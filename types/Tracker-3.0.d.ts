
/// <reference path="./GLib-2.0.d.ts" />
/// <reference path="./GModule-2.0.d.ts" />
/// <reference path="./GObject-2.0.d.ts" />
/// <reference path="./Gio-2.0.d.ts" />

/**
 * Type Definitions for GJS (https://gjs.guide/), generated by [GirGen](https://github.com/aylur/girgen)
 * If you found a bug, create a bug report on [GirGen's Repository](https://github.com/aylur/girgen/issues/new)
 */
declare module "gi://Tracker?version=3.0" {
    import type GLib from "gi://GLib?version=2.0"
    import type GModule from "gi://GModule?version=2.0"
    import type GObject from "gi://GObject?version=2.0"
    import type Gio from "gi://Gio?version=2.0"

    


    namespace Tracker {
        const __name__: "Tracker"
        const __version: "3.0"
        

        namespace Batch {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "connection": SparqlConnection
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "connection": SparqlConnection
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * `TrackerBatch` executes a series of SPARQL updates and RDF data
         * insertions within a transaction.
         *
         * A batch is created with [method@SparqlConnection.create_batch].
         * To add resources use [method@Batch.add_resource],
         * [method@Batch.add_sparql] or [method@Batch.add_statement].
         *
         * When a batch is ready for execution, use [method@Batch.execute]
         * or [method@Batch.execute_async]. The batch is executed as a single
         * transaction, it will succeed or fail entirely.
         *
         * This object has a single use, after the batch is executed it can
         * only be finished and freed.
         *
         * The mapping of blank node labels is global in a `TrackerBatch`,
         * referencing the same blank node label in different operations in
         * a batch will resolve to the same resource.
         * @since 3.1
         */
        interface Batch extends GObject.Object {
            readonly $signals: Batch.SignalSignatures
            readonly $readableProperties: Batch.ReadableProperties
            readonly $writableProperties: Batch.WritableProperties
            readonly $constructOnlyProperties: Batch.ConstructOnlyProperties
            /**
             * The [class@SparqlConnection] the batch belongs to.
             */
            get connection(): SparqlConnection
            set connection(value: SparqlConnection)
            /**
             * Inserts the RDF data contained in @stream as part of @batch.
             *
             * The RDF data will be inserted in the given @default_graph if one is provided,
             * or the anonymous graph if @default_graph is %NULL. Any RDF data that has a
             * graph specified (e.g. using the `GRAPH` clause in the Trig format) will
             * be inserted in the specified graph instead of @default_graph.
             *
             * The @flags argument is reserved for future expansions, currently
             * %TRACKER_DESERIALIZE_FLAGS_NONE must be passed.
             * @since 3.6
             * @param flags Deserialization flags
             * @param format RDF format of data in stream
             * @param default_graph Default graph that will receive the RDF data
             * @param stream Input stream with RDF data
             */
            add_rdf(flags: DeserializeFlags, format: RdfFormat, default_graph: string, stream: Gio.InputStream): void
            /**
             * Adds the RDF represented by @resource to @batch.
             * @since 3.1
             * @param graph RDF graph to insert the resource to
             * @param resource A [class@Resource]
             */
            add_resource(graph: string | null, resource: Resource): void
            /**
             * Adds an SPARQL update string to @batch.
             * @since 3.1
             * @param sparql A SPARQL update string
             */
            add_sparql(sparql: string): void
            /**
             * values[0], "John Smith");
             * tracker_batch_add_statementv (batch, stmt,
             *                               G_N_ELEMENTS (names),
             *                               names, values);
             * ```
             * ```python
             * batch.add_statement(stmt, ['name'], ['John Smith']);
             * ```
             * ```js
             * batch.add_statement(stmt, ['name'], ['John Smith']);
             * ```
             *
             * A [class@SparqlStatement] may be used on multiple [method@Batch.add_statement]
             * calls with the same or different values, on the same or different `TrackerBatch`
             * objects.
             *
             * This function should only be called on [class@SparqlStatement] objects
             * obtained through [method@SparqlConnection.update_statement] or
             * update statements loaded through [method@SparqlConnection.load_statement_from_gresource].
             * @since 3.5
             * @param stmt A [class@SparqlStatement] containing a SPARQL update
             * @param variable_names The names of each bound parameter
             * @param values The values of each bound parameter
             */
            add_statement(stmt: SparqlStatement, variable_names: string[], values: GObject.Value[]): void
            /**
             * Executes the batch. This operations happens synchronously.
             * @throws {GLib.Error}
             * @since 3.1
             * @param cancellable Optional [type@Gio.Cancellable]
             * @returns %TRUE of there were no errors, %FALSE otherwise
             */
            execute(cancellable: Gio.Cancellable | null): boolean
            /**
             * Executes the batch. This operation happens asynchronously, when
             * finished @callback will be executed.
             * @since 3.1
             * @param cancellable Optional [type@Gio.Cancellable]
             * @param callback User-defined [type@Gio.AsyncReadyCallback] to be called when
                       the asynchronous operation is finished.
             */
            execute_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Finishes the operation started with [method@Batch.execute_async].
             * @throws {GLib.Error}
             * @since 3.1
             * @param res A [type@Gio.AsyncResult] with the result of the operation
             * @returns %TRUE of there were no errors, %FALSE otherwise
             */
            execute_finish(res: Gio.AsyncResult): boolean
            /**
             * Returns the [class@SparqlConnection] that this batch was created
             * from.
             * @returns The SPARQL connection of this batch.
             */
            get_connection(): SparqlConnection
        }

        interface BatchClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Batch>
            readonly prototype: Batch
            new (props?: Partial<GObject.ConstructorProps<Batch>>): Batch
        }

        const Batch: BatchClass
        

        namespace Endpoint {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "allowed-graphs": string[]
                "allowed-services": string[]
                "readonly": boolean
                "sparql-connection": SparqlConnection
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "allowed-graphs": string[]
                "allowed-services": string[]
                "readonly": boolean
                "sparql-connection": SparqlConnection
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         *  { ... }` SPARQL
         * syntax from their own [class@SparqlConnection]s to expand their data set.
         *
         * By default, and as long as the underlying [class@SparqlConnection]
         * allows SPARQL updates and RDF graph changes, endpoints will allow updates
         * and modifications to happen through them. Use [method@Endpoint.set_readonly]
         * to change this behavior.
         *
         * By default, endpoints allow access to every RDF graph in the triple store
         * and further external SPARQL endpoints to the queries performed on it. Use
         * [method@Endpoint.set_allowed_graphs] and
         * [method@Endpoint.set_allowed_services] to change this behavior. Users do
         * not typically need to do this for D-Bus endpoints, as these do already have a layer
         * of protection with the Tracker portal. This is the mechanism used by the portal
         * itself. This access control API may not interoperate with other SPARQL endpoint
         * implementations than Tracker.
         */
        interface Endpoint extends GObject.Object {
            readonly $signals: Endpoint.SignalSignatures
            readonly $readableProperties: Endpoint.ReadableProperties
            readonly $writableProperties: Endpoint.WritableProperties
            readonly $constructOnlyProperties: Endpoint.ConstructOnlyProperties
            /**
             * RDF graphs that are allowed to be accessed
             * through queries to this endpoint. See
             * tracker_endpoint_set_allowed_graphs().
             * @since 3.7
             */
            get allowedGraphs(): string[]
            set allowedGraphs(value: string[])
            /**
             * External SPARQL endpoints that are allowed to be
             * accessed through queries to this endpint. See
             * tracker_endpoint_set_allowed_services().
             * @since 3.7
             */
            get allowedServices(): string[]
            set allowedServices(value: string[])
            /**
             * Whether the endpoint allows SPARQL updates or not. See
             * tracker_endpoint_set_readonly().
             * @since 3.7
             * @default FALSE
             */
            get readonly(): boolean
            set readonly(value: boolean)
            /**
             * The [class@SparqlConnection] being proxied by this endpoint.
             */
            get sparqlConnection(): SparqlConnection
            set sparqlConnection(value: SparqlConnection)
            /**
             * Returns the list of RDF graphs that the endpoint allows
             * access for.
             * @since 3.7
             * @returns The list of allowed RDF graphs
             */
            get_allowed_graphs(): string[]
            /**
             * Returns the list of external SPARQL endpoints that are
             * allowed to be accessed through this endpoint.
             * @since 3.7
             * @returns The list of allowed services
             */
            get_allowed_services(): string[]
            /**
             * Returns whether the endpoint is readonly, thus SPARQL update
             * queries are disallowed.
             * @since 3.7
             * @returns %TRUE if the endpoint is readonly
             */
            get_readonly(): boolean
            /**
             * Returns the [class@SparqlConnection] that this endpoint proxies
             * to a wider audience.
             * @returns The proxied SPARQL connection
             */
            get_sparql_connection(): SparqlConnection
            /**
             * Sets the list of RDF graphs that this endpoint will allow access
             * for. Any explicit (e.g. `GRAPH` keyword) or implicit (e.g. through the
             * default anonymous graph) access to RDF graphs unespecified in this
             * list in SPARQL queries will be seen as if those graphs did not exist, or
             * (equivalently) had an empty set. Changes to these graphs through SPARQL
             * updates will also be disallowed.
             *
             * If @graphs is %NULL, access will be allowed to every RDF graph stored
             * in the endpoint, this is the default behavior. If you want to forbid access
             * to all RDF graphs, use an empty list.
             *
             * The empty string (`""`) is allowed as a special value, to allow access
             * to the stock anonymous graph. All graph names are otherwise dependent
             * on the endpoint and its contained data.
             * @since 3.7
             * @param graphs List of allowed graphs, or %NULL to allow all graphs
             */
            set_allowed_graphs(graphs: string): void
            /**
             * Sets the list of external SPARQL endpoints that this endpoint
             * will allow access for. Access through the `SERVICE` SPARQL syntax
             * will fail for services not specified in this list.
             *
             * If @services is %NULL, access will be allowed to every external endpoint,
             * this is the default behavior. If you want to forbid access to all
             * external SPARQL endpoints, use an empty list.
             *
             * This affects both remote SPARQL endpoints accessed through HTTP,
             * and external SPARQL endpoints offered through D-Bus. For the latter,
             * the following syntax is allowed to describe them as an URI:
             *
             * `DBUS_URI = 'dbus:' [ ('system' | 'session') ':' ]? dbus-name [ ':' object-path ]?`
             *
             * If the system/session part is omitted, it will default to the session
             * bus. If the object path is omitted, the `/org/freedesktop/Tracker3/Endpoint`
             * [class@EndpointDBus] default will be assumed.
             * @since 3.7
             * @param services List of allowed services, or %NULL to allow all services
             */
            set_allowed_services(services: string): void
            /**
             * Sets whether the endpoint will be readonly. Readonly endpoints
             * will not allow SPARQL update queries. The underlying
             * [class@SparqlConnection] may be readonly of its own, this
             * method does not change its behavior in any way.
             * @since 3.7
             * @param readonly Whether the endpoint will be readonly
             */
            set_readonly(readonly: boolean): void
        }

        interface EndpointClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Endpoint>
            readonly prototype: Endpoint
            new (props?: Partial<GObject.ConstructorProps<Endpoint>>): Endpoint
        }

        const Endpoint: EndpointClass
        

        namespace EndpointDBus {
            interface SignalSignatures extends Endpoint.SignalSignatures, Gio.Initable.SignalSignatures {
                /**
                 * @param object
                 */
                "block-call"(object: string): boolean
            }

            interface ReadableProperties extends Endpoint.ReadableProperties, Gio.Initable.ReadableProperties {
                "dbus-connection": Gio.DBusConnection
                "object-path": string
            }

            interface WritableProperties extends Endpoint.WritableProperties, Gio.Initable.WritableProperties {
                "dbus-connection": Gio.DBusConnection
                "object-path": string
            }

            interface ConstructOnlyProperties extends Endpoint.ConstructOnlyProperties, Gio.Initable.ConstructOnlyProperties {
            }
        }

        /**
         * error);
         * ```
         *
         * The `TrackerEndpointDBus` will manage a DBus object at the given path
         * with the `org.freedesktop.Tracker3.Endpoint` interface, if no path is
         * given the object will be at the default `/org/freedesktop/Tracker3/Endpoint`
         * location.
         *
         * Access to D-Bus endpoints may be managed via the
         * [signal@EndpointDBus::block-call] signal, the boolean
         * return value expressing whether the request is blocked or not.
         * Inspection of the requester address is left up to the user. The
         * default value allows all requests independently of their provenance.
         *
         * However, moderating access to D-Bus interfaces is typically not necessary
         * in user code, as access to public D-Bus endpoints will be transparently
         * managed through the Tracker portal service for applications sandboxed
         * via XDG portals. These already have access to D-Bus SPARQL endpoints and
         * their data naturally filtered as defined in the application manifest.
         *
         * A `TrackerEndpointDBus` may be created on a different thread/main
         * context from the one that created [class@SparqlConnection].
         */
        interface EndpointDBus extends Endpoint, Gio.Initable {
            readonly $signals: EndpointDBus.SignalSignatures
            readonly $readableProperties: EndpointDBus.ReadableProperties
            readonly $writableProperties: EndpointDBus.WritableProperties
            readonly $constructOnlyProperties: EndpointDBus.ConstructOnlyProperties
            /**
             * The [class@Gio.DBusConnection] where the connection is proxied through.
             */
            get dbusConnection(): Gio.DBusConnection
            set dbusConnection(value: Gio.DBusConnection)
            /**
             * The DBus object path that this endpoint manages.
             * @default NULL
             */
            get objectPath(): string
            set objectPath(value: string)
        }

        interface EndpointDBusClass extends Omit<EndpointClass, "new"> {
            readonly $gtype: GObject.GType<EndpointDBus>
            readonly prototype: EndpointDBus
            new (props?: Partial<GObject.ConstructorProps<EndpointDBus>>): EndpointDBus
            /**
             * Registers a Tracker endpoint object at @object_path on @dbus_connection.
             * The default object path is `/org/freedesktop/Tracker3/Endpoint`.
             * @throws {GLib.Error}
             * @param sparql_connection The [class@SparqlConnection] being made public
             * @param dbus_connection #GDBusConnection to expose the DBus object over
             * @param object_path The object path to use, or %NULL to use the default
             * @param cancellable Optional [type@Gio.Cancellable]
             * @returns a `TrackerEndpointDBus` object.
             */
            "new"(sparql_connection: SparqlConnection, dbus_connection: Gio.DBusConnection, object_path: string | null, cancellable: Gio.Cancellable | null): EndpointDBus
        }

        const EndpointDBus: EndpointDBusClass
        

        namespace EndpointHttp {
            interface SignalSignatures extends Endpoint.SignalSignatures, Gio.Initable.SignalSignatures {
                /**
                 * Allows control over the connections stablished. The given
                 * address is that of the requesting peer.
                 *
                 * Returning %FALSE in this handler allows the connection,
                 * returning %TRUE blocks it. The default with no signal
                 * handlers connected is %FALSE.
                 * @param address The socket address of the remote connection
                 */
                "block-remote-address"(address: Gio.SocketAddress): boolean
            }

            interface ReadableProperties extends Endpoint.ReadableProperties, Gio.Initable.ReadableProperties {
                "http-certificate": Gio.TlsCertificate
                "http-port": number
            }

            interface WritableProperties extends Endpoint.WritableProperties, Gio.Initable.WritableProperties {
                "http-certificate": Gio.TlsCertificate
                "http-port": number
            }

            interface ConstructOnlyProperties extends Endpoint.ConstructOnlyProperties, Gio.Initable.ConstructOnlyProperties {
            }
        }

        /**
         * error);
         *
         * // From another host
         * connection = tracker_sparql_connection_remote_new ("http://example.local:8080/sparql");
         * ```
         *
         * Access to HTTP endpoints may be managed via the
         * [signal@EndpointHttp::block-remote-address] signal, the boolean
         * return value expressing whether the connection is blocked or not.
         * Inspection of the requester address is left up to the user. The
         * default value allows all requests independently of their provenance,
         * users are encouraged to add a handler.
         *
         * If the provided [class@Gio.TlsCertificate] is %NULL, the endpoint will allow
         * plain HTTP connections. Users are encouraged to provide a certificate
         * in order to use HTTPS.
         *
         * As a security measure, and in compliance specifications,
         * the HTTP endpoint does not handle database updates or modifications in any
         * way. The database content is considered to be entirely managed by the
         * process that creates the HTTP endpoint and owns the [class@SparqlConnection].
         *
         * A `TrackerEndpointHttp` may be created on a different thread/main
         * context from the one that created [class@SparqlConnection].
         * @since 3.1
         */
        interface EndpointHttp extends Endpoint, Gio.Initable {
            readonly $signals: EndpointHttp.SignalSignatures
            readonly $readableProperties: EndpointHttp.ReadableProperties
            readonly $writableProperties: EndpointHttp.WritableProperties
            readonly $constructOnlyProperties: EndpointHttp.ConstructOnlyProperties
            /**
             * [class@Gio.TlsCertificate] to encrypt the communication.
             */
            get httpCertificate(): Gio.TlsCertificate
            set httpCertificate(value: Gio.TlsCertificate)
            /**
             * HTTP port used to listen requests.
             * @default 8080
             */
            get httpPort(): number
            set httpPort(value: number)
        }

        interface EndpointHttpClass extends Omit<EndpointClass, "new"> {
            readonly $gtype: GObject.GType<EndpointHttp>
            readonly prototype: EndpointHttp
            new (props?: Partial<GObject.ConstructorProps<EndpointHttp>>): EndpointHttp
            /**
             * Sets up a Tracker endpoint to listen via HTTP, in the given @port.
             * If @certificate is not %NULL, HTTPS may be used to connect to the
             * endpoint.
             * @throws {GLib.Error}
             * @since 3.1
             * @param sparql_connection The [class@SparqlConnection] being made public
             * @param port HTTP port to handle incoming requests
             * @param certificate Optional [type@Gio.TlsCertificate] to use for encription
             * @param cancellable Optional [type@Gio.Cancellable]
             * @returns a `TrackerEndpointHttp` object.
             */
            "new"(sparql_connection: SparqlConnection, port: number, certificate: Gio.TlsCertificate | null, cancellable: Gio.Cancellable | null): EndpointHttp
        }

        const EndpointHttp: EndpointHttpClass
        

        namespace NamespaceManager {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * `TrackerNamespaceManager` object represents a mapping between namespaces and
         * their shortened prefixes.
         *
         * This object keeps track of namespaces, and allows you to assign
         * short prefixes for them to avoid frequent use of full namespace IRIs. The syntax
         * used is that of [Compact URIs (CURIEs)](https://www.w3.org/TR/2010/NOTE-curie-20101216).
         *
         * Usually you will want to use a namespace manager obtained through
         * [method@SparqlConnection.get_namespace_manager] from the
         * [class@SparqlConnection] that manages the RDF data, as that will
         * contain all prefixes and namespaces that are pre-defined by its ontology.
         */
        interface NamespaceManager extends GObject.Object {
            readonly $signals: NamespaceManager.SignalSignatures
            readonly $readableProperties: NamespaceManager.ReadableProperties
            readonly $writableProperties: NamespaceManager.WritableProperties
            readonly $constructOnlyProperties: NamespaceManager.ConstructOnlyProperties
            /**
             * Adds @prefix as the recognised abbreviation of @namespace.
             *
             * Since 3.3, The `TrackerNamespaceManager` instances obtained through
             * [method@SparqlConnection.get_namespace_manager] are "sealed",
             * this API call should not performed on those.
             * @param prefix a short, unique prefix to identify @namespace
             * @param ns the URL of the given namespace
             */
            add_prefix(prefix: string, ns: string): void
            /**
             * If @uri begins with one of the namespaces known to this
             * `TrackerNamespaceManager`, then the return value will be the
             * compressed URI. Otherwise, %NULL will be returned.
             * @since 3.3
             * @param uri a URI or compact URI
             * @returns (nullable): the compressed URI
             */
            compress_uri(uri: string): string
            /**
             * If @compact_uri begins with one of the prefixes known to this
             * `TrackerNamespaceManager`, then the return value will be the
             * expanded URI. Otherwise, a copy of @compact_uri will be returned.
             * @param compact_uri a URI or compact URI
             * @returns The possibly expanded URI in a newly-allocated string.
             */
            expand_uri(compact_uri: string): string
            /**
             * Calls @func for each known prefix / URI pair.
             * @param func the function to call for each prefix / URI pair
             */
            foreach(func: GLib.HFunc): void
            /**
             * Returns whether @prefix is known.
             * @param prefix a string
             * @returns %TRUE if the `TrackerNamespaceManager` knows about `prefix`, %FALSE otherwise
             */
            has_prefix(prefix: string): boolean
            /**
             * Looks up the namespace URI corresponding to @prefix, or %NULL if the prefix
             * is not known.
             * @param prefix a string
             * @returns a string owned by the `TrackerNamespaceManager`, or %NULL
             */
            lookup_prefix(prefix: string): string | null
            /**
             * Writes out all namespaces as `@prefix` statements in
             * the [Turtle](https://www.w3.org/TR/turtle/) RDF format.
             * @returns a newly-allocated string
             */
            print_turtle(): string
        }

        interface NamespaceManagerClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<NamespaceManager>
            readonly prototype: NamespaceManager
            new (props?: Partial<GObject.ConstructorProps<NamespaceManager>>): NamespaceManager
            /**
             * Creates a new, empty `TrackerNamespaceManager` instance.
             * @returns a new `TrackerNamespaceManager` instance
             */
            "new"(): NamespaceManager
            /**
             * Returns the global `TrackerNamespaceManager` that contains a set of well-known
             * namespaces and prefixes, such as `rdf:`, `rdfs:`, `nie:`, `tracker:`, etc.
             *
             * Note that the list of prefixes and namespaces is hardcoded in
             * libtracker-sparql. It may not correspond with the installed set of
             * ontologies, if they have been modified since they were installed.
             * @deprecated since 3.3 Use [method@SparqlConnection.get_namespace_manager] instead.
             * @returns a global, shared `TrackerNamespaceManager` instance
             */
            get_default(): NamespaceManager
        }

        const NamespaceManager: NamespaceManagerClass
        

        namespace Notifier {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
                /**
                 * Notifies of changes in the Tracker database.
                 * @param service The SPARQL service that originated the events, %NULL for the local store
                 * @param graph The graph where the events happened on, %NULL for the default anonymous graph
                 * @param events A [type@GLib.PtrArray] of [struct@NotifierEvent]
                 */
                "events"(service: string, graph: string, events: NotifierEvent[]): void
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "connection": SparqlConnection
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "connection": SparqlConnection
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * `TrackerNotifier` allows receiving notification on changes
         * in the data stored by a [class@SparqlConnection].
         *
         * This object may be created through [method@SparqlConnection.create_notifier],
         * events can then be listened for by connecting to the
         * [signal@Notifier::events] signal.
         *
         * Not every change is notified, only RDF resources with a
         * class that has the [nrl:notify](nrl-ontology.html#nrl:notify)
         * property defined by the ontology will be notified upon changes.
         *
         * Database changes are communicated through [struct@NotifierEvent] events on
         * individual graph/resource pairs. The event type obtained through
         * [method@NotifierEvent.get_event_type] will determine the type of event.
         * Insertion of new resources is notified through
         * %TRACKER_NOTIFIER_EVENT_CREATE events, deletion of
         * resources is notified through %TRACKER_NOTIFIER_EVENT_DELETE
         * events, and changes on any property of the resource is notified
         * through %TRACKER_NOTIFIER_EVENT_UPDATE events.
         *
         * The events happen in reaction to database changes, after a `TrackerNotifier`
         * received an event of type %TRACKER_NOTIFIER_EVENT_DELETE, the resource will
         * not exist anymore and only the information in the [struct@NotifierEvent]
         * will remain.
         *
         * Similarly, when receiving an event of type %TRACKER_NOTIFIER_EVENT_UPDATE,
         * the resource will have already changed, so the data previous to the update is
         * no longer available.
         *
         * The [signal@Notifier::events] signal is emitted in the thread-default
         * main context of the thread where the `TrackerNotifier` instance was created.
         */
        interface Notifier extends GObject.Object {
            readonly $signals: Notifier.SignalSignatures
            readonly $readableProperties: Notifier.ReadableProperties
            readonly $writableProperties: Notifier.WritableProperties
            readonly $constructOnlyProperties: Notifier.ConstructOnlyProperties
            /**
             * SPARQL connection to listen to.
             */
            get connection(): SparqlConnection
            set connection(value: SparqlConnection)
            /**
             * Listens to notification events from a remote DBus SPARQL endpoint.
             *
             * If @connection refers to a message bus (system/session), @service must refer
             * to a D-Bus name (either unique or well-known). If @connection is a non-message
             * bus (e.g. a peer-to-peer D-Bus connection) the @service argument may be %NULL.
             *
             * If the @object_path argument is %NULL, the default
             * `/org/freedesktop/Tracker3/Endpoint` path will be
             * used. If @graph is %NULL, all graphs will be listened for.
             *
             * The signal subscription can be removed with
             * [method@Notifier.signal_unsubscribe].
             *
             * Note that this call is not necessary to receive notifications on
             * a connection obtained through [ctor@SparqlConnection.bus_new],
             * only to listen to update notifications from additional DBus endpoints.
             * @param connection A [class@Gio.DBusConnection]
             * @param service DBus service name to subscribe to events for, or %NULL
             * @param object_path DBus object path to subscribe to events for, or %NULL
             * @param graph Graph to listen events for, or %NULL
             * @returns An ID for this subscription
             */
            signal_subscribe(connection: Gio.DBusConnection, service: string | null, object_path: string | null, graph: string | null): number
            /**
             * Undoes a signal subscription done through [method@Notifier.signal_subscribe].
             *
             * The @handler_id argument was previously obtained during signal subscription creation.
             * @param handler_id A signal subscription handler ID
             */
            signal_unsubscribe(handler_id: number): void
        }

        interface NotifierClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Notifier>
            readonly prototype: Notifier
            new (props?: Partial<GObject.ConstructorProps<Notifier>>): Notifier
        }

        const Notifier: NotifierClass
        

        namespace Resource {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "identifier": string | null
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "identifier": string | null
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * `TrackerResource` is an in-memory representation of RDF data about a given resource.
         *
         * This object keeps track of a set of properties for a given resource, and can
         * also link to other `TrackerResource` objects to form trees or graphs of RDF
         * data. See [method@Resource.set_relation] and [method@Resource.set_uri]
         * on how to link a `TrackerResource` to other RDF data.
         *
         * `TrackerResource` may also hold data about literal values, added through
         * the specialized [method@Resource.set_int64], [method@Resource.set_string],
         * etc family of functions, or the generic [method@Resource.set_gvalue] method.
         *
         * Since RDF properties may be multi-valued, for every `set` call there exists
         * another `add` call (e.g. [method@Resource.add_int64], [method@Resource.add_string]
         * and so on). The `set` methods do also reset any previously value the
         * property might hold for the given resource.
         *
         * Resources may have an IRI set at creation through [ctor@Resource.new],
         * or set afterwards through [method@Resource.set_identifier]. Resources
         * without a name will represent a blank node, and will be dealt with as such
         * during database insertions.
         *
         * `TrackerResource` performs no validation on the data being coherent as per
         * any ontology. Errors will be found out at the time of using the TrackerResource
         * for e.g. database updates.
         *
         * Once the RDF data is built in memory, the (tree of) `TrackerResource` may be
         * converted to a RDF format through [method@Resource.print_rdf], or
         * directly inserted into a database through [method@Batch.add_resource]
         * or [method@SparqlConnection.update_resource].
         */
        interface Resource extends GObject.Object {
            readonly $signals: Resource.SignalSignatures
            readonly $readableProperties: Resource.ReadableProperties
            readonly $writableProperties: Resource.WritableProperties
            readonly $constructOnlyProperties: Resource.ConstructOnlyProperties
            /**
             * The URI identifier for this class, or %NULL for a
             * blank node.
             * @default NULL
             */
            get identifier(): string | null
            set identifier(value: string | null)
            /**
             * Adds a boolean property. Previous values for the same property are kept.
             *
             * This method is meant for RDF properties allowing multiple values, see
             * [nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).
             *
             * This method corresponds to [xsd:boolean](xsd-ontology.html#xsd:boolean).
             * @param property_uri A string identifying the property to modify
             * @param value The property boolean value
             */
            add_boolean(property_uri: string, value: boolean): void
            /**
             * Adds a date property as a [type@GLib.DateTime]. Previous values for the
             * same property are kept.
             *
             * This method is meant for RDF properties allowing multiple values, see
             * [nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).
             *
             * This method corresponds to [xsd:date](xsd-ontology.html#xsd:date) and
             * [xsd:dateTime](xsd-ontology.html#xsd:dateTime).
             * @since 3.2
             * @param property_uri a string identifying the property to modify
             * @param value the property object
             */
            add_datetime(property_uri: string, value: GLib.DateTime): void
            /**
             * Adds a numeric property with double precision. Previous values for the same property are kept.
             *
             * This method is meant for RDF properties allowing multiple values, see
             * [nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).
             *
             * This method corresponds to [xsd:double](xsd-ontology.html#xsd:double).
             * @param property_uri a string identifying the property to modify
             * @param value the property object
             */
            add_double(property_uri: string, value: number): void
            /**
             * Add @value to the list of values for given property.
             *
             * You can pass any kind of [struct@GObject.Value] for @value, but serialization functions will
             * normally only be able to serialize URIs/relationships and fundamental value
             * types (string, int, etc.).
             * @param property_uri a string identifying the property to set
             * @param value an initialised [struct@GObject.Value]
             */
            add_gvalue(property_uri: string, value: (GObject.Value | unknown)): void
            /**
             * Adds a numeric property with integer precision. Previous values for the same property are kept.
             *
             * This method is meant for RDF properties allowing multiple values, see
             * [nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).
             *
             * This method corresponds to [xsd:integer](xsd-ontology.html#xsd:integer).
             * @param property_uri a string identifying the property to modify
             * @param value the property object
             */
            add_int(property_uri: string, value: number): void
            /**
             * Adds a numeric property with 64-bit integer precision. Previous values for the same property are kept.
             *
             * This method is meant for RDF properties allowing multiple values, see
             * [nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).
             *
             * This method corresponds to [xsd:integer](xsd-ontology.html#xsd:integer).
             * @param property_uri a string identifying the property to modify
             * @param value the property object
             */
            add_int64(property_uri: string, value: number): void
            /**
             * Adds a resource property as a `TrackerResource`. Previous values for the same property are kept.
             *
             * This method is meant for RDF properties allowing multiple values, see
             * [nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).
             *
             * This method applies to properties with a [rdfs:range](rdf-ontology.html#rdfs:range)
             * that points to a non-literal class (i.e. a subclass of
             * [rdfs:Resource](rdf-ontology.html#rdfs:Resource)).
             *
             * This method produces similar RDF to [method@Resource.add_uri],
             * although in this function the URI will depend on the identifier
             * set on @resource.
             * @param property_uri a string identifying the property to modify
             * @param resource the property object
             */
            add_relation(property_uri: string, resource: Resource): void
            /**
             * Adds a string property. Previous values for the same property are kept.
             *
             * This method is meant for RDF properties allowing multiple values, see
             * [nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).
             *
             * This method corresponds to [xsd:string](xsd-ontology.html#xsd:string).
             * @param property_uri a string identifying the property to modify
             * @param value the property object
             */
            add_string(property_uri: string, value: string): void
            /**
             * Adds a resource property as a `TrackerResource`. Previous values for the same property are kept.
             * Takes ownership on the given @resource.
             *
             * This method is meant to RDF properties allowing multiple values, see
             * [nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).
             *
             * This method applies to properties with a [rdfs:range](rdf-ontology.html#rdfs:range)
             * that points to a non-literal class (i.e. a subclass of
             * [rdfs:Resource](rdf-ontology.html#rdfs:Resource)).
             *
             * This function produces similar RDF to [method@Resource.add_uri],
             * although in this function the URI will depend on the identifier
             * set on @resource. This function takes ownership of @resource.
             * @param property_uri a string identifying the property to modify
             * @param resource the property object
             */
            add_take_relation(property_uri: string, resource: Resource): void
            /**
             * Adds a resource property as an URI string. Previous values for the same property are kept.
             *
             * This method applies to properties with a [rdfs:range](rdf-ontology.html#rdfs:range)
             * that points to a non-literal class (i.e. a subclass of
             * [rdfs:Resource](rdf-ontology.html#rdfs:Resource)).
             *
             * This method is meant for RDF properties allowing multiple values, see
             * [nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).
             *
             * This function produces similar RDF to [method@Resource.add_relation], although
             * it requires that the URI is previously known.
             * @param property_uri a string identifying the property to modify
             * @param value the property object
             */
            add_uri(property_uri: string, value: string): void
            /**
             * Returns the first boolean object previously assigned to a property.
             * @param property_uri a string identifying the property to look up
             * @returns the first boolean object
             */
            get_first_boolean(property_uri: string): boolean
            /**
             * Returns the first [type@GLib.DateTime] previously assigned to a property.
             * @since 3.2
             * @param property_uri a string identifying the property to look up
             * @returns the first GDateTime object
             */
            get_first_datetime(property_uri: string): GLib.DateTime | null
            /**
             * Returns the first double object previously assigned to a property.
             * @param property_uri a string identifying the property to look up
             * @returns the first double object
             */
            get_first_double(property_uri: string): number
            /**
             * Returns the first integer object previously assigned to a property.
             * @param property_uri a string identifying the property to look up
             * @returns the first integer object
             */
            get_first_int(property_uri: string): number
            /**
             * Returns the first integer object previously assigned to a property.
             * @param property_uri a string identifying the property to look up
             * @returns the first integer object
             */
            get_first_int64(property_uri: string): number
            /**
             * Returns the first resource object previously assigned to a property.
             * @param property_uri a string identifying the property to look up
             * @returns the first resource object
             */
            get_first_relation(property_uri: string): Resource | null
            /**
             * Returns the first string object previously assigned to a property.
             * @param property_uri a string identifying the property to look up
             * @returns the first string object
             */
            get_first_string(property_uri: string): string | null
            /**
             * Returns the first resource object previously assigned to a property.
             * @param property_uri a string identifying the property to look up
             * @returns the first resource object as an URI.
             */
            get_first_uri(property_uri: string): string | null
            /**
             * Returns the identifier of a resource.
             *
             * If the identifier was set to NULL, the identifier returned will be a locally
             * unique SPARQL blank node identifier, such as `_:123`.
             * @returns a string owned by the resource
             */
            get_identifier(): string | null
            /**
             * Gets the list of properties defined in @resource
             * @returns The list of properties.
             */
            get_properties(): string[]
            /**
             * Returns whether the prior values for this property would be deleted
             * in the SPARQL issued by @resource.
             * @since 3.1
             * @param property_uri a string identifying the property to query
             * @returns #TRUE if the property would be overwritten
             */
            get_property_overwrite(property_uri: string): boolean
            /**
             * Returns the list of all known values of the given property.
             * @param property_uri a string identifying the property to look up
             * @returns a [struct@GLib.List] of   [struct@GObject.Value] instances. The list should be freed with [func@GLib.List.free]
             */
            get_values(property_uri: string): GObject.Value[] | null
            /**
             * A helper function that compares a `TrackerResource` by its identifier
             * string.
             * @param identifier a string identifying the resource
             * @returns  than `identifier`
             */
            identifier_compare_func(identifier: string): number
            /**
             *  for more information on the JSON-LD
             * serialization format.
             *
             * The @namespaces object is used to expand any compact URI values. In most
             * cases you should pass the one returned by [method@SparqlConnection.get_namespace_manager]
             * from the connection that is the intended recipient of this data.
             * @deprecated since 3.5 Use [method@Resource.print_rdf] instead.
             * @param namespaces a set of prefixed URLs, or %NULL to use the
                Nepomuk set
             * @returns a newly-allocated string containing JSON-LD data.
             */
            print_jsonld(namespaces: NamespaceManager | null): string
            /**
             * Serialize all the information in @resource into the selected RDF format.
             *
             * The @namespaces object is used to expand any compact URI values. In most
             * cases you should pass the one returned by [method@SparqlConnection.get_namespace_manager]
             * from the connection that is the intended recipient of this data.
             * @since 3.4
             * @param namespaces a set of prefixed URLs
             * @param format RDF format of the printed string
             * @param graph target graph of the resource RDF, or %NULL for the
            default graph
             * @returns a newly-allocated string containing RDF data in the requested format.
             */
            print_rdf(namespaces: NamespaceManager, format: RdfFormat, graph: string | null): string
            /**
             * Generates a SPARQL command to update a database with the information
             * stored in @resource.
             *
             * The @namespaces object is used to expand any compact URI values. In most
             * cases you should pass the one returned by [method@SparqlConnection.get_namespace_manager]
             * from the connection that is the intended recipient of this data.
             * @param namespaces a set of prefixed URLs, or %NULL to use the
                Nepomuk set
             * @param graph_id the URN of the graph the data should be added to,
                or %NULL
             * @returns a newly-allocated string containing a SPARQL update command.
             */
            print_sparql_update(namespaces: NamespaceManager | null, graph_id: string | null): string
            /**
             *
             *
             * The @namespaces object is used to expand any compact URI values. In most
             * cases you should pass the one returned by [method@SparqlConnection.get_namespace_manager]
             * from the connection that is the intended recipient of this data.
             * @deprecated since 3.4 Use [method@Resource.print_rdf] instead.
             * @param namespaces a set of prefixed URLs, or %NULL to use the
                Nepomuk set
             * @returns a newly-allocated string
             */
            print_turtle(namespaces: NamespaceManager | null): string
            /**
             * Serializes a `TrackerResource` to a [type@GLib.Variant] in a lossless way.
             * All child resources are subsequently serialized. It is implied
             * that both ends use a common [class@NamespaceManager].
             * @returns A variant describing the resource,          the reference is floating.
             */
            serialize(): GLib.Variant | null
            /**
             * Sets a boolean property. Replaces any previous value.
             *
             * This method corresponds to [xsd:boolean](xsd-ontology.html#xsd:boolean).
             * @param property_uri A string identifying the property to modify
             * @param value The property boolean value
             */
            set_boolean(property_uri: string, value: boolean): void
            /**
             * Sets a date property as a [type@GLib.DateTime]. Replaces any previous value.
             *
             * This method corresponds to [xsd:date](xsd-ontology.html#xsd:date) and
             * [xsd:dateTime](xsd-ontology.html#xsd:dateTime).
             * @since 3.2
             * @param property_uri a string identifying the property to modify
             * @param value the property object
             */
            set_datetime(property_uri: string, value: GLib.DateTime): void
            /**
             * Sets a numeric property with double precision. Replaces any previous value.
             *
             * This method corresponds to [xsd:double](xsd-ontology.html#xsd:double).
             * @param property_uri A string identifying the property to modify
             * @param value The property object
             */
            set_double(property_uri: string, value: number): void
            /**
             * Replace any previously existing value for @property_uri with @value.
             *
             * When serialising to SPARQL, any properties that were set with this function
             * will get a corresponding DELETE statement to remove any existing values in
             * the database.
             *
             * You can pass any kind of [struct@GObject.Value] for @value, but serialization functions will
             * normally only be able to serialize URIs/relationships and fundamental value
             * types (string, int, etc.).
             * @param property_uri a string identifying the property to set
             * @param value an initialised [struct@GObject.Value]
             */
            set_gvalue(property_uri: string, value: (GObject.Value | unknown)): void
            /**
             * Changes the identifier of a `TrackerResource`. The identifier should be a
             * URI or compact URI, but this is not necessarily enforced. Invalid
             * identifiers may cause errors when serializing the resource or trying to
             * insert the results in a database.
             *
             * If the identifier is set to %NULL, a SPARQL blank node identifier such as
             * `_:123` is assigned to the resource.
             * @param identifier a string identifying the resource
             */
            set_identifier(identifier: string | null): void
            /**
             * Sets a numeric property with integer precision. Replaces any previous value.
             *
             * This method corresponds to [xsd:integer](xsd-ontology.html#xsd:integer).
             * @param property_uri A string identifying the property to modify
             * @param value The property object
             */
            set_int(property_uri: string, value: number): void
            /**
             * Sets a numeric property with 64-bit integer precision. Replaces any previous value.
             *
             * This method corresponds to [xsd:integer](xsd-ontology.html#xsd:integer).
             * @param property_uri a string identifying the property to modify
             * @param value the property object
             */
            set_int64(property_uri: string, value: number): void
            /**
             * Sets a resource property as a `TrackerResource`. Replaces any previous value.
             *
             * This method applies to properties with a [rdfs:range](rdf-ontology.html#rdfs:range)
             * that points to a non-literal class (i.e. a subclass of
             * [rdfs:Resource](rdf-ontology.html#rdfs:Resource)).
             *
             * This function produces similar RDF to [method@Resource.set_uri],
             * although in this function the URI will depend on the identifier
             * set on @resource.
             * @param property_uri a string identifying the property to modify
             * @param resource the property object
             */
            set_relation(property_uri: string, resource: Resource): void
            /**
             * Sets a string property. Replaces any previous value.
             *
             * This method corresponds to [xsd:string](xsd-ontology.html#xsd:string).
             * @param property_uri a string identifying the property to modify
             * @param value the property object
             */
            set_string(property_uri: string, value: string): void
            /**
             * Sets a resource property as a `TrackerResource`. Replaces any previous value.
             * Takes ownership on the given @resource.
             *
             * This method applies to properties with a [rdfs:range](rdf-ontology.html#rdfs:range)
             * that points to a non-literal class (i.e. a subclass of
             * [rdfs:Resource](rdf-ontology.html#rdfs:Resource)).
             *
             * This function produces similar RDF to [method@Resource.set_uri],
             * although in this function the URI will depend on the identifier
             * set on @resource.
             * @param property_uri a string identifying the property to modify
             * @param resource the property object
             */
            set_take_relation(property_uri: string, resource: Resource): void
            /**
             * Sets a resource property as an URI string. Replaces any previous value.
             *
             * This method applies to properties with a [rdfs:range](rdf-ontology.html#rdfs:range)
             * that points to a non-literal class (i.e. a subclass of
             * [rdfs:Resource](rdf-ontology.html#rdfs:Resource)).
             *
             * This function produces similar RDF to [method@Resource.set_relation], although
             * it requires that the URI is previously known.
             * @param property_uri a string identifying the property to modify
             * @param value the property object
             */
            set_uri(property_uri: string, value: string): void
        }

        interface ResourceClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Resource>
            readonly prototype: Resource
            new (props?: Partial<GObject.ConstructorProps<Resource>>): Resource
            /**
             * Creates a TrackerResource instance.
             * @param identifier A string containing a URI, or %NULL.
             * @returns a newly created `TrackerResource`.
             */
            "new"(identifier: string | null): Resource
            /**
             * Deserializes a `TrackerResource` previously serialized with
             * [method@Resource.serialize]. It is implied that both ends
             * use a common [class@NamespaceManager].
             * @param variant a [type@GLib.Variant]
             * @returns A TrackerResource, or %NULL if          deserialization fails.
             */
            deserialize(variant: GLib.Variant): Resource | null
        }

        const Resource: ResourceClass
        

        namespace SparqlConnection {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * `TrackerSparqlConnection` holds a connection to a RDF triple store.
         *
         * This triple store may be of three types:
         *
         *  - Local to the process, created through [ctor@SparqlConnection.new].
         *  - A HTTP SPARQL endpoint over the network, created through
         *    [ctor@SparqlConnection.remote_new]
         *  - A DBus SPARQL endpoint owned by another process in the same machine, created
         *    through [ctor@SparqlConnection.bus_new]
         *
         * When creating a local triple store, it is required to give details about its
         * structure. This is done by passing a location to an ontology, see more
         * on how are [ontologies defined](ontologies.html). A local database may be
         * stored in a filesystem location, or it may reside in memory.
         *
         * A `TrackerSparqlConnection` is private to the calling process, it can be
         * exposed to other hosts/processes via a [class@Endpoint], see
         * [ctor@EndpointDBus.new] and [ctor@EndpointHttp.new].
         *
         * When issuing SPARQL queries and updates, it is recommended that these are
         * created through [class@SparqlStatement] to avoid the SPARQL
         * injection class of bugs, see [method@SparqlConnection.query_statement]
         * and [method@SparqlConnection.update_statement]. For SPARQL updates
         * it is also possible to use a "builder" approach to generate RDF data, see
         * [class@Resource]. It is also possible to create [class@SparqlStatement]
         * objects for SPARQL queries and updates from SPARQL strings embedded in a
         * [struct@Gio.Resource], see [method@SparqlConnection.load_statement_from_gresource].
         *
         * To get the best performance, it is recommended that SPARQL updates are clustered
         * through [class@Batch].
         *
         * `TrackerSparqlConnection` also offers a number of methods for the simple cases,
         * [method@SparqlConnection.query] may be used when there is a SPARQL
         * query string directly available, and the [method@SparqlConnection.update]
         * family of functions may be used for one-off updates. All functions have asynchronous
         * variants.
         *
         * When a SPARQL query is executed, a [class@SparqlCursor] will be obtained
         * to iterate over the query results.
         *
         * Depending on the ontology definition, `TrackerSparqlConnection` may emit
         * notifications whenever resources of certain types get insert, modified or
         * deleted from the triple store (see [nrl:notify](nrl-ontology.html#nrl:notify).
         * These notifications can be handled via a [class@Notifier] obtained with
         * [method@SparqlConnection.create_notifier].
         *
         * After done with a connection, it is recommended to call [method@SparqlConnection.close]
         * or [method@SparqlConnection.close_async] explicitly to cleanly close the
         * connection and prevent consistency checks on future runs. The triple store
         * connection will be implicitly closed when the `TrackerSparqlConnection` object
         * is disposed.
         *
         * A `TrackerSparqlConnection` may be used from multiple threads, asynchronous
         * updates are executed sequentially on arrival order, asynchronous
         * queries are dispatched in a thread pool.
         *
         * If you ever have the need to procedurally compose SPARQL query strings, consider
         * the use of [func@sparql_escape_string] for literal strings and
         * the [func@sparql_escape_uri] family of functions for URIs.
         */
        interface SparqlConnection extends GObject.Object {
            readonly $signals: SparqlConnection.SignalSignatures
            readonly $readableProperties: SparqlConnection.ReadableProperties
            readonly $writableProperties: SparqlConnection.WritableProperties
            readonly $constructOnlyProperties: SparqlConnection.ConstructOnlyProperties
            /**
             * Closes a SPARQL connection.
             *
             * No other API calls than g_object_unref() should happen after this call.
             *
             * This call is blocking. All pending updates will be flushed, and the
             * store databases will be closed orderly. All ongoing SELECT queries
             * will be cancelled. Notifiers will no longer emit events.
             */
            close(): void
            /**
             * Closes a SPARQL connection asynchronously.
             *
             * No other API calls than g_object_unref() should happen after this call.
             * @param cancellable Optional [type@Gio.Cancellable]
             * @param callback User-defined [type@Gio.AsyncReadyCallback] to be called when
                       the asynchronous operation is finished.
             */
            close_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Finishes the operation started with [method@SparqlConnection.close_async].
             * @throws {GLib.Error}
             * @param res A [type@Gio.AsyncResult] with the result of the operation
             * @returns %FALSE if some error occurred, %TRUE otherwise
             */
            close_finish(res: Gio.AsyncResult): boolean
            /**
             * Creates a new [class@Batch] to store and execute SPARQL updates.
             *
             * If the connection is readonly or cannot issue SPARQL updates, %NULL will be returned.
             * @returns (nullable): A new [class@Batch]
             */
            create_batch(): Batch
            /**
             * Creates a new [class@Notifier] to receive notifications about changes in @connection.
             *
             * See [class@Notifier] documentation for information about how to use this
             * object.
             *
             * Connections to HTTP endpoints will return %NULL.
             * @returns A newly created notifier.
             */
            create_notifier(): Notifier | null
            /**
             * Loads the RDF data contained in @stream into the given @connection.
             *
             * This is an asynchronous operation, @callback will be invoked when the
             * data has been fully inserted to @connection.
             *
             * The RDF data will be inserted in the given @default_graph if one is provided,
             * or the anonymous graph if @default_graph is %NULL. Any RDF data that has a
             * graph specified (e.g. using the `GRAPH` clause in the Trig format) will
             * be inserted in the specified graph instead of @default_graph.
             *
             * The @flags argument is reserved for future expansions, currently
             * %TRACKER_DESERIALIZE_FLAGS_NONE must be passed.
             * @since 3.4
             * @param flags Deserialization flags
             * @param format RDF format of data in stream
             * @param default_graph Default graph that will receive the RDF data
             * @param stream Input stream with RDF data
             * @param cancellable Optional [type@Gio.Cancellable]
             * @param callback User-defined [type@Gio.AsyncReadyCallback] to be called when
                       the asynchronous operation is finished.
             */
            deserialize_async(flags: DeserializeFlags, format: RdfFormat, default_graph: string, stream: Gio.InputStream, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Finishes the operation started with [method@SparqlConnection.deserialize_async].
             * @throws {GLib.Error}
             * @since 3.4
             * @param result A [type@Gio.AsyncResult] with the result of the operation
             * @returns %TRUE if all data was inserted successfully.
             */
            deserialize_finish(result: Gio.AsyncResult): boolean
            /**
             * Returns a [class@NamespaceManager] that contains all
             * prefixes in the ontology of @connection.
             * @returns a [class@NamespaceManager] with the prefixes of `connection`.
             */
            get_namespace_manager(): NamespaceManager
            /**
             * Prepares a [class@SparqlStatement] for the SPARQL contained as a [struct@Gio.Resource]
             * file at @resource_path.
             *
             * SPARQL Query files typically have the .rq extension. This will use
             * [method@SparqlConnection.query_statement] or [method@SparqlConnection.update_statement]
             * underneath to indistinctly return SPARQL query or update statements.
             * @throws {GLib.Error}
             * @since 3.3
             * @param resource_path The resource path of the file to parse.
             * @param cancellable Optional [type@Gio.Cancellable]
             * @returns A prepared statement
             */
            load_statement_from_gresource(resource_path: string, cancellable: Gio.Cancellable | null): SparqlStatement
            /**
             *  {
             *     ?u a rdfs:Resource
             *   }
             * }
             * ```
             *
             * This is useful to interrelate data from multiple
             * `TrackerSparqlConnection` instances maintained by the same process,
             * without creating a public endpoint for @service_connection.
             *
             * @connection may only be a `TrackerSparqlConnection` created via
             * [ctor@SparqlConnection.new] and [func@SparqlConnection.new_async].
             * @since 3.3
             * @param handle_name Handle name for @service_connection
             * @param service_connection a `TrackerSparqlConnection` to use from @connection
             */
            map_connection(handle_name: string, service_connection: SparqlConnection): void
            /**
             * Executes a SPARQL query on @connection.
             *
             * This method is synchronous and will block until the query
             * is executed. See [method@SparqlConnection.query_async]
             * for an asynchronous variant.
             *
             * If the query is partially built from user input or other
             * untrusted sources, special care is required about possible
             * SPARQL injection. In order to avoid it entirely, it is recommended
             * to use [class@SparqlStatement]. The function
             * [func@sparql_escape_string] exists as a last resort,
             * but its use is not recommended.
             * @throws {GLib.Error}
             * @param sparql String containing the SPARQL query
             * @param cancellable Optional [type@Gio.Cancellable]
             * @returns a [class@SparqlCursor] with the results.
             */
            query(sparql: string, cancellable: Gio.Cancellable | null): SparqlCursor
            /**
             * Executes asynchronously a SPARQL query on @connection
             *
             * If the query is partially built from user input or other
             * untrusted sources, special care is required about possible
             * SPARQL injection. In order to avoid it entirely, it is recommended
             * to use [class@SparqlStatement]. The function
             * [func@sparql_escape_string] exists as a last resort,
             * but its use is not recommended.
             * @param sparql String containing the SPARQL query
             * @param cancellable Optional [type@Gio.Cancellable]
             * @param callback User-defined [type@Gio.AsyncReadyCallback] to be called when
                       the asynchronous operation is finished.
             */
            query_async(sparql: string, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Finishes the operation started with [method@SparqlConnection.query_async].
             * @throws {GLib.Error}
             * @param res A [type@Gio.AsyncResult] with the result of the operation
             * @returns a [class@SparqlCursor] with the results.
             */
            query_finish(res: Gio.AsyncResult): SparqlCursor
            /**
             * Prepares the given `SELECT`/`ASK`/`DESCRIBE`/`CONSTRUCT` SPARQL query as a
             * [class@SparqlStatement].
             *
             * This prepared statement can be executed through [method@SparqlStatement.execute]
             * or [method@SparqlStatement.serialize_async] families of functions.
             * @throws {GLib.Error}
             * @param sparql The SPARQL query
             * @param cancellable Optional [type@Gio.Cancellable]
             * @returns A prepared statement
             */
            query_statement(sparql: string, cancellable: Gio.Cancellable | null): SparqlStatement
            /**
             * Serializes a `DESCRIBE` or `CONSTRUCT` query into the specified RDF format.
             *
             * This is an asynchronous operation, @callback will be invoked when
             * the data is available for reading.
             *
             * The SPARQL endpoint may not support the specified format, in that case
             * an error will be raised.
             *
             * The @flags argument is reserved for future expansions, currently
             * %TRACKER_SERIALIZE_FLAGS_NONE must be passed.
             * @since 3.3
             * @param flags Serialization flags
             * @param format Output RDF format
             * @param query SPARQL query
             * @param cancellable Optional [type@Gio.Cancellable]
             * @param callback User-defined [type@Gio.AsyncReadyCallback] to be called when
                       the asynchronous operation is finished.
             */
            serialize_async(flags: SerializeFlags, format: RdfFormat, query: string, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Finishes the operation started with [method@SparqlConnection.serialize_async].
             * @throws {GLib.Error}
             * @since 3.3
             * @param result A [type@Gio.AsyncResult] with the result of the operation
             * @returns A [class@Gio.InputStream] to read RDF content.
             */
            serialize_finish(result: Gio.AsyncResult): Gio.InputStream
            /**
             * Executes a SPARQL update on @connection.
             *
             * This method is synchronous and will block until the update
             * is finished. See [method@SparqlConnection.update_async]
             * for an asynchronous variant.
             *
             * It is recommented to consider the usage of [class@Batch]
             * to cluster database updates. Frequent isolated SPARQL updates
             * through this method will have a degraded performance in comparison.
             *
             * If the query is partially built from user input or other
             * untrusted sources, special care is required about possible
             * SPARQL injection. In order to avoid it entirely, it is recommended
             * to use [class@SparqlStatement], or to build the SPARQL
             * input through [class@Resource]. The function
             * [func@sparql_escape_string] exists as a last resort,
             * but its use is not recommended.
             * @throws {GLib.Error}
             * @param sparql String containing the SPARQL update query
             * @param cancellable Optional [type@Gio.Cancellable]
             */
            update(sparql: string, cancellable: Gio.Cancellable | null): void
            /**
             * Executes asynchronously an array of SPARQL updates. All updates in the
             * array are handled within a single transaction.
             *
             * If the query is partially built from user input or other
             * untrusted sources, special care is required about possible
             * SPARQL injection. In order to avoid it entirely, it is recommended
             * to use [class@SparqlStatement], or to build the SPARQL
             * input through [class@Resource]. The function
             * [func@sparql_escape_string] exists as a last resort,
             * but its use is not recommended.
             * @param sparql An array of strings containing the SPARQL update queries
             * @param sparql_length The amount of strings you pass as @sparql
             * @param cancellable Optional [type@Gio.Cancellable]
             * @param callback User-defined [type@Gio.AsyncReadyCallback] to be called when
                       the asynchronous operation is finished.
             */
            update_array_async(sparql: string, sparql_length: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Finishes the operation started with [method@SparqlConnection.update_array_async].
             * @throws {GLib.Error}
             * @param res A [type@Gio.AsyncResult] with the result of the operation
             * @returns #TRUE if there were no errors.
             */
            update_array_finish(res: Gio.AsyncResult): boolean
            /**
             * Executes asynchronously a SPARQL update.
             *
             * It is recommented to consider the usage of [class@Batch]
             * to cluster database updates. Frequent isolated SPARQL updates
             * through this method will have a degraded performance in comparison.
             *
             * If the query is partially built from user input or other
             * untrusted sources, special care is required about possible
             * SPARQL injection. In order to avoid it entirely, it is recommended
             * to use [class@SparqlStatement], or to build the SPARQL
             * input through [class@Resource]. The function
             * [func@sparql_escape_string] exists as a last resort,
             * but its use is not recommended.
             * @param sparql String containing the SPARQL update query
             * @param cancellable Optional [type@Gio.Cancellable]
             * @param callback User-defined [type@Gio.AsyncReadyCallback] to be called when
                       the asynchronous operation is finished.
             */
            update_async(sparql: string, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Executes a SPARQL update and returns the names of the generated blank nodes.
             *
             * This method is synchronous and will block until the update
             * is finished. See [method@SparqlConnection.update_blank_async]
             * for an asynchronous variant.
             *
             * The @sparql query should be built with [class@Resource], or
             * its parts correctly escaped using [func@sparql_escape_string],
             * otherwise SPARQL injection is possible.
             *
             * The format string of the `GVariant` is `aaa{ss}` (an array of an array
             * of dictionaries). The first array represents each INSERT that may exist in
             * the SPARQL string. The second array represents each new node for a given
             * WHERE clause. The last array holds a string pair with the blank node name
             * (e.g. `foo` for the blank node `_:foo`) and the URN that was generated for
             * it. For most updates the first two outer arrays will only contain one item.
             * @throws {GLib.Error}
             * @deprecated since 3.5 This function makes the expectation that blank nodes have a durable name that persist. The SPARQL and RDF specs define a much more reduced scope for blank node labels. This function advises a behavior that goes against that reduced scope, and will directly make the returned values meaningless if the #TRACKER_SPARQL_CONNECTION_FLAGS_ANONYMOUS_BNODES flag is defined in the connection.  Users that want names generated for them, should look for other methods (e.g. IRIs containing UUIDv4 strings).
             * @param sparql String containing the SPARQL update query
             * @param cancellable Optional [type@Gio.Cancellable]
             * @returns a [type@GLib.Variant] with the generated URNs.
             */
            update_blank(sparql: string, cancellable: Gio.Cancellable | null): GLib.Variant
            /**
             * Executes asynchronously a SPARQL update and returns the names of the generated blank nodes.
             *
             * See the [method@SparqlConnection.update_blank] documentation to
             * learn the differences with [method@SparqlConnection.update].
             * @deprecated since 3.5 See [method@SparqlConnection.update_blank].
             * @param sparql String containing the SPARQL update query
             * @param cancellable Optional [type@Gio.Cancellable]
             * @param callback User-defined [type@Gio.AsyncReadyCallback] to be called when
                       the asynchronous operation is finished.
             */
            update_blank_async(sparql: string, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Finishes the operation started with [method@SparqlConnection.update_blank_async].
             *
             * This method returns the URNs of the generated nodes, if any. See the
             * [method@SparqlConnection.update_blank] documentation for the interpretation
             * of the returned [type@GLib.Variant].
             * @throws {GLib.Error}
             * @deprecated since 3.5 See [method@SparqlConnection.update_blank].
             * @param res A [type@Gio.AsyncResult] with the result of the operation
             * @returns a [type@GLib.Variant] with the generated URNs.
             */
            update_blank_finish(res: Gio.AsyncResult): GLib.Variant
            /**
             * Finishes the operation started with [method@SparqlConnection.update_async].
             * @throws {GLib.Error}
             * @param res A [type@Gio.AsyncResult] with the result of the operation
             */
            update_finish(res: Gio.AsyncResult): void
            /**
             * Inserts a resource as described by @resource on the given @graph.
             *
             * This method is synchronous and will block until the update
             * is finished. See [method@SparqlConnection.update_resource_async]
             * for an asynchronous variant.
             *
             * It is recommented to consider the usage of [class@Batch]
             * to cluster database updates. Frequent isolated SPARQL updates
             * through this method will have a degraded performance in comparison.
             * @throws {GLib.Error}
             * @since 3.1
             * @param graph RDF graph where the resource should be inserted/updated, or %NULL for the default graph
             * @param resource A [class@Resource]
             * @param cancellable Optional [type@Gio.Cancellable]
             * @returns #TRUE if there were no errors.
             */
            update_resource(graph: string | null, resource: Resource, cancellable: Gio.Cancellable | null): boolean
            /**
             * Inserts asynchronously a resource as described by @resource on the given @graph.
             *
             * It is recommented to consider the usage of [class@Batch]
             * to cluster database updates. Frequent isolated SPARQL updates
             * through this method will have a degraded performance in comparison.
             * @since 3.1
             * @param graph RDF graph where the resource should be inserted/updated, or %NULL for the default graph
             * @param resource A [class@Resource]
             * @param cancellable Optional [type@Gio.Cancellable]
             * @param callback User-defined [type@Gio.AsyncReadyCallback] to be called when
                       the asynchronous operation is finished.
             */
            update_resource_async(graph: string | null, resource: Resource, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Finishes the operation started with [method@SparqlConnection.update_resource_async].
             * @throws {GLib.Error}
             * @since 3.1
             * @param res A [type@Gio.AsyncResult] with the result of the operation
             * @returns #TRUE if there were no errors.
             */
            update_resource_finish(res: Gio.AsyncResult): boolean
            /**
             * Prepares the given `INSERT`/`DELETE` SPARQL as a [class@SparqlStatement].
             *
             * This prepared statement can be executed through
             * the [method@SparqlStatement.update] family of functions.
             * @throws {GLib.Error}
             * @since 3.5
             * @param sparql The SPARQL update
             * @param cancellable Optional [type@Gio.Cancellable]
             * @returns A prepared statement
             */
            update_statement(sparql: string, cancellable: Gio.Cancellable | null): SparqlStatement
        }

        interface SparqlConnectionClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<SparqlConnection>
            readonly prototype: SparqlConnection
            new (props?: Partial<GObject.ConstructorProps<SparqlConnection>>): SparqlConnection
            /**
             * @service_name (nullable): The name of the D-Bus service to connect to, or %NULL if not using a message bus.
             * Connects to a database owned by another process on the
             * local machine via DBus.
             *
             * When using a message bus (session/system), the @service_name argument will
             * be used to describe the remote endpoint, either by unique or well-known D-Bus
             * names. If not using a message bus (e.g. peer-to-peer D-Bus connections) the
             * @service_name may be %NULL.
             *
             * The D-Bus object path of the remote endpoint will be given through
             * @object_path, %NULL may be used to use the default
             * `/org/freedesktop/Tracker3/Endpoint` path.
             *
             * The D-Bus connection used to set up the connection may be given through
             * the @dbus_connection argument. Using %NULL will resort to the default session
             * bus.
             * @throws {GLib.Error}
             * @param service_name
             * @param object_path The path to the object, or %NULL to use the default.
             * @param dbus_connection The [type@Gio.DBusConnection] to use, or %NULL to use the session bus
             * @returns a new `TrackerSparqlConnection`.
             */
            bus_new(service_name: string, object_path: string | null, dbus_connection: Gio.DBusConnection | null): SparqlConnection
            /**
             * Finishes the operation started with [func@SparqlConnection.bus_new_async].
             * @throws {GLib.Error}
             * @since 3.1
             * @param result A [type@Gio.AsyncResult] with the result of the operation
             * @returns a new `TrackerSparqlConnection`.
             */
            bus_new_finish(result: Gio.AsyncResult): SparqlConnection
            /**
             * Creates or opens a process-local database.
             *
             * This method should only be used for databases owned by the current process.
             * To connect to databases managed by other processes, use
             * [ctor@SparqlConnection.bus_new].
             *
             * The @store argument determines where in the local filesystem the database
             * will be stored. If @store is %NULL, the database will be created in memory.
             * Traditionally, @store describes a directory where a file named `meta.db`
             * contains the data. Starting with version 3.10, if the basename of @store
             * contains a `.` extension separator, it will be considered as the database
             * file itself.
             *
             * If defined, the @ontology argument must point to a location containing
             * suitable `.ontology` files in Turtle format. These define the structure of
             * the triple store. You can learn more about [ontologies](ontologies.html),
             * or you can use the stock Nepomuk ontologies by calling
             * [func@sparql_get_ontology_nepomuk].
             *
             * If opening an existing database, it is possible to pass %NULL as the
             * @ontology location, the ontology will be introspected from the database.
             * Passing a %NULL @ontology will raise an error if the database does not exist.
             *
             * If a database is opened without the `READONLY` [flags@SparqlConnectionFlags]
             * flag enabled, and the given @ontology holds differences with the current
             * data layout, migration to the new structure will be attempted. This operation
             * may raise an error. In particular, not all migrations are possible without
             * causing data loss and Tracker will refuse to delete data during a migration.
             * The database is always left in a consistent state, either prior or posterior
             * to migration.
             *
             * Operations on a [class@SparqlConnection] resulting on a
             * `CORRUPT` [error@SparqlError] will have the event recorded
             * persistently through a `.$DB_BASENAME.corrupted` file alongside the database file.
             * If the database is opened without the `READONLY` [flags@SparqlConnectionFlags]
             * flag enabled and the file is found, this constructor will attempt to repair the
             * database. In that situation, this constructor will either return a valid
             * [class@SparqlConnection] if the database was repaired successfully, or
             * raise a `CORRUPT` [error@SparqlError] error if the database remains
             * corrupted.
             *
             * It is considered a developer error to ship ontologies that contain format
             * errors, or that fail at migrations.
             *
             * It is encouraged to use `resource:///` URI locations for @ontology wherever
             * possible, so the triple store structure is tied to the executable binary,
             * and in order to minimize disk seeks during `TrackerSparqlConnection`
             * initialization.
             * @throws {GLib.Error}
             * @param flags Connection flags to define the SPARQL connection behavior
             * @param store The database location as a [iface@Gio.File], or %NULL
             * @param ontology The directory that contains the database schemas as a [iface@Gio.File], or %NULL
             * @param cancellable Optional [type@Gio.Cancellable]
             * @returns a new `TrackerSparqlConnection`.
             */
            "new"(flags: SparqlConnectionFlags, store: Gio.File | null, ontology: Gio.File | null, cancellable: Gio.Cancellable | null): SparqlConnection
            /**
             * Finishes the operation started with [func@SparqlConnection.new_async].
             * @throws {GLib.Error}
             * @param result A [type@Gio.AsyncResult] with the result of the operation
             * @returns a new `TrackerSparqlConnection`.
             */
            new_finish(result: Gio.AsyncResult): SparqlConnection
            /**
             * Constructor similar to [ctor@SparqlConnection.new], that takes the
             * RDF Schema definitions declaring the database schema as an input stream.
             *
             * Unlike that constructor, databases created this way will not have the
             * RDF Schema data snapshot into the database itself. It will need to be
             * done by the caller as a separate step, e.g. via
             * [method@SparqlConnection.deserialize_async].
             * @throws {GLib.Error}
             * @since 3.11
             * @param flags Connection flags to define the SPARQL connection behavior
             * @param store The database location as a [iface@Gio.File], or %NULL
             * @param deserialize_flags Deserialization flags
             * @param rdf_format RDF format of the @rdf_stream argument
             * @param rdf_stream RDF Schema definition of the database format
             * @param cancellable Optional [type@Gio.Cancellable]
             * @returns a new `TrackerSparqlConnection`.
             */
            new_from_rdf(flags: SparqlConnectionFlags, store: Gio.File | null, deserialize_flags: DeserializeFlags, rdf_format: RdfFormat, rdf_stream: Gio.InputStream, cancellable: Gio.Cancellable | null): SparqlConnection
            /**
             * Finishes the operation started with [func@SparqlConnection.new_from_rdf_async].
             * @throws {GLib.Error}
             * @since 3.11
             * @param result A [type@Gio.AsyncResult] with the result of the operation
             * @returns a new `TrackerSparqlConnection`.
             */
            new_from_rdf_finish(result: Gio.AsyncResult): SparqlConnection
            /**
             * Creates a connection to a remote HTTP SPARQL endpoint.
             *
             * The connection is made using the libsoup HTTP library. The connection will
             * normally use the `https://` or `http://` protocols.
             * @param uri_base Base URI of the remote connection
             * @returns a new remote `TrackerSparqlConnection`.
             */
            remote_new(uri_base: string): SparqlConnection
            /**
             * Connects asynchronously to a database owned by another process on the
             * local machine via DBus.
             * @since 3.1
             * @param service_name The name of the D-Bus service to connect to.
             * @param object_path The path to the object, or %NULL to use the default.
             * @param dbus_connection The [class@Gio.DBusConnection] to use, or %NULL to use the session bus
             * @param cancellable Optional [type@Gio.Cancellable]
             * @param callback User-defined [type@Gio.AsyncReadyCallback] to be called when
                       the asynchronous operation is finished.
             */
            bus_new_async(service_name: string, object_path: string | null, dbus_connection: Gio.DBusConnection | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Creates or opens a process-local database asynchronously.
             *
             * See [ctor@SparqlConnection.new] for more information.
             * @param flags Connection flags to define the SPARQL connection behavior
             * @param store The database location as a [iface@Gio.File], or %NULL
             * @param ontology The directory that contains the database schemas as a [iface@Gio.File], or %NULL
             * @param cancellable Optional [type@Gio.Cancellable]
             * @param callback User-defined [type@Gio.AsyncReadyCallback] to be called when
                       the asynchronous operation is finished.
             */
            new_async(flags: SparqlConnectionFlags, store: Gio.File | null, ontology: Gio.File | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Asynchronous version of [ctor@SparqlConnection.new_from_rdf].
             * @since 3.11
             * @param flags Connection flags to define the SPARQL connection behavior
             * @param store The database location as a [iface@Gio.File], or %NULL
             * @param deserialize_flags Deserialization flags
             * @param rdf_format RDF format of the @rdf_stream argument
             * @param rdf_stream RDF Schema definition of the database format
             * @param cancellable Optional [type@Gio.Cancellable]
             * @param callback User-defined [type@Gio.AsyncReadyCallback] to be called when
                       the asynchronous operation is finished.
             */
            new_from_rdf_async(flags: SparqlConnectionFlags, store: Gio.File | null, deserialize_flags: DeserializeFlags, rdf_format: RdfFormat, rdf_stream: Gio.InputStream, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
        }

        const SparqlConnection: SparqlConnectionClass
        

        namespace SparqlCursor {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "connection": SparqlConnection
                "n-columns": number
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "connection": SparqlConnection
                "n-columns": number
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * `TrackerSparqlCursor` provides the methods to iterate the results of a SPARQL query.
         *
         * Cursors are obtained through e.g. [method@SparqlStatement.execute]
         * or [method@SparqlConnection.query] after the SPARQL query has been
         * executed.
         *
         * When created, a cursor does not point to any element, [method@SparqlCursor.next]
         * is necessary to iterate one by one to the first (and following) results.
         * When the cursor iterated across all rows in the result set, [method@SparqlCursor.next]
         * will return %FALSE with no error set.
         *
         * On each row, it is possible to extract the result values through the
         * [method@SparqlCursor.get_integer], [method@SparqlCursor.get_string], etc... family
         * of methods. The column index of those functions starts at 0. The number of columns is
         * dependent on the SPARQL query issued, but may be checked at runtime through the
         * [method@SparqlCursor.get_n_columns] method.
         *
         * After a cursor is iterated, it is recommended to call [method@SparqlCursor.close]
         * explicitly to free up resources for other users of the same [class@SparqlConnection],
         * this is especially important in garbage collected languages. These resources
         * will be also implicitly freed on cursor object finalization.
         *
         * It is possible to use a given `TrackerSparqlCursor` in other threads than
         * the one it was created from. It must be however used from just one thread
         * at any given time.
         */
        interface SparqlCursor extends GObject.Object {
            readonly $signals: SparqlCursor.SignalSignatures
            readonly $readableProperties: SparqlCursor.ReadableProperties
            readonly $writableProperties: SparqlCursor.WritableProperties
            readonly $constructOnlyProperties: SparqlCursor.ConstructOnlyProperties
            /**
             * The [class@SparqlConnection] used to retrieve the results.
             */
            get connection(): SparqlConnection
            set connection(value: SparqlConnection)
            /**
             * Number of columns available in the result set.
             * @default 0
             */
            get nColumns(): number
            set nColumns(value: number)
            /**
             * Closes the cursor. The object can only be freed after this call.
             */
            close(): void
            /**
             * Retrieve a boolean for the current row in @column.
             *
             * If the row/column do not have a boolean value, the result is
             * undefined, see [method@SparqlCursor.get_value_type].
             * @param column column number to retrieve (first one is 0)
             * @returns a boolean value.
             */
            get_boolean(column: number): boolean
            /**
             * Returns the [class@SparqlConnection] associated with this
             * `TrackerSparqlCursor`.
             * @returns the cursor [class@SparqlConnection]. The returned object must not be unreferenced by the caller.
             */
            get_connection(): SparqlConnection
            /**
             * Retrieves a [type@GLib.DateTime] pointer for the current row in @column.
             * @since 3.2
             * @param column Column number to retrieve (first one is 0)
             * @returns [type@GLib.DateTime] object, or %NULL if the given column does not   contain a [xsd:date](xsd-ontology.html#xsd:date) or [xsd:dateTime](xsd-ontology.html#xsd:dateTime).
             */
            get_datetime(column: number): GLib.DateTime | null
            /**
             * Retrieve a double for the current row in @column.
             *
             * If the row/column do not have a integer or double value, the result is
             * undefined, see [method@SparqlCursor.get_value_type].
             * @param column column number to retrieve (first one is 0)
             * @returns a double value.
             */
            get_double(column: number): number
            /**
             * Retrieve an integer for the current row in @column.
             *
             * If the row/column do not have an integer value, the result is
             * undefined, see [method@SparqlCursor.get_value_type].
             * @param column column number to retrieve (first one is 0)
             * @returns a 64-bit integer value.
             */
            get_integer(column: number): number
            /**
             * Retrieves a string representation of the data in the current
             * row in @column. If the string has language information (i.e. it is
             * a `rdf:langString`](rdf-ontology.html#rdf:langString)), the language
             * tag will be returned in the location provided through @langtag. This
             * language tag will typically be in a format conforming
             * [RFC 5646](https://www.rfc-editor.org/rfc/rfc5646.html).
             * @since 3.7
             * @param column column number to retrieve
             * @returns a string which must not be freed. %NULL is returned if the column is not in the `[0, n_columns]` range, or if the row/column refer to a nullable optional value in the result set., language tag of the returned string, or %NULL if the   string has no language tag, length of the returned string
             */
            get_langstring(column: number): [string | null, string, number | null]
            /**
             * Retrieves the number of columns available in the result set.
             *
             * This method should only be called after a successful
             * [method@SparqlCursor.next], otherwise its return value
             * will be undefined.
             * @returns The number of columns returned in the result set.
             */
            get_n_columns(): number
            /**
             * Retrieves a string representation of the data in the current
             * row in @column.
             *
             * Any type may be converted to a string. If the value is not bound
             * (See [method@SparqlCursor.is_bound]) this method will return %NULL.
             * @param column column number to retrieve (first one is 0)
             * @returns a string which must not be freed. %NULL is returned if the column is not in the `[0, n_columns]` range, or if the row/column refer to a nullable optional value in the result set., length of the returned string, or %NULL
             */
            get_string(column: number): [string | null, number | null]
            /**
             * Returns the data type bound to the current row and the given @column.
             *
             * If the column is unbound, the value will be %TRACKER_SPARQL_VALUE_TYPE_UNBOUND.
             * See also [method@SparqlCursor.is_bound].
             *
             * Values of type #TRACKER_SPARQL_VALUE_TYPE_RESOURCE and
             * #TRACKER_SPARQL_VALUE_TYPE_BLANK_NODE can be considered equivalent, the
             * difference is the resource being referenced as a named IRI or a blank
             * node.
             *
             * All other [enum@SparqlValueType] value types refer to literal values.
             * @param column column number to retrieve (first one is 0)
             * @returns a [enum@SparqlValueType] expressing the content type of   the given column for the current row.
             */
            get_value_type(column: number): SparqlValueType
            /**
             * Retrieves the name of the given @column.
             *
             * This name will be defined at the SPARQL query, either
             * implicitly from the names of the variables returned in
             * the resultset, or explicitly through the `AS ?var` SPARQL
             * syntax.
             * @param column column number to retrieve (first one is 0)
             * @returns The name of the given column.
             */
            get_variable_name(column: number): string | null
            /**
             * Returns whether the given @column has a bound value in the current row.
             *
             * This may not be the case through e.g. the `OPTIONAL { }` SPARQL syntax.
             * @param column column number to retrieve (first one is 0)
             * @returns a %TRUE or %FALSE.
             */
            is_bound(column: number): boolean
            /**
             * Iterates the cursor to the next result.
             *
             * If the cursor was not started, it will point to the first result after
             * this call. This operation is completely synchronous and it may block,
             * see [method@SparqlCursor.next_async] for an asynchronous variant.
             * @throws {GLib.Error}
             * @param cancellable Optional [type@Gio.Cancellable]
             * @returns %FALSE if there are no more results or if an error is found, otherwise %TRUE.
             */
            next(cancellable: Gio.Cancellable | null): boolean
            /**
             * Iterates the cursor asyncronously to the next result.
             *
             * If the cursor was not started, it will point to the first result after
             * this operation completes.
             *
             * In the period between this call and the corresponding
             * [method@SparqlCursor.next_finish] call, the other cursor methods
             * should not be used, nor their results trusted. The cursor should only
             * be iterated once at a time.
             * @param cancellable Optional [type@Gio.Cancellable]
             * @param callback user-defined [type@Gio.AsyncReadyCallback] to be called when
                       asynchronous operation is finished.
             */
            next_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Finishes the asynchronous iteration to the next result started with
             * [method@SparqlCursor.next_async].
             * @throws {GLib.Error}
             * @param res a [type@Gio.AsyncResult] with the result of the operation
             * @returns %FALSE if there are no more results or if an error is found, otherwise %TRUE.
             */
            next_finish(res: Gio.AsyncResult): boolean
            /**
             * Resets the iterator to point back to the first result.
             * @deprecated since 3.5 This function only works on cursors from direct [class@SparqlConnection] objects and cannot work reliably across all cursor types. Issue a different query to obtain a new cursor.
             */
            rewind(): void
        }

        interface SparqlCursorClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<SparqlCursor>
            readonly prototype: SparqlCursor
            new (props?: Partial<GObject.ConstructorProps<SparqlCursor>>): SparqlCursor
        }

        const SparqlCursor: SparqlCursorClass
        

        namespace SparqlStatement {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "connection": SparqlConnection
                "sparql": string
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "connection": SparqlConnection
                "sparql": string
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * `TrackerSparqlStatement` represents a prepared statement for a SPARQL query.
         *
         * The SPARQL query will be internally compiled into the format that is most
         * optimal to execute the query many times. For connections created
         * through [ctor@SparqlConnection.new] that will be a
         * SQLite compiled statement.
         *
         * The SPARQL query may contain parameterized variables expressed via the
         * `~` prefix in the SPARQL syntax (e.g. `~var`), these may happen anywhere
         * in the SPARQL where a literal or variable would typically happen. These
         * parameterized variables may be mapped to arbitrary values prior to
         * execution. The `TrackerSparqlStatement` may be reused for future
         * queries with different values.
         *
         * The argument bindings may be changed through the [method@SparqlStatement.bind_int],
         * [method@SparqlStatement.bind_int], etc... family of functions. Those functions
         * receive a @name argument corresponding for the variable name in the SPARQL query
         * (eg. `"var"` for `~var`) and a value to map the variable to.
         *
         * Once all arguments have a value, the query may be executed through
         * [method@SparqlStatement.execute_async] or [method@SparqlStatement.execute].
         *
         * It is possible to use any `TrackerSparqlStatement` from other threads than
         * the one it was created from. However, binding values and executing the
         * statement must only happen from one thread at a time. It is possible to reuse
         * the `TrackerSparqlStatement` right after [method@SparqlStatement.execute_async]
         * was called, there is no need to wait for [method@SparqlStatement.execute_finish].
         *
         * In some circumstances, it is possible that the query needs to be recompiled
         * from the SPARQL source. This will happen transparently.
         */
        interface SparqlStatement extends GObject.Object {
            readonly $signals: SparqlStatement.SignalSignatures
            readonly $readableProperties: SparqlStatement.ReadableProperties
            readonly $writableProperties: SparqlStatement.WritableProperties
            readonly $constructOnlyProperties: SparqlStatement.ConstructOnlyProperties
            /**
             * The [class@SparqlConnection] the statement was created for.
             */
            get connection(): SparqlConnection
            set connection(value: SparqlConnection)
            /**
             * SPARQL query stored in this statement.
             * @default NULL
             */
            get sparql(): string
            set sparql(value: string)
            /**
             * Binds the boolean @value to the parameterized variable given by @name.
             * @param name variable name
             * @param value value
             */
            bind_boolean(name: string, value: boolean): void
            /**
             * Binds the [type@GLib.DateTime] @value to the parameterized variable given by @name.
             * @since 3.2
             * @param name variable name
             * @param value value
             */
            bind_datetime(name: string, value: GLib.DateTime): void
            /**
             * Binds the double @value to the parameterized variable given by @name.
             * @param name variable name
             * @param value value
             */
            bind_double(name: string, value: number): void
            /**
             * Binds the integer @value to the parameterized variable given by @name.
             * @param name variable name
             * @param value value
             */
            bind_int(name: string, value: number): void
            /**
             * Binds the @value to the parameterized variable given by @name, tagged
             * with the language defined by @langtag. The language tag should follow
             * [RFC 5646](https://www.rfc-editor.org/rfc/rfc5646.html). The parameter
             * will be represented as a [`rdf:langString`](rdf-ontology.html#rdf:langString).
             * @since 3.7
             * @param name variable name
             * @param value value
             * @param langtag language tag
             */
            bind_langstring(name: string, value: string, langtag: string): void
            /**
             * Binds the string @value to the parameterized variable given by @name.
             * @param name variable name
             * @param value value
             */
            bind_string(name: string, value: string): void
            /**
             * Clears all bindings.
             */
            clear_bindings(): void
            /**
             * Executes the `SELECT` or `ASK` SPARQL query with the currently bound values.
             *
             * This function also works for `DESCRIBE` and `CONSTRUCT` queries that
             * retrieve data from the triple store. These query forms that return
             * RDF data are however more useful together with [method@SparqlStatement.serialize_async].
             *
             * This function should only be called on `TrackerSparqlStatement` objects
             * obtained through [method@SparqlConnection.query_statement] or
             * SELECT/CONSTRUCT/DESCRIBE statements loaded through
             * [method@SparqlConnection.load_statement_from_gresource].
             * An error will be raised if this method is called on a `INSERT` or `DELETE`
             * SPARQL query.
             * @throws {GLib.Error}
             * @param cancellable Optional [type@Gio.Cancellable]
             * @returns A `TrackerSparqlCursor` with the query results.
             */
            execute(cancellable: Gio.Cancellable | null): SparqlCursor
            /**
             * Executes asynchronously the `SELECT` or `ASK` SPARQL query with the currently bound values.
             *
             * This function also works for `DESCRIBE` and `CONSTRUCT` queries that
             * retrieve data from the triple store. These query forms that return
             * RDF data are however more useful together with [method@SparqlStatement.serialize_async].
             *
             * This function should only be called on `TrackerSparqlStatement` objects
             * obtained through [method@SparqlConnection.query_statement] or
             * SELECT/CONSTRUCT/DESCRIBE statements loaded through
             * [method@SparqlConnection.load_statement_from_gresource].
             * An error will be raised if this method is called on a `INSERT` or `DELETE`
             * SPARQL query.
             * @param cancellable Optional [type@Gio.Cancellable]
             * @param callback user-defined [type@Gio.AsyncReadyCallback] to be called when
                       the asynchronous operation is finished.
             */
            execute_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Finishes the asynchronous operation started through
             * [method@SparqlStatement.execute_async].
             * @throws {GLib.Error}
             * @param res a [type@Gio.AsyncResult] with the result of the operation
             * @returns A `TrackerSparqlCursor` with the query results.
             */
            execute_finish(res: Gio.AsyncResult): SparqlCursor
            /**
             * Returns the [class@SparqlConnection] that this statement was created for.
             * @returns The SPARQL connection of this statement.
             */
            get_connection(): SparqlConnection
            /**
             * Returns the SPARQL string that this prepared statement holds.
             * @returns The contained SPARQL query
             */
            get_sparql(): string
            /**
             * Serializes a `DESCRIBE` or `CONSTRUCT` query into the given RDF @format.
             *
             * The query @stmt was created from must be either a `DESCRIBE` or `CONSTRUCT`
             * query, an error will be raised otherwise.
             *
             * This is an asynchronous operation, @callback will be invoked when the
             * data is available for reading.
             *
             * The SPARQL endpoint may not support the specified format, in that case
             * an error will be raised.
             *
             * The @flags argument is reserved for future expansions, currently
             * #TRACKER_SERIALIZE_FLAGS_NONE must be passed.
             * @since 3.3
             * @param flags serialization flags
             * @param format RDF format of the serialized data
             * @param cancellable Optional [type@Gio.Cancellable]
             * @param callback user-defined [type@Gio.AsyncReadyCallback] to be called when
                       the asynchronous operation is finished.
             */
            serialize_async(flags: SerializeFlags, format: RdfFormat, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Finishes the asynchronous operation started through
             * [method@SparqlStatement.serialize_async].
             * @throws {GLib.Error}
             * @since 3.3
             * @param result a [type@Gio.AsyncResult] with the result of the operation
             * @returns a [class@Gio.InputStream] to read RDF content.
             */
            serialize_finish(result: Gio.AsyncResult): Gio.InputStream
            /**
             * Executes the `INSERT`/`DELETE` SPARQL query series with the currently bound values.
             *
             * This function should only be called on `TrackerSparqlStatement` objects
             * obtained through [method@SparqlConnection.update_statement] or
             * `INSERT`/`DELETE` statements loaded through
             * [method@SparqlConnection.load_statement_from_gresource].
             * An error will be raised if this method is called on
             * `SELECT`/`ASK`/`DESCRIBE`/`CONSTRUCT` SPARQL queries.
             * @throws {GLib.Error}
             * @since 3.5
             * @param cancellable Optional [type@Gio.Cancellable]
             * @returns %TRUE if the update finished with no errors, %FALSE otherwise
             */
            update(cancellable: Gio.Cancellable | null): boolean
            /**
             * Executes asynchronously the `INSERT`/`DELETE` SPARQL query series with the currently bound values.
             *
             * This function should only be called on `TrackerSparqlStatement` objects
             * obtained through [method@SparqlConnection.update_statement] or
             * `INSERT`/`DELETE` statements loaded through
             * [method@SparqlConnection.load_statement_from_gresource].
             * An error will be raised if this method is called on
             * `SELECT`/`ASK`/`DESCRIBE`/`CONSTRUCT` SPARQL queries.
             * @since 3.5
             * @param cancellable Optional [type@Gio.Cancellable]
             * @param callback user-defined [type@Gio.AsyncReadyCallback] to be called when
                       the asynchronous operation is finished.
             */
            update_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Finishes the asynchronous update started through
             * [method@SparqlStatement.update_async].
             * @throws {GLib.Error}
             * @since 3.5
             * @param result a [type@Gio.AsyncResult] with the result of the operation
             * @returns %TRUE if the update finished with no errors, %FALSE otherwise
             */
            update_finish(result: Gio.AsyncResult): boolean
        }

        interface SparqlStatementClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<SparqlStatement>
            readonly prototype: SparqlStatement
            new (props?: Partial<GObject.ConstructorProps<SparqlStatement>>): SparqlStatement
        }

        const SparqlStatement: SparqlStatementClass
        none
        none
        none
        none
        /**
         *  struct represents a
         * change event in the stored data.
         */
        abstract class NotifierEvent {
            static readonly $gtype: GObject.GType<NotifierEvent>

            
            /**
             * Returns the event type.
             * @returns The event type
             */
            get_event_type(): NotifierEventType
            /**
             * Returns the tracker:id of the element being notified upon. This is a #gint64
             * which is used as efficient internal identifier for the resource.
             * @returns the resource ID
             */
            get_id(): number
            /**
             * Returns the Uniform Resource Name of the element. This is Tracker's
             * public identifier for the resource.
             *
             * This URN is an unique string identifier for the resource being
             * notified upon, typically of the form `urn:uuid:...`.
             * @returns The element URN
             */
            get_urn(): string
        }
        none
        none
        none
        none
        /**
         * Checks that the Tracker library in use is compatible with the given version.
         *
         * Generally you would pass in the constants
         * [const@MAJOR_VERSION], [const@MINOR_VERSION], [const@MICRO_VERSION]
         * as the three arguments to this function; that produces
         * a check that the library in use is compatible with
         * the version of Tracker the application or module was compiled
         * against.
         *
         * Compatibility is defined by two things: first the version
         * of the running library is newer than the version
         * @required_major.@required_minor.@required_micro. Second
         * the running library must be binary compatible with the
         * version @required_major.@required_minor.@required_micro
         * (same major version.)
         * @param required_major the required major version.
         * @param required_minor the required minor version.
         * @param required_micro the required micro version.
         * @returns %NULL if the Tracker library is compatible with the   given version, or a string describing the version mismatch.
         */
        function check_version(required_major: number, required_minor: number, required_micro: number): string
        /**
         */
        function sparql_error_quark(): GLib.Quark
        /**
         * Escapes @literal so it is suitable for insertion in
         * SPARQL queries as string literals.
         *
         * Manual construction of query strings based user input is best
         * avoided at all cost, use of #TrackerSparqlStatement is recommended
         * instead.
         * @param literal a string to escape
         * @returns the escaped string
         */
        function sparql_escape_string(literal: string): string
        /**
         * Escapes a string for use as a URI.
         * @param uri a string to be escaped, following the tracker sparql rules
         * @returns a newly-allocated string holding the result.
         */
        function sparql_escape_uri(uri: string): string
        none
        none
        /**
         * Returns a path to the built-in Nepomuk ontologies.
         * @returns a #GFile instance.
         */
        function sparql_get_ontology_nepomuk(): Gio.File
        /**
         * Creates a fresh UUID-based URN.
         * @returns A newly generated UUID URN.
         */
        function sparql_get_uuid_urn(): string
        const MAJOR_VERSION: 3
        const MICRO_VERSION: 0
        const MINOR_VERSION: 11
        const PREFIX_DC: "http://purl.org/dc/elements/1.1/"
        const PREFIX_MFO: "http://tracker.api.gnome.org/ontology/v3/mfo#"
        const PREFIX_NAO: "http://tracker.api.gnome.org/ontology/v3/nao#"
        const PREFIX_NCO: "http://tracker.api.gnome.org/ontology/v3/nco#"
        const PREFIX_NFO: "http://tracker.api.gnome.org/ontology/v3/nfo#"
        const PREFIX_NIE: "http://tracker.api.gnome.org/ontology/v3/nie#"
        const PREFIX_NMM: "http://tracker.api.gnome.org/ontology/v3/nmm#"
        const PREFIX_NRL: "http://tracker.api.gnome.org/ontology/v3/nrl#"
        const PREFIX_OSINFO: "http://tracker.api.gnome.org/ontology/v3/osinfo#"
        const PREFIX_RDF: "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
        const PREFIX_RDFS: "http://www.w3.org/2000/01/rdf-schema#"
        const PREFIX_SLO: "http://tracker.api.gnome.org/ontology/v3/slo#"
        const PREFIX_TRACKER: "http://tracker.api.gnome.org/ontology/v3/tracker#"
        const PREFIX_XSD: "http://www.w3.org/2001/XMLSchema#"
        
        namespace DeserializeFlags {
            const $gtype: GObject.GType<DeserializeFlags>
        }

        /**
         * Flags affecting deserialization from a RDF data format.
         */
        enum DeserializeFlags {
            /**
             * No flags.
             */
            "NONE" = 0,
        }
        
        namespace NotifierEventType {
            const $gtype: GObject.GType<NotifierEventType>
        }

        /**
         * Notifier event types.
         */
        enum NotifierEventType {
            /**
             * An element was created.
             */
            "CREATE" = 0,
            /**
             * An element was deleted.
             */
            "DELETE" = 1,
            /**
             * An element was updated.
             */
            "UPDATE" = 2,
        }
        
        namespace RdfFormat {
            const $gtype: GObject.GType<RdfFormat>
        }

        /**
         * Describes a RDF format to be used in data exchange.
         */
        enum RdfFormat {
            /**
             * Turtle format
             *   ([http://www.w3.org/ns/formats/Turtle](http://www.w3.org/ns/formats/Turtle))
             */
            "TURTLE" = 0,
            /**
             * Trig format
             *   ([http://www.w3.org/ns/formats/Trig](http://www.w3.org/ns/formats/Trig))
             */
            "TRIG" = 1,
            /**
             * JSON-LD format
             *   ([http://www.w3.org/ns/formats/JSON-LD](http://www.w3.org/ns/formats/JSON-LD)).
             *   This value was added in version 3.5.
             */
            "JSON_LD" = 2,
            /**
             * The total number of RDF formats
             */
            "LAST" = 3,
        }
        
        namespace SerializeFlags {
            const $gtype: GObject.GType<SerializeFlags>
        }

        /**
         * Flags affecting serialization into a RDF data format.
         */
        enum SerializeFlags {
            /**
             * No flags.
             */
            "NONE" = 0,
        }
        
        abstract class SparqlError extends GLib.Error {
            static readonly $gtype: GObject.GType<SparqlError>
            /**
             * Subject is not in the domain of a property or
             *                             trying to set multiple values for a single valued
             *                             property.
             */
            static readonly "CONSTRAINT": 0
            /**
             * Internal error.
             */
            static readonly "INTERNAL": 1
            /**
             * There was no disk space available to perform the request.
             */
            static readonly "NO_SPACE": 2
            /**
             * The specified ontology wasn't found.
             */
            static readonly "ONTOLOGY_NOT_FOUND": 3
            /**
             * Problem encountered while opening the database.
             */
            static readonly "OPEN_ERROR": 4
            /**
             * Error parsing the SPARQL string.
             */
            static readonly "PARSE": 5
            /**
             * Problem while executing the query.
             */
            static readonly "QUERY_FAILED": 6
            /**
             * Type constraint failed when trying to insert data.
             */
            static readonly "TYPE": 7
            /**
             * Unknown class.
             */
            static readonly "UNKNOWN_CLASS": 8
            /**
             * Unknown graph.
             */
            static readonly "UNKNOWN_GRAPH": 9
            /**
             * Unknown property.
             */
            static readonly "UNKNOWN_PROPERTY": 10
            /**
             * Unsupported feature or method.
             */
            static readonly "UNSUPPORTED": 11
            /**
             * The ontology doesn't contain nrl:lastModified header
             */
            static readonly "MISSING_LAST_MODIFIED_HEADER": 12
            /**
             * The property is not completely defined.
             */
            static readonly "INCOMPLETE_PROPERTY_DEFINITION": 13
            /**
             * A soft/hard corruption was found in the database during operation.
             *   If this error is obtained during regular operations with an existing [class@SparqlConnection],
             *   the corruption was newly found. This event will be persistently recorded so that the
             *   [func@SparqlConnection.new_async] constructor (or its synchronous variant) will
             *   perform database repair attempts. If this error is obtained during one of those constructors, the
             *   database could not be repaired automatically and data loss is unavoidable. It is left to the discretion
             *   of the API user to set up the appropriate fallbacks in this situation, to replace the
             *   database and recover from the error. See [ctor@SparqlConnection.new] documentation
             *   for more information on corruption handling.
             */
            static readonly "CORRUPT": 14
            /**
             * The total number of error codes.
             */
            static readonly "LAST": 15
        }
        /**
         */
        function quark(): GLib.Quark
        
        namespace SparqlValueType {
            const $gtype: GObject.GType<SparqlValueType>
        }

        /**
         * Enumeration with the possible types of the cursor's cells
         */
        enum SparqlValueType {
            /**
             * Unbound value type
             */
            "UNBOUND" = 0,
            /**
             * Uri value type, rdfs:Resource
             */
            "URI" = 1,
            /**
             * String value type, xsd:string or rdf:langString
             */
            "STRING" = 2,
            /**
             * Integer value type, xsd:integer
             */
            "INTEGER" = 3,
            /**
             * Double value type, xsd:double
             */
            "DOUBLE" = 4,
            /**
             * Datetime value type, xsd:dateTime
             */
            "DATETIME" = 5,
            /**
             * Blank node value type
             */
            "BLANK_NODE" = 6,
            /**
             * Boolean value type, xsd:boolean
             */
            "BOOLEAN" = 7,
        }
        
        namespace SparqlConnectionFlags {
            const $gtype: GObject.GType<SparqlConnectionFlags>
        }

        /**
         * Connection flags to modify #TrackerSparqlConnection behavior.
         */
        enum SparqlConnectionFlags {
            /**
             * No flags.
             */
            "NONE" = 0,
            /**
             * Connection is readonly.
             */
            "READONLY" = 1,
            /**
             * Word stemming is applied to FTS search terms.
             */
            "FTS_ENABLE_STEMMER" = 2,
            /**
             * Unaccenting is applied to FTS search terms.
             */
            "FTS_ENABLE_UNACCENT" = 4,
            /**
             * FTS Search terms are filtered through a stop word list. This flag is deprecated since Tracker 3.6, and will do nothing.
             */
            "FTS_ENABLE_STOP_WORDS" = 8,
            /**
             * Ignore numbers in FTS search terms.
             */
            "FTS_IGNORE_NUMBERS" = 16,
            /**
             * Treat blank nodes as specified in
             *   SPARQL 1.1 syntax. Namely, they cannot be used as URIs. This flag is available since Tracker 3.3.
             */
            "ANONYMOUS_BNODES" = 32,
            /**
             * Disables no longer recommended [legacy syntax extensions to the SPARQL 1.1
             * specifications](sparql-and-tracker.md#legacy-syntax-extensions).
             * @since 3.11
             */
            "DISABLE_SYNTAX_EXTENSIONS" = 64,
            /**
             * Enables all behavior that provides most adherence to SPARQL 1.1 standards.
             * Currently this is equivalent to `ANONYMOUS_BNODES | DISABLE_SYNTAX_EXTENSIONS`.
             * More flags may be added in the future.
             * @since 3.11
             */
            "SPARQL_STRICT" = 96,
        }
    }

    export default Tracker
}