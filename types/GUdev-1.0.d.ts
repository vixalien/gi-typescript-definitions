
/// <reference path="./GLib-2.0.d.ts" />
/// <reference path="./GObject-2.0.d.ts" />

/**
 * Type Definitions for GJS (https://gjs.guide/), generated by [GirGen](https://github.com/aylur/girgen)
 * If you found a bug, create a bug report on [GirGen's Repository](https://github.com/aylur/girgen/issues/new)
 */
declare module "gi://GUdev?version=1.0" {
    import type GLib from "gi://GLib?version=2.0"
    import type GObject from "gi://GObject?version=2.0"

    


    namespace GUdev {
        const __name__: "GUdev"
        const __version: "1.0"
        

        namespace Client {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
                /**
                 *
                 * of the thread that @client was created in.
                 * @param action The action for the uevent e.g. "add", "remove", "change", "move",
                         "online" or "offline"
                 * @param device Details about the #GUdevDevice the event is for.
                 */
                "uevent"(action: string, device: Device): void
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "subsystems": string[]
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "subsystems": string[]
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         *  filesystem) and presented through
         * #GUdevDevice objects. This means that no blocking IO ever happens
         * (in both cases, we are essentially just reading data from kernel
         * memory) and as such there are no asynchronous versions of the
         * provided methods.
         *
         * To get #GUdevDevice objects, use
         * g_udev_client_query_by_subsystem(),
         * g_udev_client_query_by_device_number(),
         * g_udev_client_query_by_device_file(),
         * g_udev_client_query_by_sysfs_path(),
         * g_udev_client_query_by_subsystem_and_name()
         * or the #GUdevEnumerator type.
         *
         * To listen to uevents, connect to the #GUdevClient::uevent signal.
         */
        interface Client extends GObject.Object {
            readonly $signals: Client.SignalSignatures
            readonly $readableProperties: Client.ReadableProperties
            readonly $writableProperties: Client.WritableProperties
            readonly $constructOnlyProperties: Client.ConstructOnlyProperties
            /**
             * The subsystems to listen for uevents on.
             *
             * To listen for only a specific DEVTYPE for a given SUBSYSTEM, use
             * "subsystem/devtype". For example, to only listen for uevents
             * where SUBSYSTEM is usb and DEVTYPE is usb_interface, use
             * "usb/usb_interface".
             *
             * If this property is %NULL, then no events will be reported. If
             * it's the empty array, events from all subsystems will be
             * reported.
             */
            get subsystems(): string[]
            set subsystems(value: string[])
            /**
             * Looks up a device for a device file.
             * @param device_file A device file.
             * @returns A #GUdevDevice object or %NULL if the device was not found. Free with g_object_unref().
             */
            query_by_device_file(device_file: string): Device | null
            /**
             * Looks up a device for a type and device number.
             * @param type A value from the #GUdevDeviceType enumeration.
             * @param number A device number.
             * @returns A #GUdevDevice object or %NULL if the device was not found. Free with g_object_unref().
             */
            query_by_device_number(type: DeviceType, number: DeviceNumber): Device | null
            /**
             * Gets all devices belonging to @subsystem.
             * @param subsystem The subsystem to get devices for or %NULL to get all devices.
             * @returns A list of #GUdevDevice objects. The caller should free the result by using g_object_unref() on each element in the list and then g_list_free() on the list.
             */
            query_by_subsystem(subsystem: string | null): Device[] | null
            /**
             * Looks up a device for a subsystem and name.
             * @param subsystem A subsystem name.
             * @param name The name of the device.
             * @returns A #GUdevDevice object or %NULL if the device was not found. Free with g_object_unref().
             */
            query_by_subsystem_and_name(subsystem: string, name: string): Device | null
            /**
             * Looks up a device for a sysfs path.
             * @param sysfs_path A sysfs path.
             * @returns A #GUdevDevice object or %NULL if the device was not found. Free with g_object_unref().
             */
            query_by_sysfs_path(sysfs_path: string): Device | null
            /**
             * Signal class handler for the #GUdevClient::uevent signal.
             * @param action
             * @param device
             */
            vfunc_uevent(action: string, device: Device): void
        }

        interface ClientClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Client>
            readonly prototype: Client
            new (props?: Partial<GObject.ConstructorProps<Client>>): Client
            /**
             *
             * of the thread that you call this constructor from.
             * @param subsystems A %NULL terminated string array of subsystems to listen for uevents on, %NULL to not listen on uevents at all, or an empty array to listen to uevents on all subsystems. See the documentation for the #GUdevClient:subsystems property for details on this parameter.
             * @returns A new #GUdevClient object. Free with g_object_unref().
             */
            "new"(subsystems: string[] | null): Client
        }

        const Client: ClientClass
        

        namespace Device {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * The #GUdevDevice class is used to get information about a specific
         * device. Note that you cannot instantiate a #GUdevDevice object
         * yourself. Instead you must use #GUdevClient to obtain #GUdevDevice
         * objects.
         *
         * To get basic information about a device, use
         * g_udev_device_get_subsystem(), g_udev_device_get_devtype(),
         * g_udev_device_get_name(), g_udev_device_get_number(),
         * g_udev_device_get_sysfs_path(), g_udev_device_get_driver(),
         * g_udev_device_get_action(), g_udev_device_get_seqnum(),
         * g_udev_device_get_device_type(), g_udev_device_get_device_number(),
         * g_udev_device_get_device_file(),
         * g_udev_device_get_device_file_symlinks().
         *
         * To navigate the device tree, use g_udev_device_get_parent() and
         * g_udev_device_get_parent_with_subsystem().
         *
         * To access udev properties for the device, use
         * g_udev_device_get_property_keys(),
         * g_udev_device_has_property(),
         * g_udev_device_get_property(),
         * g_udev_device_get_property_as_int(),
         * g_udev_device_get_property_as_uint64(),
         * g_udev_device_get_property_as_double(),
         * g_udev_device_get_property_as_boolean() and
         * g_udev_device_get_property_as_strv().
         *
         * To access sysfs attributes for the device, use
         * g_udev_device_get_sysfs_attr_keys(),
         * g_udev_device_has_sysfs_attr(),
         * g_udev_device_get_sysfs_attr(),
         * g_udev_device_get_sysfs_attr_as_int(),
         * g_udev_device_get_sysfs_attr_as_uint64(),
         * g_udev_device_get_sysfs_attr_as_double(),
         * g_udev_device_get_sysfs_attr_as_boolean() and
         * g_udev_device_get_sysfs_attr_as_strv().
         *
         * Note that all getters on #GUdevDevice are non-reffing – returned
         * values are owned by the object, should not be freed and are only
         * valid as long as the object is alive.
         *
         * By design, #GUdevDevice will not react to changes for a device – it
         * only contains a snapshot of information when the #GUdevDevice
         * object was created. To work with changes, you typically connect to
         * the #GUdevClient::uevent signal on a #GUdevClient and get a new
         * #GUdevDevice whenever an event happens.
         */
        interface Device extends GObject.Object {
            readonly $signals: Device.SignalSignatures
            readonly $readableProperties: Device.ReadableProperties
            readonly $writableProperties: Device.WritableProperties
            readonly $constructOnlyProperties: Device.ConstructOnlyProperties
            /**
             * Gets the most recent action (e.g. "add", "remove", "change", etc.) for @device.
             * @returns An action string.
             */
            get_action(): string
            /**
             * Gets all current tags for @device.
             *
             * https://www.freedesktop.org/software/systemd/man/udev_device_has_current_tag.html
             * @since 238
             * @returns A %NULL terminated string array of current tags. This array is owned by `device` and should not be freed by the caller.
             */
            get_current_tags(): string[]
            /**
             * Gets the device file for @device.
             * @returns The device file for `device` or %NULL if no device file exists.
             */
            get_device_file(): string | null
            /**
             * ) that points to
             * the device file for @device.
             * @returns A %NULL terminated string array of symlinks. This array is owned by `device` and should not be freed by the caller.
             */
            get_device_file_symlinks(): string[]
            /**
             * Gets the device number, if any, for @device.
             * @returns The device number for `device` or 0 if unknown.
             */
            get_device_number(): DeviceNumber
            /**
             * Gets the type of the device file, if any, for @device.
             * @returns The device number for `device` or #G_UDEV_DEVICE_TYPE_NONE if the device does not have a device file.
             */
            get_device_type(): DeviceType
            /**
             * Gets the device type for @device.
             * @returns The devtype for `device`.
             */
            get_devtype(): string
            /**
             * Gets the name of the driver used for @device.
             * @returns The name of the driver for `device` or %NULL if unknown.
             */
            get_driver(): string | null
            /**
             * Gets whether @device has been initialized.
             * @since 165
             * @returns Whether `device` has been initialized.
             */
            get_is_initialized(): boolean
            /**
             * Gets the name of @device, e.g. "sda3".
             * @returns The name of `device`.
             */
            get_name(): string
            /**
             * Gets the number of @device, e.g. "3" if g_udev_device_get_name() returns "sda3".
             * @returns The number of `device`.
             */
            get_number(): string
            /**
             * Gets the immediate parent of @device, if any.
             * @returns A #GUdevDevice or %NULL if `device` has no parent. Free with g_object_unref().
             */
            get_parent(): Device | null
            /**
             * Walks up the chain of parents of @device and returns the first
             * device encountered where @subsystem and @devtype matches, if any.
             * @param subsystem The subsystem of the parent to get.
             * @param devtype The devtype of the parent to get or %NULL.
             * @returns A #GUdevDevice or %NULL if `device` has no parent with `subsystem` and `devtype`. Free with g_object_unref().
             */
            get_parent_with_subsystem(subsystem: string, devtype: string | null): Device | null
            /**
             * Look up the value for @key on @device.
             * @param key Name of property.
             * @returns The value for `key` or %NULL if `key` doesn't exist on `device`. Do not free this string, it is owned by `device`.
             */
            get_property(key: string): string | null
            /**
             * Look up the value for @key on @device and convert it to an
             * boolean. This is done by doing a case-insensitive string comparison
             * on the string value against "1" and "true".
             * @param key Name of property.
             * @returns The value for `key` or %FALSE if `key` doesn't exist or isn't a #gboolean.
             */
            get_property_as_boolean(key: string): boolean
            /**
             * Look up the value for @key on @device and convert it to a double
             * precision floating point number using g_ascii_strtod().
             * @param key Name of property.
             * @returns The value for `key` or 0.0 if `key` doesn't exist or isn't a #gdouble.
             */
            get_property_as_double(key: string): number
            /**
             * Look up the value for @key on @device and convert it to an integer
             * using strtol().
             * @param key Name of property.
             * @returns The value for `key` or 0 if `key` doesn't exist or isn't an integer.
             */
            get_property_as_int(key: string): number
            /**
             * Look up the value for @key on @device and return the result of
             * splitting it into non-empty tokens split at white space (only space
             * (' '), form-feed ('\f'), newline ('\n'), carriage return ('\r'),
             * horizontal tab ('\t'), and vertical tab ('\v') are considered; the
             * locale is not taken into account).
             * @param key Name of property.
             * @returns  The value of `key` on `device` split into tokens or %NULL if `key` doesn't exist. This array is owned by `device` and should not be freed by the caller.
             */
            get_property_as_strv(key: string): string[] | null
            /**
             * Look up the value for @key on @device and convert it to an unsigned
             * 64-bit integer using g_ascii_strtoull().
             * @param key Name of property.
             * @returns The value  for `key` or 0 if `key` doesn't  exist or isn't a #guint64.
             */
            get_property_as_uint64(key: string): number
            /**
             * Gets all keys for properties on @device.
             * @returns A %NULL terminated string array of property keys. This array is owned by `device` and should not be freed by the caller.
             */
            get_property_keys(): string[]
            /**
             * Gets the most recent sequence number for @device.
             * @returns A sequence number.
             */
            get_seqnum(): number
            /**
             * Gets the subsystem for @device.
             * @returns The subsystem for `device`.
             */
            get_subsystem(): string
            /**
             * Look up the sysfs attribute with @name on @device. The retrieved value
             * is cached in the device. Repeated calls will return the same value and
             * not open the attribute again, unless updated through one of the
             * "uncached" functions.
             * @param name Name of the sysfs attribute.
             * @returns The value of the sysfs attribute or %NULL if there is no such attribute. Do not free this string, it is owned by `device`.
             */
            get_sysfs_attr(name: string): string | null
            /**
             * Look up the sysfs attribute with @name on @device and convert it to an
             * boolean. This is done by doing a case-insensitive string comparison
             * on the string value against "1", "true", "Y" and "y". The retrieved value is
             * cached in the device. Repeated calls will return the same value and
             * not open the attribute again, unless updated through one of the
             * "uncached" functions.
             * @param name Name of the sysfs attribute.
             * @returns The value of the sysfs attribute or %FALSE if there is no such attribute.
             */
            get_sysfs_attr_as_boolean(name: string): boolean
            /**
             * Look up the sysfs attribute with @name on @device and convert it to an
             * boolean. This is done by doing a case-insensitive string comparison
             * on the string value against "1", "true", "Y" and "y". This function does
             * blocking I/O, and updates the sysfs attributes cache.
             *
             * Before version 238 the uncached getters would not strip trailing newlines.
             * @since 234
             * @param name Name of the sysfs attribute.
             * @returns The value of the sysfs attribute or %FALSE if there is no such attribute.
             */
            get_sysfs_attr_as_boolean_uncached(name: string): boolean
            /**
             * Look up the sysfs attribute with @name on @device and convert it to a double
             * precision floating point number using g_ascii_strtod(). The retrieved value is cached
             * in the device. Repeated calls will return the same value and not open the
             * attribute again, unless updated through one of the "uncached" functions.
             * @param name Name of the sysfs attribute.
             * @returns The value of the sysfs attribute or 0.0 if there is no such attribute.
             */
            get_sysfs_attr_as_double(name: string): number
            /**
             * Look up the sysfs attribute with @name on @device and convert it to a double
             * precision floating point number using g_ascii_strtod(). This function does blocking
             * I/O, and updates the sysfs attributes cache.
             *
             * Before version 238 the uncached getters would not strip trailing newlines.
             * @since 234
             * @param name Name of the sysfs attribute.
             * @returns The value of the sysfs attribute or 0.0 if there is no such attribute.
             */
            get_sysfs_attr_as_double_uncached(name: string): number
            /**
             * Look up the sysfs attribute with @name on @device and convert it to an integer
             * using strtol(). The retrieved value is cached in the device. Repeated calls
             * will return the same value and not open the attribute again, unless updated
             * through one of the "uncached" functions.
             * @param name Name of the sysfs attribute.
             * @returns The value of the sysfs attribute or 0 if there is no such attribute.
             */
            get_sysfs_attr_as_int(name: string): number
            /**
             * Look up the sysfs attribute with @name on @device and convert it to an integer
             * using strtol(). This function does blocking I/O, and updates the sysfs
             * attributes cache.
             *
             * Before version 238 the uncached getters would not strip trailing newlines.
             * @since 234
             * @param name Name of the sysfs attribute.
             * @returns The value of the sysfs attribute or 0 if there is no such attribute.
             */
            get_sysfs_attr_as_int_uncached(name: string): number
            /**
             * Look up the sysfs attribute with @name on @device and return the result of
             * splitting it into non-empty tokens split at white space (only space (' '),
             * form-feed ('\f'), newline ('\n'), carriage return ('\r'), horizontal
             * tab ('\t'), and vertical tab ('\v') are considered; the locale is
             * not taken into account).
             *
             * The retrieved value is cached in the device. Repeated calls will return
             * the same value and not open the attribute again, unless updated through
             * one of the "uncached" functions.
             * @param name Name of the sysfs attribute.
             * @returns  The value of the sysfs attribute split into tokens or %NULL if there is no such attribute. This array is owned by `device` and should not be freed by the caller.
             */
            get_sysfs_attr_as_strv(name: string): string[] | null
            /**
             * Look up the sysfs attribute with @name on @device and return the result of
             * splitting it into non-empty tokens split at white space (only space (' '),
             * form-feed ('\f'), newline ('\n'), carriage return ('\r'), horizontal
             * tab ('\t'), and vertical tab ('\v') are considered; the locale is
             * not taken into account).
             *
             * This function does blocking I/O, and updates the sysfs attributes cache.
             * @since 234
             * @param name Name of the sysfs attribute.
             * @returns  The value of the sysfs attribute split into tokens or %NULL if there is no such attribute. This array is owned by `device` and should not be freed by the caller.  Before version 238 the uncached getters would not strip trailing newlines.
             */
            get_sysfs_attr_as_strv_uncached(name: string): string[] | null
            /**
             * Look up the sysfs attribute with @name on @device and convert it to an unsigned
             * 64-bit integer using g_ascii_strtoull(). The retrieved value is cached in the
             * device. Repeated calls will return the same value and not open the attribute
             * again, unless updated through one of the "uncached" functions.
             * @param name Name of the sysfs attribute.
             * @returns The value of the sysfs attribute or 0 if there is no such attribute.
             */
            get_sysfs_attr_as_uint64(name: string): number
            /**
             * Look up the sysfs attribute with @name on @device and convert it to an unsigned
             * 64-bit integer using g_ascii_strtoull(). This function does blocking I/O, and
             * updates the sysfs attributes cache.
             *
             * Before version 238 the uncached getters would not strip trailing newlines.
             * @since 234
             * @param name Name of the sysfs attribute.
             * @returns The value of the sysfs attribute or 0 if there is no such attribute.
             */
            get_sysfs_attr_as_uint64_uncached(name: string): number
            /**
             * Gets all keys for sysfs attributes on @device.
             * @returns A %NULL terminated string array of sysfs attribute keys. This array is owned by `device` and should not be freed by the caller.
             */
            get_sysfs_attr_keys(): string[]
            /**
             * Look up the sysfs attribute with @name on @device. This function does
             * blocking I/O, and updates the sysfs attributes cache.
             *
             * Before version 238 the uncached getters would not strip trailing newlines.
             * @since 234
             * @param name Name of the sysfs attribute.
             * @returns The value of the sysfs attribute or %NULL if there is no such attribute. Do not free this string, it is owned by `device`.
             */
            get_sysfs_attr_uncached(name: string): string | null
            /**
             * Gets the sysfs path for @device.
             * @returns The sysfs path for `device`.
             */
            get_sysfs_path(): string
            /**
             * Gets all tags for @device.
             * @since 165
             * @returns A %NULL terminated string array of tags. This array is owned by `device` and should not be freed by the caller.
             */
            get_tags(): string[]
            /**
             * Gets number of micro-seconds since @device was initialized.
             *
             * This only works for devices with properties in the udev
             * database. All other devices return 0.
             * @since 165
             * @returns Number of micro-seconds since `device` was initialized or 0 if unknown.
             */
            get_usec_since_initialized(): number
            /**
             * Check if a the property with the given key exists.
             * @param key Name of property.
             * @returns %TRUE only if the value for `key` exist.
             */
            has_property(key: string): boolean
            /**
             * Check if a the sysfs attribute with the given key exists. The
             * retrieved value is cached in the device. Repeated calls will
             * return the same result and not check for the presence of the
             * attribute again, unless updated through one of the "uncached"
             * functions.
             * @param key Name of sysfs attribute.
             * @returns %TRUE only if the value for `key` exist.
             */
            has_sysfs_attr(key: string): boolean
            /**
             * Check if a the sysfs attribute with the given key exists. The
             * retrieved value is cached in the device. Repeated calls will
             * return the same result and not check for the presence of the
             * attribute again, unless updated through one of the "uncached"
             * functions.
             * @since 234
             * @param key Name of sysfs attribute.
             * @returns %TRUE only if the value for `key` exist.
             */
            has_sysfs_attr_uncached(key: string): boolean
        }

        interface DeviceClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Device>
            readonly prototype: Device
            new (props?: Partial<GObject.ConstructorProps<Device>>): Device
        }

        const Device: DeviceClass
        

        namespace Enumerator {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "client": Client
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "client": Client
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * #GUdevEnumerator is used to lookup and sort devices.
         * @since 165
         */
        interface Enumerator extends GObject.Object {
            readonly $signals: Enumerator.SignalSignatures
            readonly $readableProperties: Enumerator.ReadableProperties
            readonly $writableProperties: Enumerator.WritableProperties
            readonly $constructOnlyProperties: Enumerator.ConstructOnlyProperties
            /**
             * The #GUdevClient to enumerate devices from.
             * @since 165
             */
            get client(): Client
            set client(value: Client)
            /**
             * All returned devices will be initialized.
             * @since 165
             * @returns The passed in `enumerator`.
             */
            add_match_is_initialized(): Enumerator
            /**
             * All returned devices will match the given @name.
             * @since 165
             * @param name Wildcard filter for kernel name e.g. "sda*".
             * @returns The passed in `enumerator`.
             */
            add_match_name(name: string): Enumerator
            /**
             * All returned devices will have a property matching the given @name and @value.
             * @since 165
             * @param name Wildcard filter for property name.
             * @param value Wildcard filter for property value.
             * @returns The passed in `enumerator`.
             */
            add_match_property(name: string, value: string): Enumerator
            /**
             * All returned devices will match the given @subsystem.
             * @since 165
             * @param subsystem Wildcard for subsystem name e.g. 'scsi' or 'a*'.
             * @returns The passed in `enumerator`.
             */
            add_match_subsystem(subsystem: string): Enumerator
            /**
             * All returned devices will have a sysfs attribute matching the given @name and @value.
             * @since 165
             * @param name Wildcard filter for sysfs attribute key.
             * @param value Wildcard filter for sysfs attribute value.
             * @returns The passed in `enumerator`.
             */
            add_match_sysfs_attr(name: string, value: string): Enumerator
            /**
             * All returned devices will match the given @tag.
             * @since 165
             * @param tag A udev tag e.g. "udev-acl".
             * @returns The passed in `enumerator`.
             */
            add_match_tag(tag: string): Enumerator
            /**
             * All returned devices will not match the given @subsystem.
             * @since 165
             * @param subsystem Wildcard for subsystem name e.g. 'scsi' or 'a*'.
             * @returns The passed in `enumerator`.
             */
            add_nomatch_subsystem(subsystem: string): Enumerator
            /**
             * All returned devices will not have a sysfs attribute matching the given @name and @value.
             * @since 165
             * @param name Wildcard filter for sysfs attribute key.
             * @param value Wildcard filter for sysfs attribute value.
             * @returns The passed in `enumerator`.
             */
            add_nomatch_sysfs_attr(name: string, value: string): Enumerator
            /**
             * Add a device to the list of devices, to retrieve it back sorted in dependency order.
             * @since 165
             * @param sysfs_path A sysfs path, e.g. "/sys/devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda"
             * @returns The passed in `enumerator`.
             */
            add_sysfs_path(sysfs_path: string): Enumerator
            /**
             * Executes the query in @enumerator.
             * @since 165
             * @returns A list of #GUdevDevice objects. The caller should free the result by using g_object_unref() on each element in the list and then g_list_free() on the list.
             */
            execute(): Device[]
        }

        interface EnumeratorClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Enumerator>
            readonly prototype: Enumerator
            new (props?: Partial<GObject.ConstructorProps<Enumerator>>): Enumerator
            /**
             * Constructs a #GUdevEnumerator object that can be used to enumerate
             * and sort devices. Use the add_match_*() and add_nomatch_*() methods
             * and execute the query to get a list of devices with
             * g_udev_enumerator_execute().
             * @since 165
             * @param client A #GUdevClient to enumerate devices from.
             * @returns A new #GUdevEnumerator object. Free with g_object_unref().
             */
            "new"(client: Client): Enumerator
        }

        const Enumerator: EnumeratorClass
        none
        /**
         */
        abstract class ClientPrivate {
            static readonly $gtype: GObject.GType<ClientPrivate>

            
        }
        none
        /**
         */
        abstract class DevicePrivate {
            static readonly $gtype: GObject.GType<DevicePrivate>

            
        }
        none
        /**
         */
        abstract class EnumeratorPrivate {
            static readonly $gtype: GObject.GType<EnumeratorPrivate>

            
        }
        
        namespace DeviceType {
            const $gtype: GObject.GType<DeviceType>
        }

        /**
         * Enumeration used to specify a the type of a device.
         */
        enum DeviceType {
            /**
             * Device does not have a device file.
             */
            "NONE" = 0,
            /**
             * Device is a block device.
             */
            "BLOCK" = 98,
            /**
             * Device is a character device.
             */
            "CHAR" = 99,
        }
        /**
         * Corresponds to the standard #dev_t type as defined by POSIX (Until
         * bug 584517 is resolved this work-around is needed).
         */
        type DeviceNumber = number
    }

    export default GUdev
}