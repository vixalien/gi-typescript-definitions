
/// <reference path="./GLib-2.0.d.ts" />
/// <reference path="./GObject-2.0.d.ts" />
/// <reference path="./GModule-2.0.d.ts" />
/// <reference path="./GUdev-1.0.d.ts" />
/// <reference path="./Gio-2.0.d.ts" />

/**
 * Type Definitions for GJS (https://gjs.guide/), generated by [GirGen](https://github.com/aylur/girgen)
 * If you found a bug, create a bug report on [GirGen's Repository](https://github.com/aylur/girgen/issues/new)
 */
declare module "gi://Manette?version=1" {
    import type GLib from "gi://GLib?version=2.0"
    import type GObject from "gi://GObject?version=2.0"
    import type GModule from "gi://GModule?version=2.0"
    import type GUdev from "gi://GUdev?version=1.0"
    import type Gio from "gi://Gio?version=2.0"

    


    namespace Manette {
        const __name__: "Manette"
        const __version: "1"
        

        namespace Device {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
                /**
                 * Emitted when value of @axis changes.
                 * @param axis the axis
                 * @param value the axis value
                 */
                "absolute-axis-changed"(axis: Axis, value: number): void
                /**
                 * Emitted when @button is pressed.
                 * @param button the button
                 */
                "button-pressed"(button: Button): void
                /**
                 * Emitted when @button is released.
                 * @param button the button
                 */
                "button-released"(button: Button): void
                /**
                 * Emitted when the device is disconnected.
                 */
                "disconnected"(): void
                /**
                 * Emitted when an unmapped absolute axis' value changes.
                 * @param axis the axis hardware index
                 * @param value the axis value
                 */
                "unmapped-absolute-axis-changed"(axis: number, value: number): void
                /**
                 * Emitted when an unmapped button is pressed.
                 * @param index the button hardware index
                 */
                "unmapped-button-pressed"(index: number): void
                /**
                 * Emitted when an unmapped button is released.
                 * @param index the button hardware index
                 */
                "unmapped-button-released"(index: number): void
                /**
                 * Emitted when an unmapped hat axis' value changes.
                 * @param axis the axis hardware index
                 * @param value the axis value
                 */
                "unmapped-hat-axis-changed"(axis: number, value: number): void
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * An object representing a physical gamepad.
         *
         * See also: [class@Monitor].
         */
        interface Device extends GObject.Object {
            readonly $signals: Device.SignalSignatures
            readonly $readableProperties: Device.ReadableProperties
            readonly $writableProperties: Device.WritableProperties
            readonly $constructOnlyProperties: Device.ConstructOnlyProperties
            /**
             * Gets the timestamp of when the current event was emitted on @self.
             *
             * Use this timestamp to ensure external factors such as synchronous disk writes
             * don't influence your timing computations.
             * @returns the timestamp of when the current event was emitted
             */
            get_current_event_time(): number
            /**
             * Gets the device type of @self.
             * @returns the device type
             */
            get_device_type(): DeviceType
            /**
             * Gets the identifier used by SDL mappings to discriminate game controller
             * devices.
             * @returns the identifier used by SDL mappings
             */
            get_guid(): string
            /**
             * Gets the user mapping for @self, or default mapping if there isn't any.
             *
             * Can return `NULL` if there's no mapping or @self doesn't support mappings.
             * @returns the mapping for `self`
             */
            get_mapping(): string | null
            /**
             * Gets the device's name.
             * @returns the name of `self`
             */
            get_name(): string
            /**
             * Gets whether the device has @axis.
             * @param axis an axis
             * @returns whether the device has `axis`
             */
            has_axis(axis: Axis): boolean
            /**
             * Gets whether the device has @button.
             * @param button a button
             * @returns whether the device has `button`
             */
            has_button(button: Button): boolean
            /**
             * Gets whether the device has the given input.
             *
             * If the input is present, it means that the device can send events for it
             * regardless of whether the device is mapped or not.
             * @param type the input type
             * @param code the input code
             * @returns whether the device has the given input
             */
            has_input(type: number, code: number): boolean
            /**
             * Gets whether @self supports rumble.
             * @returns whether `self` supports rumble
             */
            has_rumble(): boolean
            /**
             * Gets whether @self has a user mapping.
             * @returns whether `self` has a user mapping
             */
            has_user_mapping(): boolean
            /**
             * Removes the user mapping for @self.
             */
            remove_user_mapping(): void
            /**
             * Make @self rumble during @milliseconds milliseconds.
             *
             * The heavy and light motors will rumble at their respectively defined
             * magnitudes.
             *
             * The duration cannot exceed 32767 milliseconds.
             * @param strong_magnitude the magnitude for the heavy motor
             * @param weak_magnitude the magnitude for the light motor
             * @param milliseconds the rumble effect play time in milliseconds
             * @returns whether the rumble effect was played
             */
            rumble(strong_magnitude: number, weak_magnitude: number, milliseconds: number): boolean
            /**
             * Saves @mapping_string as the user mapping for @self.
             * @param mapping_string the mapping string
             */
            save_user_mapping(mapping_string: string): void
            /**
             * Gets whether @self supports mapping.
             * @returns whether `self` supports mapping
             */
            supports_mapping(): boolean
        }

        interface DeviceClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Device>
            readonly prototype: Device
            new (props?: Partial<GObject.ConstructorProps<Device>>): Device
        }

        const Device: DeviceClass
        

        namespace Monitor {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
                /**
                 * Emitted when @device is connected.
                 * @param device a device
                 */
                "device-connected"(device: Device): void
                /**
                 * Emitted when @device is disconnected.
                 * @param device a device
                 */
                "device-disconnected"(device: Device): void
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * An object monitoring the availability of devices.
         *
         * See also: [class@Device].
         */
        interface Monitor extends GObject.Object {
            readonly $signals: Monitor.SignalSignatures
            readonly $readableProperties: Monitor.ReadableProperties
            readonly $writableProperties: Monitor.WritableProperties
            readonly $constructOnlyProperties: Monitor.ConstructOnlyProperties
            /**
             * Lists the currently connected devices.
             * @returns the list of devices
             */
            list_devices(): Device[]
        }

        interface MonitorClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Monitor>
            readonly prototype: Monitor
            new (props?: Partial<GObject.ConstructorProps<Monitor>>): Monitor
            /**
             * Creates a new `ManetteMonitor`.
             * @returns a new `ManetteMonitor`
             */
            "new"(): Monitor
        }

        const Monitor: MonitorClass
        none
        none
        /**
         * Returns the major version number of the libmanette library.
         *
         * For example, in libmanette version 1.2.3 this is 1.
         *
         * This function is in the library, so it represents the libmanette library your
         * code is running against. Contrast with the [const@MAJOR_VERSION] constant,
         * which represents the major version of the libmanette headers you have
         * included when compiling your code.
         * @returns the major version number of the libmanette library
         */
        function get_major_version(): number
        /**
         * Returns the micro version number of the libmanette library.
         *
         * For example, in libmanette version 1.2.3 this is 3.
         *
         * This function is in the library, so it represents the libmanette library your
         * code is running against. Contrast with the [const@MAJOR_VERSION] constant,
         * which represents the micro version of the libmanette headers you have
         * included when compiling your code.
         * @returns the micro version number of the libmanette library
         */
        function get_micro_version(): number
        /**
         * Returns the minor version number of the libmanette library.
         *
         * For example, in libmanette version 1.2.3 this is 2.
         *
         * This function is in the library, so it represents the libmanette library your
         * code is running against. Contrast with the [const@MAJOR_VERSION] constant,
         * which represents the minor version of the libmanette headers you have
         * included when compiling your code.
         * @returns the minor version number of the libmanette library
         */
        function get_minor_version(): number
        const MAJOR_VERSION: 1
        const MICRO_VERSION: 0
        const MINOR_VERSION: 0
        const VERSION_S: "1.0.alpha"
        
        namespace Axis {
            const $gtype: GObject.GType<Axis>
        }

        /**
         * Describes available axes a [class@Device] can have.
         *
         * More values may be added to this enumeration over time.
         */
        enum Axis {
            /**
             * Left analog stick, horizontal axis
             */
            "LEFT_X" = 0,
            /**
             * Left analog stick, vertical axis
             */
            "LEFT_Y" = 1,
            /**
             * Right analog stick, horizontal axis
             */
            "RIGHT_X" = 2,
            /**
             * Right analog stick, vertical axis
             */
            "RIGHT_Y" = 3,
            /**
             * Left trigger (L2, LT or ZL)
             */
            "LEFT_TRIGGER" = 4,
            /**
             * Right trigger (R2, RT or ZR)
             */
            "RIGHT_TRIGGER" = 5,
        }
        
        namespace Button {
            const $gtype: GObject.GType<Button>
        }

        /**
         * Describes available buttons a [class@Device] can have.
         *
         * More values may be added to this enumeration over time.
         */
        enum Button {
            /**
             * D-pad (up)
             */
            "DPAD_UP" = 0,
            /**
             * D-pad (down)
             */
            "DPAD_DOWN" = 1,
            /**
             * D-pad (left)
             */
            "DPAD_LEFT" = 2,
            /**
             * D-pad (right)
             */
            "DPAD_RIGHT" = 3,
            /**
             * Top face button
             *     (XBox Y, Nintendo X, PlayStation triangle)
             */
            "NORTH" = 4,
            /**
             * Bottom face button
             *     (XBox A, Nintendo B, PlayStation X)
             */
            "SOUTH" = 5,
            /**
             * Left face button
             *     (XBox X, Nintendo Y, PlayStation square)
             */
            "WEST" = 6,
            /**
             * Right face button
             *     (XBox B, Nintendo A, PlayStation circle)
             */
            "EAST" = 7,
            /**
             * Left menu button
             */
            "SELECT" = 8,
            /**
             * Right menu button
             */
            "START" = 9,
            /**
             * Center menu button (Home, Guide, Steam etc)
             */
            "MODE" = 10,
            /**
             * Left shoulder button (L, L1 or LB)
             */
            "LEFT_SHOULDER" = 11,
            /**
             * Right shoulder button (R, R1 or RB)
             */
            "RIGHT_SHOULDER" = 12,
            /**
             * Left stick
             */
            "LEFT_STICK" = 13,
            /**
             * Right stick
             */
            "RIGHT_STICK" = 14,
            /**
             * Upper left paddle
             *     (Steam Deck L4 or XBox Elite P3)
             */
            "LEFT_PADDLE1" = 15,
            /**
             * Lower left paddle
             *     (Steam Deck L5 or XBox Elite P4)
             */
            "LEFT_PADDLE2" = 16,
            /**
             * Upper right paddle
             *     (Steam Deck R4 or XBox Elite P1)
             */
            "RIGHT_PADDLE1" = 17,
            /**
             * Lower right paddle
             *     (Steam Deck R5 or XBox Elite P2)
             */
            "RIGHT_PADDLE2" = 18,
            /**
             * Additional button
             *     (Steam Deck QAM button, Xbox Series X share button etc)
             */
            "MISC1" = 19,
            /**
             * Additional button
             */
            "MISC2" = 20,
            /**
             * Additional button
             */
            "MISC3" = 21,
            /**
             * Additional button
             */
            "MISC4" = 22,
            /**
             * Additional button
             */
            "MISC5" = 23,
            /**
             * Additional button
             */
            "MISC6" = 24,
            /**
             * PS4/PS5 touchpad button
             */
            "TOUCHPAD" = 25,
        }
        
        namespace DeviceType {
            const $gtype: GObject.GType<DeviceType>
        }

        /**
         * Describes available types of a [class@Device].
         *
         * More values may be added to this enumeration over time.
         */
        enum DeviceType {
            /**
             * Generic gamepads
             */
            "GENERIC" = 0,
            /**
             * Steam Deck
             */
            "STEAM_DECK" = 1,
        }
    }

    export default Manette
}