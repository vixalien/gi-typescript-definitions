
/// <reference path="./GLib-2.0.d.ts" />
/// <reference path="./GModule-2.0.d.ts" />
/// <reference path="./GObject-2.0.d.ts" />
/// <reference path="./Gio-2.0.d.ts" />

/**
 * Type Definitions for GJS (https://gjs.guide/), generated by [GirGen](https://github.com/aylur/girgen)
 * If you found a bug, create a bug report on [GirGen's Repository](https://github.com/aylur/girgen/issues/new)
 */
declare module "gi://GIRepository?version=3.0" {
    import type GLib from "gi://GLib?version=2.0"
    import type GModule from "gi://GModule?version=2.0"
    import type GObject from "gi://GObject?version=2.0"
    import type Gio from "gi://Gio?version=2.0"

    


    namespace GIRepository {
        const __name__: "GIRepository"
        const __version: "3.0"
        

        namespace ArgInfo {
            interface SignalSignatures extends BaseInfo.SignalSignatures {
            }

            interface ReadableProperties extends BaseInfo.ReadableProperties {
            }

            interface WritableProperties extends BaseInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends BaseInfo.ConstructOnlyProperties {
            }
        }

        /**
         * `GIArgInfo` represents an argument of a callable.
         *
         * An argument is always part of a [class@GIRepository.CallableInfo].
         * @since 2.80
         */
        interface ArgInfo extends BaseInfo {
            readonly $signals: ArgInfo.SignalSignatures
            readonly $readableProperties: ArgInfo.ReadableProperties
            readonly $writableProperties: ArgInfo.WritableProperties
            readonly $constructOnlyProperties: ArgInfo.ConstructOnlyProperties
            /**
             * Obtain the index of the user data argument. This is only valid
             * for arguments which are callbacks.
             * @since 2.80
             * @returns `TRUE` if the argument has a user data argument, return location for the closure index
             */
            get_closure_index(): boolean
            /**
             * Obtains the index of the [type@GLib.DestroyNotify] argument. This is only
             * valid for arguments which are callbacks.
             * @since 2.80
             * @returns `TRUE` if the argument has a [type@GLib.DestroyNotify] argument, return location for the destroy index
             */
            get_destroy_index(): boolean
            /**
             * Obtain the direction of the argument. Check [type@GIRepository.Direction]
             * for possible direction values.
             * @since 2.80
             * @returns The direction
             */
            get_direction(): Direction
            /**
             * Obtain the ownership transfer for this argument.
             * [type@GIRepository.Transfer] contains a list of possible values.
             * @since 2.80
             * @returns The transfer
             */
            get_ownership_transfer(): Transfer
            /**
             * Obtain the scope type for this argument.
             *
             * The scope type explains how a callback is going to be invoked, most
             * importantly when the resources required to invoke it can be freed.
             *
             * [type@GIRepository.ScopeType] contains a list of possible values.
             * @since 2.80
             * @returns The scope type
             */
            get_scope(): ScopeType
            /**
             * Obtain the type information for @info.
             * @since 2.80
             * @returns The [class@GIRepository.TypeInfo] holding the type   information for `info`, free it with [method@GIRepository.BaseInfo.unref]   when done
             */
            get_type_info(): TypeInfo
            /**
             * Obtain if the argument is a pointer to a struct or object that will
             * receive an output of a function.
             *
             * The default assumption for `GI_DIRECTION_OUT` arguments which have allocation
             * is that the callee allocates; if this is `TRUE`, then the caller must
             * allocate.
             * @since 2.80
             * @returns `TRUE` if caller is required to have allocated the argument
             */
            is_caller_allocates(): boolean
            /**
             * Obtain if the argument is optional.
             *
             * For ‘out’ arguments this means that you can pass `NULL` in order to ignore
             * the result.
             * @since 2.80
             * @returns `TRUE` if it is an optional argument
             */
            is_optional(): boolean
            /**
             * Obtain if the argument is a return value. It can either be a
             * parameter or a return value.
             * @since 2.80
             * @returns `TRUE` if it is a return value
             */
            is_return_value(): boolean
            /**
             * Obtain if an argument is only useful in C.
             * @since 2.80
             * @returns `TRUE` if argument is only useful in C.
             */
            is_skip(): boolean
            /**
             * Obtain information about a the type of given argument @info; this
             * function is a variant of [method@GIRepository.ArgInfo.get_type_info] designed
             * for stack allocation.
             *
             * The initialized @type must not be referenced after @info is deallocated.
             *
             * Once you are done with @type, it must be cleared using
             * [method@GIRepository.BaseInfo.clear].
             * @since 2.80
             * @returns , Initialized with information about type of `info`
             */
            load_type_info(): TypeInfo
            /**
             * Obtain if the type of the argument includes the possibility of `NULL`.
             *
             * For ‘in’ values this means that `NULL` is a valid value.  For ‘out’
             * values, this means that `NULL` may be returned.
             *
             * See also [method@GIRepository.ArgInfo.is_optional].
             * @since 2.80
             * @returns `TRUE` if the value may be `NULL`
             */
            may_be_null(): boolean
        }

        interface ArgInfoClass extends Omit<BaseInfoClass, "new"> {
            readonly $gtype: GObject.GType<ArgInfo>
            readonly prototype: ArgInfo
            new (props?: Partial<GObject.ConstructorProps<ArgInfo>>): ArgInfo
        }

        const ArgInfo: ArgInfoClass
        

        namespace BaseInfo {
            interface SignalSignatures  {
            }

            interface ReadableProperties  {
            }

            interface WritableProperties  {
            }

            interface ConstructOnlyProperties  {
            }
        }

        /**
         * `GIBaseInfo` is the common base struct of all other Info structs
         * accessible through the [class@GIRepository.Repository] API.
         *
         * All info structures can be cast to a `GIBaseInfo`, for instance:
         *
         * ```c
         *    GIFunctionInfo *function_info = …;
         *    GIBaseInfo *info = (GIBaseInfo *) function_info;
         * ```
         *
         * Most [class@GIRepository.Repository] APIs returning a `GIBaseInfo` are
         * actually creating a new struct; in other words,
         * [method@GIRepository.BaseInfo.unref] has to be called when done accessing the
         * data.
         *
         * `GIBaseInfo` structuress are normally accessed by calling either
         * [method@GIRepository.Repository.find_by_name],
         * [method@GIRepository.Repository.find_by_gtype] or
         * [method@GIRepository.get_info].
         *
         * ```c
         * GIBaseInfo *button_info =
         *   gi_repository_find_by_name (NULL, "Gtk", "Button");
         *
         * // use button_info…
         *
         * gi_base_info_unref (button_info);
         * ```
         * @since 2.80
         */
        interface BaseInfo  {
            readonly $signals: BaseInfo.SignalSignatures
            readonly $readableProperties: BaseInfo.ReadableProperties
            readonly $writableProperties: BaseInfo.WritableProperties
            readonly $constructOnlyProperties: BaseInfo.ConstructOnlyProperties
            /**
             * Clears memory allocated internally by a stack-allocated
             * [type@GIRepository.BaseInfo].
             *
             * This does not deallocate the [type@GIRepository.BaseInfo] struct itself. It
             * does clear the struct to zero so that calling this function subsequent times
             * on the same struct is a no-op.
             *
             * This must only be called on stack-allocated [type@GIRepository.BaseInfo]s.
             * Use [method@GIRepository.BaseInfo.unref] for heap-allocated ones.
             * @since 2.80
             */
            clear(): void
            /**
             * Compare two `GIBaseInfo`s.
             *
             * Using pointer comparison is not practical since many functions return
             * different instances of `GIBaseInfo` that refers to the same part of the
             * TypeLib; use this function instead to do `GIBaseInfo` comparisons.
             * @since 2.80
             * @param info2 a #GIBaseInfo
             * @returns `TRUE` if and only if `info1` equals `info2`.
             */
            equal(info2: BaseInfo): boolean
            /**
             * Retrieve an arbitrary attribute associated with this node.
             * @since 2.80
             * @param name a freeform string naming an attribute
             * @returns The value of the attribute, or `NULL` if no such   attribute exists
             */
            get_attribute(name: string): string | null
            /**
             * Obtain the container of the @info.
             *
             * The container is the parent `GIBaseInfo`. For instance, the parent of a
             * [class@GIRepository.FunctionInfo] is an [class@GIRepository.ObjectInfo] or
             * [class@GIRepository.InterfaceInfo].
             * @since 2.80
             * @returns the container
             */
            get_container(): BaseInfo
            /**
             * Obtain the name of the @info.
             *
             * What the name represents depends on the type of the
             * @info. For instance for [class@GIRepository.FunctionInfo] it is the name of
             * the function.
             * @since 2.80
             * @returns the name of `info` or `NULL` if it lacks a name.
             */
            get_name(): string | null
            /**
             * Obtain the namespace of @info.
             * @since 2.80
             * @returns the namespace
             */
            get_namespace(): string
            /**
             * Obtain the typelib this @info belongs to
             * @since 2.80
             * @returns the typelib
             */
            get_typelib(): Typelib
            /**
             * Obtain whether the @info is represents a metadata which is
             * deprecated.
             * @since 2.80
             * @returns `TRUE` if deprecated
             */
            is_deprecated(): boolean
            /**
             * value))
             *     {
             *       g_print ("attribute name: %s value: %s", name, value);
             *     }
             * }
             * ```
             * @since 2.80
             * @returns `TRUE` if there are more attributes, a [type@GIRepository.AttributeIter] structure, must be   initialized; see below, Returned name, must not be freed, Returned name, must not be freed
             */
            iterate_attributes(): [boolean, AttributeIter, string, string]
            /**
             * Increases the reference count of @info.
             * @since 2.80
             * @returns the same `info`.
             */
            ref(): BaseInfo
            /**
             * Decreases the reference count of @info. When its reference count
             * drops to 0, the info is freed.
             *
             * This must not be called on stack-allocated [type@GIRepository.BaseInfo]s —
             * use [method@GIRepository.BaseInfo.clear] for that.
             * @since 2.80
             */
            unref(): void
        }

        interface BaseInfoClass {
            readonly $gtype: GObject.GType<BaseInfo>
            readonly prototype: BaseInfo
            new (props?: Partial<GObject.ConstructorProps<BaseInfo>>): BaseInfo
        }

        const BaseInfo: BaseInfoClass
        

        namespace CallableInfo {
            interface SignalSignatures extends BaseInfo.SignalSignatures {
            }

            interface ReadableProperties extends BaseInfo.ReadableProperties {
            }

            interface WritableProperties extends BaseInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends BaseInfo.ConstructOnlyProperties {
            }
        }

        /**
         * `GICallableInfo` represents an entity which is callable.
         *
         * Examples of callable are:
         *
         *  - functions ([class@GIRepository.FunctionInfo])
         *  - virtual functions ([class@GIRepository.VFuncInfo])
         *  - callbacks ([class@GIRepository.CallbackInfo]).
         *
         * A callable has a list of arguments ([class@GIRepository.ArgInfo]), a return
         * type, direction and a flag which decides if it returns `NULL`.
         * @since 2.80
         */
        interface CallableInfo extends BaseInfo {
            readonly $signals: CallableInfo.SignalSignatures
            readonly $readableProperties: CallableInfo.ReadableProperties
            readonly $writableProperties: CallableInfo.WritableProperties
            readonly $constructOnlyProperties: CallableInfo.ConstructOnlyProperties
            /**
             * Whether the callable can throw a [type@GLib.Error]
             * @since 2.80
             * @returns `TRUE` if this `GICallableInfo` can throw a [type@GLib.Error]
             */
            can_throw_gerror(): boolean
            /**
             * Obtain information about a particular argument of this callable.
             * @since 2.80
             * @param n the argument index to fetch
             * @returns the [class@GIRepository.ArgInfo]. Free it with   [method@GIRepository.BaseInfo.unref] when done.
             */
            get_arg(n: number): ArgInfo
            /**
             * Gets the callable info for the callable's asynchronous version
             * @since 2.84
             * @returns a [class@GIRepository.CallableInfo] for the   async function or `NULL` if not defined.
             */
            get_async_function(): CallableInfo | null
            /**
             * See whether the caller owns the return value of this callable.
             *
             * [type@GIRepository.Transfer] contains a list of possible transfer values.
             * @since 2.80
             * @returns the transfer mode for the return value of the callable
             */
            get_caller_owns(): Transfer
            /**
             * Gets the info for an async function's corresponding finish function
             * @since 2.84
             * @returns a [class@GIRepository.CallableInfo] for the   finish function or `NULL` if not defined.
             */
            get_finish_function(): CallableInfo | null
            /**
             * Obtains the ownership transfer for the instance argument.
             *
             * [type@GIRepository.Transfer] contains a list of possible transfer values.
             * @since 2.80
             * @returns the transfer mode of the instance argument
             */
            get_instance_ownership_transfer(): Transfer
            /**
             * Obtain the number of arguments (both ‘in’ and ‘out’) for this callable.
             * @since 2.80
             * @returns The number of arguments this callable expects.
             */
            get_n_args(): number
            /**
             * Retrieve an arbitrary attribute associated with the return value.
             * @since 2.80
             * @param name a freeform string naming an attribute
             * @returns The value of the attribute, or `NULL` if no such   attribute exists
             */
            get_return_attribute(name: string): string | null
            /**
             * Obtain the return type of a callable item as a [class@GIRepository.TypeInfo].
             *
             * If the callable doesn’t return anything, a [class@GIRepository.TypeInfo] of
             * type [enum@GIRepository.TypeTag.VOID] will be returned.
             * @since 2.80
             * @returns the [class@GIRepository.TypeInfo]. Free the struct   by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_return_type(): TypeInfo
            /**
             * Gets the callable info for the callable's synchronous version
             * @since 2.84
             * @returns a [class@GIRepository.CallableInfo] for the   sync function or `NULL` if not defined.
             */
            get_sync_function(): CallableInfo | null
            /**
             * Invoke the given `GICallableInfo` by calling the given @function pointer.
             *
             * The set of arguments passed to @function will be constructed according to the
             * introspected type of the `GICallableInfo`, using @in_args, @out_args
             * and @error.
             * @throws {GLib.Error}
             * @since 2.80
             * @param function function pointer to call
             * @param in_args array of ‘in’ arguments
             * @param out_args array of ‘out’ arguments allocated by
              the caller, to be populated with outputted values
             * @returns `TRUE` if the callable was executed successfully and didn’t throw   a [type@GLib.Error]; `FALSE` if `error` is set, return   location for the return value from the callable; `NULL` may be returned if   the callable returns that
             */
            invoke(func: never | null, in_args: Argument[], out_args: Argument[]): [boolean, Argument]
            /**
             * Gets whether a callable is ‘async’. Async callables have a
             * [type@Gio.AsyncReadyCallback] parameter and user data.
             * @since 2.84
             * @returns true if the callable is async
             */
            is_async(): boolean
            /**
             * Determines if the callable info is a method.
             *
             * For [class@GIRepository.SignalInfo]s, this is always true, and for
             * [class@GIRepository.CallbackInfo]s always false.
             * For [class@GIRepository.FunctionInfo]s this looks at the
             * `GI_FUNCTION_IS_METHOD` flag on the [class@GIRepository.FunctionInfo].
             * For [class@GIRepository.VFuncInfo]s this is true when the virtual function
             * has an instance parameter.
             *
             * Concretely, this function returns whether
             * [method@GIRepository.CallableInfo.get_n_args] matches the number of arguments
             * in the raw C method. For methods, there is one more C argument than is
             * exposed by introspection: the `self` or `this` object.
             * @since 2.80
             * @returns `TRUE` if `info` is a method, `FALSE` otherwise
             */
            is_method(): boolean
            /**
             * Iterate over all attributes associated with the return value.
             *
             * The iterator structure is typically stack allocated, and must have its
             * first member initialized to `NULL`.
             *
             * Both the @name and @value should be treated as constants
             * and must not be freed.
             *
             * See [method@GIRepository.BaseInfo.iterate_attributes] for an example of how
             * to use a similar API.
             * @since 2.80
             * @returns `TRUE` if there are more attributes, a [type@GIRepository.AttributeIter] structure, must be   initialized; see below, Returned name, must not be freed, Returned name, must not be freed
             */
            iterate_return_attributes(): [boolean, AttributeIter, string, string]
            /**
             * Obtain information about a particular argument of this callable; this
             * function is a variant of [method@GIRepository.CallableInfo.get_arg] designed
             * for stack allocation.
             *
             * The initialized @arg must not be referenced after @info is deallocated.
             *
             * Once you are done with @arg, it must be cleared using
             * [method@GIRepository.BaseInfo.clear].
             * @since 2.80
             * @param n the argument index to fetch
             * @returns , Initialize with argument number `n`
             */
            load_arg(n: number): ArgInfo
            /**
             * Obtain information about a return value of callable; this
             * function is a variant of [method@GIRepository.CallableInfo.get_return_type]
             * designed for stack allocation.
             *
             * The initialized @type must not be referenced after @info is deallocated.
             *
             * Once you are done with @type, it must be cleared using
             * [method@GIRepository.BaseInfo.clear].
             * @since 2.80
             * @returns , Initialized with return type of `info`
             */
            load_return_type(): TypeInfo
            /**
             * See if a callable could return `NULL`.
             * @since 2.80
             * @returns `TRUE` if callable could return `NULL`
             */
            may_return_null(): boolean
            /**
             * See if a callable’s return value is only useful in C.
             * @since 2.80
             * @returns `TRUE` if return value is only useful in C.
             */
            skip_return(): boolean
        }

        interface CallableInfoClass extends Omit<BaseInfoClass, "new"> {
            readonly $gtype: GObject.GType<CallableInfo>
            readonly prototype: CallableInfo
            new (props?: Partial<GObject.ConstructorProps<CallableInfo>>): CallableInfo
        }

        const CallableInfo: CallableInfoClass
        

        namespace CallbackInfo {
            interface SignalSignatures extends CallableInfo.SignalSignatures {
            }

            interface ReadableProperties extends CallableInfo.ReadableProperties {
            }

            interface WritableProperties extends CallableInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends CallableInfo.ConstructOnlyProperties {
            }
        }

        /**
         * `GICallbackInfo` represents a callback.
         * @since 2.80
         */
        interface CallbackInfo extends CallableInfo {
            readonly $signals: CallbackInfo.SignalSignatures
            readonly $readableProperties: CallbackInfo.ReadableProperties
            readonly $writableProperties: CallbackInfo.WritableProperties
            readonly $constructOnlyProperties: CallbackInfo.ConstructOnlyProperties
        }

        interface CallbackInfoClass extends Omit<CallableInfoClass, "new"> {
            readonly $gtype: GObject.GType<CallbackInfo>
            readonly prototype: CallbackInfo
            new (props?: Partial<GObject.ConstructorProps<CallbackInfo>>): CallbackInfo
        }

        const CallbackInfo: CallbackInfoClass
        

        namespace ConstantInfo {
            interface SignalSignatures extends BaseInfo.SignalSignatures {
            }

            interface ReadableProperties extends BaseInfo.ReadableProperties {
            }

            interface WritableProperties extends BaseInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends BaseInfo.ConstructOnlyProperties {
            }
        }

        /**
         * `GIConstantInfo` represents a constant.
         *
         * A constant has a type associated – which can be obtained by calling
         * [method@GIRepository.ConstantInfo.get_type_info] – and a value – which can be
         * obtained by calling [method@GIRepository.ConstantInfo.get_value].
         * @since 2.80
         */
        interface ConstantInfo extends BaseInfo {
            readonly $signals: ConstantInfo.SignalSignatures
            readonly $readableProperties: ConstantInfo.ReadableProperties
            readonly $writableProperties: ConstantInfo.WritableProperties
            readonly $constructOnlyProperties: ConstantInfo.ConstructOnlyProperties
            /**
             * Obtain the type of the constant as a [class@GIRepository.TypeInfo].
             * @since 2.80
             * @returns The [class@GIRepository.TypeInfo]. Free the struct   by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_type_info(): TypeInfo
        }

        interface ConstantInfoClass extends Omit<BaseInfoClass, "new"> {
            readonly $gtype: GObject.GType<ConstantInfo>
            readonly prototype: ConstantInfo
            new (props?: Partial<GObject.ConstructorProps<ConstantInfo>>): ConstantInfo
        }

        const ConstantInfo: ConstantInfoClass
        

        namespace EnumInfo {
            interface SignalSignatures extends RegisteredTypeInfo.SignalSignatures {
            }

            interface ReadableProperties extends RegisteredTypeInfo.ReadableProperties {
            }

            interface WritableProperties extends RegisteredTypeInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends RegisteredTypeInfo.ConstructOnlyProperties {
            }
        }

        /**
         * A `GIEnumInfo` represents an enumeration.
         *
         * The `GIEnumInfo` contains a set of values (each a
         * [class@GIRepository.ValueInfo]) and a type.
         *
         * The [class@GIRepository.ValueInfo] for a value is fetched by calling
         * [method@GIRepository.EnumInfo.get_value] on a `GIEnumInfo`.
         * @since 2.80
         */
        interface EnumInfo extends RegisteredTypeInfo {
            readonly $signals: EnumInfo.SignalSignatures
            readonly $readableProperties: EnumInfo.ReadableProperties
            readonly $writableProperties: EnumInfo.WritableProperties
            readonly $constructOnlyProperties: EnumInfo.ConstructOnlyProperties
            /**
             * Obtain the string form of the quark for the error domain associated with
             * this enum, if any.
             * @since 2.80
             * @returns the string form of the error domain   associated with this enum, or `NULL`.
             */
            get_error_domain(): string | null
            /**
             * Obtain an enum type method at index @n.
             * @since 2.80
             * @param n index of method to get
             * @returns the [class@GIRepository.FunctionInfo]. Free the   struct by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_method(n: number): FunctionInfo
            /**
             * Obtain the number of methods that this enum type has.
             * @since 2.80
             * @returns number of methods
             */
            get_n_methods(): number
            /**
             * Obtain the number of values this enumeration contains.
             * @since 2.80
             * @returns the number of enumeration values
             */
            get_n_values(): number
            /**
             * Obtain the tag of the type used for the enum in the C ABI. This will
             * will be a signed or unsigned integral type.
             *
             * Note that in the current implementation the width of the type is
             * computed correctly, but the signed or unsigned nature of the type
             * may not match the sign of the type used by the C compiler.
             * @since 2.80
             * @returns the storage type for the enumeration
             */
            get_storage_type(): TypeTag
            /**
             * Obtain a value for this enumeration.
             * @since 2.80
             * @param n index of value to fetch
             * @returns the enumeration value, free the struct with   [method@GIRepository.BaseInfo.unref] when done.
             */
            get_value(n: number): ValueInfo
        }

        interface EnumInfoClass extends Omit<RegisteredTypeInfoClass, "new"> {
            readonly $gtype: GObject.GType<EnumInfo>
            readonly prototype: EnumInfo
            new (props?: Partial<GObject.ConstructorProps<EnumInfo>>): EnumInfo
        }

        const EnumInfo: EnumInfoClass
        

        namespace FieldInfo {
            interface SignalSignatures extends BaseInfo.SignalSignatures {
            }

            interface ReadableProperties extends BaseInfo.ReadableProperties {
            }

            interface WritableProperties extends BaseInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends BaseInfo.ConstructOnlyProperties {
            }
        }

        /**
         * A `GIFieldInfo` struct represents a field of a struct, union, or object.
         *
         * The `GIFieldInfo` is fetched by calling
         * [method@GIRepository.StructInfo.get_field],
         * [method@GIRepository.UnionInfo.get_field] or
         * [method@GIRepository.ObjectInfo.get_field].
         *
         * A field has a size, type and a struct offset associated and a set of flags,
         * which are currently `GI_FIELD_IS_READABLE` or `GI_FIELD_IS_WRITABLE`.
         *
         * See also: [type@GIRepository.StructInfo], [type@GIRepository.UnionInfo],
         * [type@GIRepository.ObjectInfo]
         * @since 2.80
         */
        interface FieldInfo extends BaseInfo {
            readonly $signals: FieldInfo.SignalSignatures
            readonly $readableProperties: FieldInfo.ReadableProperties
            readonly $writableProperties: FieldInfo.WritableProperties
            readonly $constructOnlyProperties: FieldInfo.ConstructOnlyProperties
            /**
             * Obtain the flags for this `GIFieldInfo`. See
             * [flags@GIRepository.FieldInfoFlags] for possible flag values.
             * @since 2.80
             * @returns the flags
             */
            get_flags(): FieldInfoFlags
            /**
             * Obtain the offset of the field member, in bytes. This is relative
             * to the beginning of the struct or union.
             * @since 2.80
             * @returns the field offset, in bytes
             */
            get_offset(): number
            /**
             * Obtain the size of the field member, in bits. This is how
             * much space you need to allocate to store the field.
             * @since 2.80
             * @returns the field size, in bits
             */
            get_size(): number
            /**
             * Obtain the type of a field as a [type@GIRepository.TypeInfo].
             * @since 2.80
             * @returns the [type@GIRepository.TypeInfo]. Free the struct   by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_type_info(): TypeInfo
        }

        interface FieldInfoClass extends Omit<BaseInfoClass, "new"> {
            readonly $gtype: GObject.GType<FieldInfo>
            readonly prototype: FieldInfo
            new (props?: Partial<GObject.ConstructorProps<FieldInfo>>): FieldInfo
        }

        const FieldInfo: FieldInfoClass
        

        namespace FlagsInfo {
            interface SignalSignatures extends EnumInfo.SignalSignatures {
            }

            interface ReadableProperties extends EnumInfo.ReadableProperties {
            }

            interface WritableProperties extends EnumInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends EnumInfo.ConstructOnlyProperties {
            }
        }

        /**
         * A `GIFlagsInfo` represents an enumeration which defines flag values
         * (independently set bits).
         *
         * The `GIFlagsInfo` contains a set of values (each a
         * [class@GIRepository.ValueInfo]) and a type.
         *
         * The [class@GIRepository.ValueInfo] for a value is fetched by calling
         * [method@GIRepository.EnumInfo.get_value] on a `GIFlagsInfo`.
         * @since 2.80
         */
        interface FlagsInfo extends EnumInfo {
            readonly $signals: FlagsInfo.SignalSignatures
            readonly $readableProperties: FlagsInfo.ReadableProperties
            readonly $writableProperties: FlagsInfo.WritableProperties
            readonly $constructOnlyProperties: FlagsInfo.ConstructOnlyProperties
        }

        interface FlagsInfoClass extends Omit<EnumInfoClass, "new"> {
            readonly $gtype: GObject.GType<FlagsInfo>
            readonly prototype: FlagsInfo
            new (props?: Partial<GObject.ConstructorProps<FlagsInfo>>): FlagsInfo
        }

        const FlagsInfo: FlagsInfoClass
        

        namespace FunctionInfo {
            interface SignalSignatures extends CallableInfo.SignalSignatures {
            }

            interface ReadableProperties extends CallableInfo.ReadableProperties {
            }

            interface WritableProperties extends CallableInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends CallableInfo.ConstructOnlyProperties {
            }
        }

        /**
         * `GIFunctionInfo` represents a function, method or constructor.
         *
         * To find out what kind of entity a `GIFunctionInfo` represents, call
         * [method@GIRepository.FunctionInfo.get_flags].
         *
         * See also [class@GIRepository.CallableInfo] for information on how to retrieve
         * arguments and other metadata.
         * @since 2.80
         */
        interface FunctionInfo extends CallableInfo {
            readonly $signals: FunctionInfo.SignalSignatures
            readonly $readableProperties: FunctionInfo.ReadableProperties
            readonly $writableProperties: FunctionInfo.WritableProperties
            readonly $constructOnlyProperties: FunctionInfo.ConstructOnlyProperties
            /**
             * Obtain the [type@GIRepository.FunctionInfoFlags] for the @info.
             * @since 2.80
             * @returns the flags
             */
            get_flags(): FunctionInfoFlags
            /**
             * Obtain the property associated with this `GIFunctionInfo`.
             *
             * Only `GIFunctionInfo`s with the flag `GI_FUNCTION_IS_GETTER` or
             * `GI_FUNCTION_IS_SETTER` have a property set. For other cases,
             * `NULL` will be returned.
             * @since 2.80
             * @returns The property or `NULL` if not set. Free   it with [method@GIRepository.BaseInfo.unref] when done.
             */
            get_property(): PropertyInfo | null
            /**
             * Obtain the symbol of the function.
             *
             * The symbol is the name of the exported function, suitable to be used as an
             * argument to [method@GModule.Module.symbol].
             * @since 2.80
             * @returns the symbol
             */
            get_symbol(): string
            /**
             * Obtain the virtual function associated with this `GIFunctionInfo`.
             *
             * Only `GIFunctionInfo`s with the flag `GI_FUNCTION_WRAPS_VFUNC` have
             * a virtual function set. For other cases, `NULL` will be returned.
             * @since 2.80
             * @returns The virtual function or `NULL` if not   set. Free it by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_vfunc(): VFuncInfo | null
        }

        interface FunctionInfoClass extends Omit<CallableInfoClass, "new"> {
            readonly $gtype: GObject.GType<FunctionInfo>
            readonly prototype: FunctionInfo
            new (props?: Partial<GObject.ConstructorProps<FunctionInfo>>): FunctionInfo
        }

        const FunctionInfo: FunctionInfoClass
        

        namespace InterfaceInfo {
            interface SignalSignatures extends RegisteredTypeInfo.SignalSignatures {
            }

            interface ReadableProperties extends RegisteredTypeInfo.ReadableProperties {
            }

            interface WritableProperties extends RegisteredTypeInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends RegisteredTypeInfo.ConstructOnlyProperties {
            }
        }

        /**
         * `GIInterfaceInfo` represents a `GInterface` type.
         *
         * A `GInterface` has methods, fields, properties, signals,
         * interfaces, constants, virtual functions and prerequisites.
         * @since 2.80
         */
        interface InterfaceInfo extends RegisteredTypeInfo {
            readonly $signals: InterfaceInfo.SignalSignatures
            readonly $readableProperties: InterfaceInfo.ReadableProperties
            readonly $writableProperties: InterfaceInfo.WritableProperties
            readonly $constructOnlyProperties: InterfaceInfo.ConstructOnlyProperties
            /**
             * Obtain a method of the interface type given a @name.
             *
             * `NULL` will be returned if there’s no method available with that name.
             * @since 2.80
             * @param name name of method to obtain
             * @returns The [class@GIRepository.FunctionInfo] or   `NULL` if none found. Free the struct by calling   [method@GIRepository.BaseInfo.unref] when done.
             */
            find_method(name: string): FunctionInfo | null
            /**
             * Obtain a signal of the interface type given a @name.
             *
             * `NULL` will be returned if there’s no signal available with that name.
             * @since 2.80
             * @param name name of signal to find
             * @returns The [class@GIRepository.SignalInfo] or   `NULL` if none found. Free the struct by calling   [method@GIRepository.BaseInfo.unref] when done.
             */
            find_signal(name: string): SignalInfo | null
            /**
             * Locate a virtual function slot with name @name.
             *
             * See the documentation for [method@GIRepository.ObjectInfo.find_vfunc] for
             * more information on virtuals.
             * @since 2.80
             * @param name The name of a virtual function to find.
             * @returns The [class@GIRepository.VFuncInfo], or   `NULL` if none found. Free it with [method@GIRepository.BaseInfo.unref]   when done.
             */
            find_vfunc(name: string): VFuncInfo | null
            /**
             * Obtain an interface type constant at index @n.
             * @since 2.80
             * @param n index of constant to get
             * @returns The [class@GIRepository.ConstantInfo]. Free the   struct by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_constant(n: number): ConstantInfo
            /**
             * Returns the layout C structure associated with this `GInterface`.
             * @since 2.80
             * @returns The [class@GIRepository.StructInfo] or   `NULL` if unknown. Free it with [method@GIRepository.BaseInfo.unref] when   done.
             */
            get_iface_struct(): StructInfo | null
            /**
             * Obtain an interface type method at index @n.
             * @since 2.80
             * @param n index of method to get
             * @returns The [class@GIRepository.FunctionInfo]. Free the   struct by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_method(n: number): FunctionInfo
            /**
             * Obtain the number of constants that this interface type has.
             * @since 2.80
             * @returns number of constants
             */
            get_n_constants(): number
            /**
             * Obtain the number of methods that this interface type has.
             * @since 2.80
             * @returns number of methods
             */
            get_n_methods(): number
            /**
             * Obtain the number of prerequisites for this interface type.
             *
             * A prerequisite is another interface that needs to be implemented for
             * interface, similar to a base class for [class@GObject.Object]s.
             * @since 2.80
             * @returns number of prerequisites
             */
            get_n_prerequisites(): number
            /**
             * Obtain the number of properties that this interface type has.
             * @since 2.80
             * @returns number of properties
             */
            get_n_properties(): number
            /**
             * Obtain the number of signals that this interface type has.
             * @since 2.80
             * @returns number of signals
             */
            get_n_signals(): number
            /**
             * Obtain the number of virtual functions that this interface type has.
             * @since 2.80
             * @returns number of virtual functions
             */
            get_n_vfuncs(): number
            /**
             * Obtain an interface type’s prerequisite at index @n.
             * @since 2.80
             * @param n index of prerequisite to get
             * @returns The prerequisite as a [class@GIRepository.BaseInfo].   Free the struct by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_prerequisite(n: number): BaseInfo
            /**
             * Obtain an interface type property at index @n.
             * @since 2.80
             * @param n index of property to get
             * @returns The [class@GIRepository.PropertyInfo]. Free the   struct by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_property(n: number): PropertyInfo
            /**
             * Obtain an interface type signal at index @n.
             * @since 2.80
             * @param n index of signal to get
             * @returns The [class@GIRepository.SignalInfo]. Free the   struct by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_signal(n: number): SignalInfo
            /**
             * Obtain an interface type virtual function at index @n.
             * @since 2.80
             * @param n index of virtual function to get
             * @returns the [class@GIRepository.VFuncInfo]. Free the struct   by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_vfunc(n: number): VFuncInfo
        }

        interface InterfaceInfoClass extends Omit<RegisteredTypeInfoClass, "new"> {
            readonly $gtype: GObject.GType<InterfaceInfo>
            readonly prototype: InterfaceInfo
            new (props?: Partial<GObject.ConstructorProps<InterfaceInfo>>): InterfaceInfo
        }

        const InterfaceInfo: InterfaceInfoClass
        

        namespace ObjectInfo {
            interface SignalSignatures extends RegisteredTypeInfo.SignalSignatures {
            }

            interface ReadableProperties extends RegisteredTypeInfo.ReadableProperties {
            }

            interface WritableProperties extends RegisteredTypeInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends RegisteredTypeInfo.ConstructOnlyProperties {
            }
        }

        /**
         * `GIObjectInfo` represents a classed type.
         *
         * Classed types in [type@GObject.Type] inherit from
         * [type@GObject.TypeInstance]; the most common type is [class@GObject.Object].
         *
         * A `GIObjectInfo` doesn’t represent a specific instance of a classed type,
         * instead this represent the object type (i.e. the class).
         *
         * A `GIObjectInfo` has methods, fields, properties, signals, interfaces,
         * constants and virtual functions.
         * @since 2.80
         */
        interface ObjectInfo extends RegisteredTypeInfo {
            readonly $signals: ObjectInfo.SignalSignatures
            readonly $readableProperties: ObjectInfo.ReadableProperties
            readonly $writableProperties: ObjectInfo.WritableProperties
            readonly $constructOnlyProperties: ObjectInfo.ConstructOnlyProperties
            /**
             * Obtain a method of the object type given a @name.
             *
             * `NULL` will be returned if there’s no method available with that name.
             * @since 2.80
             * @param name name of method to obtain
             * @returns The [class@GIRepository.FunctionInfo],   or `NULL` if no method could be found. Free the struct by calling   [method@GIRepository.BaseInfo.unref] when done.
             */
            find_method(name: string): FunctionInfo | null
            /**
             * Obtain a method of the object given a @name, searching both the
             * object @info and any interfaces it implements.
             *
             * `NULL` will be returned if there’s no method available with that name.
             *
             * Note that this function does *not* search parent classes; you will have
             * to chain up if that’s desired.
             * @since 2.80
             * @param name name of method to obtain
             * @returns The [class@GIRepository.FunctionInfo],   or `NULL` if none was found. Free the struct by calling   [method@GIRepository.BaseInfo.unref] when done., The   [class@GIRepository.ObjectInfo] or [class@GIRepository.InterfaceInfo] which   declares the method, or `NULL` to ignore. If no method is found, this will   return `NULL`.
             */
            find_method_using_interfaces(name: string): FunctionInfo | null
            /**
             * Obtain a signal of the object type given a @name.
             *
             * `NULL` will be returned if there’s no signal available with that name.
             * @since 2.80
             * @param name name of signal
             * @returns The [class@GIRepository.SignalInfo],   or `NULL` if no signal could be found. Free the struct by calling   [method@GIRepository.BaseInfo.unref] when done.
             */
            find_signal(name: string): SignalInfo | null
            /**
             * Locate a virtual function slot with name @name.
             *
             * Note that the namespace for virtuals is distinct from that of methods; there
             * may or may not be a concrete method associated for a virtual. If there is
             * one, it may be retrieved using [method@GIRepository.VFuncInfo.get_invoker],
             * otherwise that method will return `NULL`.
             *
             * See the documentation for [method@GIRepository.VFuncInfo.get_invoker] for
             * more information on invoking virtuals.
             * @since 2.80
             * @param name the name of a virtual function to find.
             * @returns The [class@GIRepository.VFuncInfo], or   `NULL` if none is found. Free it with [method@GIRepository.BaseInfo.unref]   when done.
             */
            find_vfunc(name: string): VFuncInfo | null
            /**
             * Locate a virtual function slot with name @name, searching both the object
             * @info and any interfaces it implements.
             *
             * `NULL` will be returned if there’s no vfunc available with that name.
             *
             * Note that the namespace for virtuals is distinct from that of methods; there
             * may or may not be a concrete method associated for a virtual. If there is
             * one, it may be retrieved using [method@GIRepository.VFuncInfo.get_invoker],
             * otherwise that method will return `NULL`.
             *
             * Note that this function does *not* search parent classes; you will have
             * to chain up if that’s desired.
             * @since 2.80
             * @param name name of vfunc to obtain
             * @returns The [class@GIRepository.VFuncInfo],   or `NULL` if none was found. Free the struct by calling   [method@GIRepository.BaseInfo.unref] when done., The   [class@GIRepository.ObjectInfo] or [class@GIRepository.InterfaceInfo] which   declares the vfunc, or `NULL` to ignore. If no vfunc is found, this will   return `NULL`.
             */
            find_vfunc_using_interfaces(name: string): VFuncInfo | null
            /**
             * Obtain if the object type is an abstract type, i.e. if it cannot be
             * instantiated.
             * @since 2.80
             * @returns `TRUE` if the object type is abstract
             */
            get_abstract(): boolean
            /**
             * Every [class@GObject.Object] has two structures; an instance structure and a
             * class structure.  This function returns the metadata for the class structure.
             * @since 2.80
             * @returns The [class@GIRepository.StructInfo] or   `NULL` if it’s unknown. Free with [method@GIRepository.BaseInfo.unref] when   done.
             */
            get_class_struct(): StructInfo | null
            /**
             * Obtain an object type constant at index @n.
             * @since 2.80
             * @param n index of constant to get
             * @returns The [class@GIRepository.ConstantInfo]. Free the   struct by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_constant(n: number): ConstantInfo
            /**
             * Obtain an object type field at index @n.
             * @since 2.80
             * @param n index of field to get
             * @returns The [class@GIRepository.FieldInfo]. Free the struct   by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_field(n: number): FieldInfo
            /**
             * Checks whether the object type is a final type, i.e. if it cannot
             * be derived.
             * @since 2.80
             * @returns `TRUE` if the object type is final
             */
            get_final(): boolean
            /**
             * Obtain if the object type is of a fundamental type which is not
             * `G_TYPE_OBJECT`.
             *
             * This is mostly for supporting `GstMiniObject`.
             * @since 2.80
             * @returns `TRUE` if the object type is a fundamental type
             */
            get_fundamental(): boolean
            /**
             * Obtain the symbol name of the function that should be called to convert
             * an object instance pointer of this object type to a [type@GObject.Value].
             *
             * It’s mainly used for fundamental types. The type signature for the symbol
             * is [type@GIRepository.ObjectInfoGetValueFunction]. To fetch the function
             * pointer see [method@GIRepository.ObjectInfo.get_get_value_function_pointer].
             * @since 2.80
             * @returns the symbol, or `NULL` if the object type has no   get-value function
             */
            get_get_value_function_name(): string | null
            /**
             * Obtain an object type interface at index @n.
             * @since 2.80
             * @param n index of interface to get
             * @returns The [class@GIRepository.InterfaceInfo]. Free the   struct by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_interface(n: number): InterfaceInfo
            /**
             * Obtain an object type method at index @n.
             * @since 2.80
             * @param n index of method to get
             * @returns The [class@GIRepository.FunctionInfo]. Free the   struct by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_method(n: number): FunctionInfo
            /**
             * Obtain the number of constants that this object type has.
             * @since 2.80
             * @returns number of constants
             */
            get_n_constants(): number
            /**
             * Obtain the number of fields that this object type has.
             * @since 2.80
             * @returns number of fields
             */
            get_n_fields(): number
            /**
             * Obtain the number of interfaces that this object type has.
             * @since 2.80
             * @returns number of interfaces
             */
            get_n_interfaces(): number
            /**
             * Obtain the number of methods that this object type has.
             * @since 2.80
             * @returns number of methods
             */
            get_n_methods(): number
            /**
             * Obtain the number of properties that this object type has.
             * @since 2.80
             * @returns number of properties
             */
            get_n_properties(): number
            /**
             * Obtain the number of signals that this object type has.
             * @since 2.80
             * @returns number of signals
             */
            get_n_signals(): number
            /**
             * Obtain the number of virtual functions that this object type has.
             * @since 2.80
             * @returns number of virtual functions
             */
            get_n_vfuncs(): number
            /**
             * Obtain the parent of the object type.
             * @since 2.80
             * @returns The `GIObjectInfo`. Free the struct by   calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_parent(): ObjectInfo | null
            /**
             * Obtain an object type property at index @n.
             * @since 2.80
             * @param n index of property to get
             * @returns The [class@GIRepository.PropertyInfo]. Free the   struct by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_property(n: number): PropertyInfo
            /**
             * Obtain the symbol name of the function that should be called to ref this
             * object type.
             *
             * It’s mainly used for fundamental types. The type signature for
             * the symbol is [type@GIRepository.ObjectInfoRefFunction]. To fetch the
             * function pointer see
             * [method@GIRepository.ObjectInfo.get_ref_function_pointer].
             * @since 2.80
             * @returns the symbol, or `NULL` if the object type has no ref   function
             */
            get_ref_function_name(): string | null
            /**
             * Obtain the symbol name of the function that should be called to set a
             * [type@GObject.Value], given an object instance pointer of this object type.
             *
             * It’s mainly used for fundamental types. The type signature for the symbol
             * is [type@GIRepository.ObjectInfoSetValueFunction]. To fetch the function
             * pointer see [method@GIRepository.ObjectInfo.get_set_value_function_pointer].
             * @since 2.80
             * @returns the symbol, or `NULL` if the object type has no   set-value function
             */
            get_set_value_function_name(): string | null
            /**
             * Obtain an object type signal at index @n.
             * @since 2.80
             * @param n index of signal to get
             * @returns The [class@GIRepository.SignalInfo]. Free the   struct by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_signal(n: number): SignalInfo
            /**
             * Obtain the name of the function which, when called, will return the
             * [type@GObject.Type] for this object type.
             * @since 2.80
             * @returns the type init function name
             */
            get_type_init_function_name(): string
            /**
             * Obtain the name of the object’s class/type.
             * @since 2.80
             * @returns name of the object’s type
             */
            get_type_name(): string
            /**
             * Obtain the symbol name of the function that should be called to unref this
             * object type.
             *
             * It’s mainly used for fundamental types. The type signature for the symbol is
             * [type@GIRepository.ObjectInfoUnrefFunction]. To fetch the function pointer
             * see [method@GIRepository.ObjectInfo.get_unref_function_pointer].
             * @since 2.80
             * @returns the symbol, or `NULL` if the object type has no unref   function
             */
            get_unref_function_name(): string | null
            /**
             * Obtain an object type virtual function at index @n.
             * @since 2.80
             * @param n index of virtual function to get
             * @returns The [class@GIRepository.VFuncInfo]. Free the struct   by calling [method@GIRepository.BaseInfo.unref] when done.
             */
            get_vfunc(n: number): VFuncInfo
        }

        interface ObjectInfoClass extends Omit<RegisteredTypeInfoClass, "new"> {
            readonly $gtype: GObject.GType<ObjectInfo>
            readonly prototype: ObjectInfo
            new (props?: Partial<GObject.ConstructorProps<ObjectInfo>>): ObjectInfo
        }

        const ObjectInfo: ObjectInfoClass
        

        namespace PropertyInfo {
            interface SignalSignatures extends BaseInfo.SignalSignatures {
            }

            interface ReadableProperties extends BaseInfo.ReadableProperties {
            }

            interface WritableProperties extends BaseInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends BaseInfo.ConstructOnlyProperties {
            }
        }

        /**
         * `GIPropertyInfo` represents a property in a [class@GObject.Object].
         *
         * A property belongs to either a [class@GIRepository.ObjectInfo] or a
         * [class@GIRepository.InterfaceInfo].
         * @since 2.80
         */
        interface PropertyInfo extends BaseInfo {
            readonly $signals: PropertyInfo.SignalSignatures
            readonly $readableProperties: PropertyInfo.ReadableProperties
            readonly $writableProperties: PropertyInfo.WritableProperties
            readonly $constructOnlyProperties: PropertyInfo.ConstructOnlyProperties
            /**
             * Obtain the flags for this property info.
             *
             * See [type@GObject.ParamFlags] for more information about possible flag
             * values.
             * @since 2.80
             * @returns the flags
             */
            get_flags(): GObject.ParamFlags
            /**
             * Obtains the getter function associated with this `GIPropertyInfo`.
             *
             * The setter is only available for `G_PARAM_READABLE` properties.
             * @since 2.80
             * @returns The function info, or `NULL` if not set.   Free it with [method@GIRepository.BaseInfo.unref] when done.
             */
            get_getter(): FunctionInfo | null
            /**
             * Obtain the ownership transfer for this property.
             *
             * See [type@GIRepository.Transfer] for more information about transfer values.
             * @since 2.80
             * @returns the transfer
             */
            get_ownership_transfer(): Transfer
            /**
             * Obtains the setter function associated with this `GIPropertyInfo`.
             *
             * The setter is only available for `G_PARAM_WRITABLE` properties that
             * are also not `G_PARAM_CONSTRUCT_ONLY`.
             * @since 2.80
             * @returns The function info, or `NULL` if not set.   Free it with [method@GIRepository.BaseInfo.unref] when done.
             */
            get_setter(): FunctionInfo | null
            /**
             * Obtain the type information for the property @info.
             * @since 2.80
             * @returns The [class@GIRepository.TypeInfo]. Free it with   [method@GIRepository.BaseInfo.unref] when done.
             */
            get_type_info(): TypeInfo
        }

        interface PropertyInfoClass extends Omit<BaseInfoClass, "new"> {
            readonly $gtype: GObject.GType<PropertyInfo>
            readonly prototype: PropertyInfo
            new (props?: Partial<GObject.ConstructorProps<PropertyInfo>>): PropertyInfo
        }

        const PropertyInfo: PropertyInfoClass
        

        namespace RegisteredTypeInfo {
            interface SignalSignatures extends BaseInfo.SignalSignatures {
            }

            interface ReadableProperties extends BaseInfo.ReadableProperties {
            }

            interface WritableProperties extends BaseInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends BaseInfo.ConstructOnlyProperties {
            }
        }

        /**
         * `GIRegisteredTypeInfo` represents an entity with a [type@GObject.Type]
         * associated.
         *
         * Could be either a [class@GIRepository.EnumInfo],
         * [class@GIRepository.InterfaceInfo], [class@GIRepository.ObjectInfo],
         * [class@GIRepository.StructInfo] or a [class@GIRepository.UnionInfo].
         *
         * A registered type info struct has a name and a type function.
         *
         * To get the name call [method@GIRepository.RegisteredTypeInfo.get_type_name].
         * Most users want to call [method@GIRepository.RegisteredTypeInfo.get_g_type]
         * and don’t worry about the rest of the details.
         *
         * If the registered type is a subtype of `G_TYPE_BOXED`,
         * [method@GIRepository.RegisteredTypeInfo.is_boxed] will return true, and
         * [method@GIRepository.RegisteredTypeInfo.get_type_name] is guaranteed to
         * return a non-`NULL` value. This is relevant for the
         * [class@GIRepository.StructInfo] and [class@GIRepository.UnionInfo]
         * subclasses.
         * @since 2.80
         */
        interface RegisteredTypeInfo extends BaseInfo {
            readonly $signals: RegisteredTypeInfo.SignalSignatures
            readonly $readableProperties: RegisteredTypeInfo.ReadableProperties
            readonly $writableProperties: RegisteredTypeInfo.WritableProperties
            readonly $constructOnlyProperties: RegisteredTypeInfo.ConstructOnlyProperties
            /**
             * Obtain the [type@GObject.Type] for this registered type.
             *
             * If there is no type information associated with @info, or the shared library
             * which provides the `type_init` function for @info cannot be called, then
             * `G_TYPE_NONE` is returned.
             * @since 2.80
             * @returns the [type@GObject.Type], or `G_TYPE_NONE` if unknown
             */
            get_g_type(): GObject.GType
            /**
             * Obtain the type init function for @info.
             *
             * The type init function is the function which will register the
             * [type@GObject.Type] within the GObject type system. Usually this is not
             * called by language bindings or applications — use
             * [method@GIRepository.RegisteredTypeInfo.get_g_type] directly instead.
             * @since 2.80
             * @returns the symbol name of the type init function, suitable for   passing into [method@GModule.Module.symbol], or `NULL` if unknown
             */
            get_type_init_function_name(): string | null
            /**
             * Obtain the type name of the struct within the GObject type system.
             *
             * This type can be passed to [func@GObject.type_name] to get a
             * [type@GObject.Type].
             * @since 2.80
             * @returns the type name, or `NULL` if unknown
             */
            get_type_name(): string | null
            /**
             * Get whether the registered type is a boxed type.
             *
             * A boxed type is a subtype of the fundamental `G_TYPE_BOXED` type.
             * It’s a type which has registered a [type@GObject.Type], and which has
             * associated copy and free functions.
             *
             * Most boxed types are `struct`s; some are `union`s; and it’s possible for a
             * boxed type to be neither, but that is currently unsupported by
             * libgirepository. It’s also possible for a `struct` or `union` to have
             * associated copy and/or free functions *without* being a boxed type, by virtue
             * of not having registered a [type@GObject.Type].
             *
             * This function will return false for [type@GObject.Type]s which are not boxed,
             * such as classes or interfaces. It will also return false for the `struct`s
             * associated with a class or interface, which return true from
             * [method@GIRepository.StructInfo.is_gtype_struct].
             * @since 2.80
             * @returns true if `info` is a boxed type
             */
            is_boxed(): boolean
        }

        interface RegisteredTypeInfoClass extends Omit<BaseInfoClass, "new"> {
            readonly $gtype: GObject.GType<RegisteredTypeInfo>
            readonly prototype: RegisteredTypeInfo
            new (props?: Partial<GObject.ConstructorProps<RegisteredTypeInfo>>): RegisteredTypeInfo
        }

        const RegisteredTypeInfo: RegisteredTypeInfoClass
        

        namespace Repository {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * `GIRepository` is used to manage repositories of namespaces. Namespaces
         * are represented on disk by type libraries (`.typelib` files).
         *
         * The individual pieces of API within a type library are represented by
         * subclasses of [class@GIRepository.BaseInfo]. These can be found using
         * methods like [method@GIRepository.Repository.find_by_name] or
         * [method@GIRepository.Repository.get_info].
         *
         * You are responsible for ensuring that the lifetime of the
         * [class@GIRepository.Repository] exceeds that of the lifetime of any of its
         * [class@GIRepository.BaseInfo]s. This cannot be guaranteed by using internal
         * references within libgirepository as that would affect performance.
         *
         * ### Discovery of type libraries
         *
         * `GIRepository` will typically look for a `girepository-1.0` directory
         * under the library directory used when compiling gobject-introspection. On a
         * standard Linux system this will end up being `/usr/lib/girepository-1.0`.
         *
         * It is possible to control the search paths programmatically, using
         * [method@GIRepository.Repository.prepend_search_path]. It is also possible to
         * modify the search paths by using the `GI_TYPELIB_PATH` environment variable.
         * The environment variable takes precedence over the default search path
         * and the [method@GIRepository.Repository.prepend_search_path] calls.
         *
         * ### Namespace ordering
         *
         * In situations where namespaces may be searched in order, or returned in a
         * list, the namespaces will be returned in alphabetical order, with all fully
         * loaded namespaces being returned before any lazily loaded ones (those loaded
         * with `GI_REPOSITORY_LOAD_FLAG_LAZY`). This allows for deterministic and
         * reproducible results.
         *
         * Similarly, if a symbol (such as a `GType` or error domain) is being searched
         * for in the set of loaded namespaces, the namespaces will be searched in that
         * order. In particular, this means that a symbol which exists in two namespaces
         * will always be returned from the alphabetically-higher namespace. This should
         * only happen in the case of `Gio` and `GioUnix`/`GioWin32`, which all refer to
         * the same `.so` file and expose overlapping sets of symbols. Symbols should
         * always end up being resolved to `GioUnix` or `GioWin32` if they are platform
         * dependent, rather than `Gio` itself.
         * @since 2.80
         */
        interface Repository extends GObject.Object {
            readonly $signals: Repository.SignalSignatures
            readonly $readableProperties: Repository.ReadableProperties
            readonly $writableProperties: Repository.WritableProperties
            readonly $constructOnlyProperties: Repository.ConstructOnlyProperties
            /**
             * Obtain an unordered list of versions (either currently loaded or
             * available) for @namespace_ in this @repository.
             *
             * The list is guaranteed to be `NULL` terminated. The `NULL` terminator is not
             * counted in @n_versions_out.
             * @since 2.80
             * @param namespace_ GI namespace, e.g. `Gtk`
             * @returns the array of versions.
             */
            enumerate_versions(namespace_: string): string[]
            /**
             * Searches for the enum type corresponding to the given [type@GLib.Error]
             * domain.
             *
             * Before calling this function for a particular namespace, you must call
             * [method@GIRepository.Repository.require] to load the namespace, or otherwise
             * ensure the namespace has already been loaded.
             * @since 2.80
             * @param domain a [type@GLib.Error] domain
             * @returns [class@GIRepository.EnumInfo]   representing metadata about `domain`’s enum type, or `NULL` if none found
             */
            find_by_error_domain(domain: GLib.Quark): EnumInfo | null
            /**
             * Searches all loaded namespaces for a particular [type@GObject.Type].
             *
             * Note that in order to locate the metadata, the namespace corresponding to
             * the type must first have been loaded.  There is currently no
             * mechanism for determining the namespace which corresponds to an
             * arbitrary [type@GObject.Type] — thus, this function will operate most
             * reliably when you know the [type@GObject.Type] is from a loaded namespace.
             * @since 2.80
             * @param gtype [type@GObject.Type] to search for
             * @returns [class@GIRepository.BaseInfo]   representing metadata about `type`, or `NULL` if none found
             */
            find_by_gtype(gtype: (GObject.GType | { $gtype: GObject.GType })): BaseInfo | null
            /**
             * Searches for a particular entry in a namespace.
             *
             * Before calling this function for a particular namespace, you must call
             * [method@GIRepository.Repository.require] to load the namespace, or otherwise
             * ensure the namespace has already been loaded.
             * @since 2.80
             * @param namespace_ Namespace which will be searched
             * @param name Entry name to find
             * @returns [class@GIRepository.BaseInfo]   representing metadata about `name`, or `NULL` if none found
             */
            find_by_name(namespace_: string, name: string): BaseInfo | null
            /**
             * This function returns the ‘C prefix’, or the C level namespace
             * associated with the given introspection namespace.
             *
             * Each C symbol starts with this prefix, as well each [type@GObject.Type] in
             * the library.
             *
             * Note: The namespace must have already been loaded using a function
             * such as [method@GIRepository.Repository.require] before calling this
             * function.
             * @since 2.80
             * @param namespace_ Namespace to inspect
             * @returns C namespace prefix, or `NULL` if none associated
             */
            get_c_prefix(namespace_: string): string | null
            /**
             * Retrieves all (transitive) versioned dependencies for
             * @namespace_.
             *
             * The returned strings are of the form `namespace-version`.
             *
             * Note: @namespace_ must have already been loaded using a function
             * such as [method@GIRepository.Repository.require] before calling this
             * function.
             *
             * To get only the immediate dependencies for @namespace_, use
             * [method@GIRepository.Repository.get_immediate_dependencies].
             *
             * The list is guaranteed to be `NULL` terminated. The `NULL` terminator is not
             * counted in @n_dependencies_out.
             * @since 2.80
             * @param namespace_ Namespace of interest
             * @returns String array of   all versioned dependencies
             */
            get_dependencies(namespace_: string): string[]
            /**
             * Return an array of the immediate versioned dependencies for @namespace_.
             * Returned strings are of the form `namespace-version`.
             *
             * Note: @namespace_ must have already been loaded using a function
             * such as [method@GIRepository.Repository.require] before calling this
             * function.
             *
             * To get the transitive closure of dependencies for @namespace_, use
             * [method@GIRepository.Repository.get_dependencies].
             *
             * The list is guaranteed to be `NULL` terminated. The `NULL` terminator is not
             * counted in @n_dependencies_out.
             * @since 2.80
             * @param namespace_ Namespace of interest
             * @returns String array of   immediate versioned dependencies
             */
            get_immediate_dependencies(namespace_: string): string[]
            /**
             * This function returns a particular metadata entry in the
             * given namespace @namespace_.
             *
             * The namespace must have already been loaded before calling this function.
             * See [method@GIRepository.Repository.get_n_infos] to find the maximum number
             * of entries. It is an error to pass an invalid @idx to this function.
             * @since 2.80
             * @param namespace_ Namespace to inspect
             * @param idx 0-based offset into namespace metadata for entry
             * @returns [class@GIRepository.BaseInfo]   containing metadata
             */
            get_info(namespace_: string, idx: number): BaseInfo
            /**
             * Returns the current search path [class@GIRepository.Repository] will use when
             * loading shared libraries referenced by imported namespaces.
             *
             * The list is internal to [class@GIRepository.Repository] and should not be
             * freed, nor should its string elements.
             *
             * The list is guaranteed to be `NULL` terminated. The `NULL` terminator is not
             * counted in @n_paths_out.
             * @since 2.80
             * @returns list of search paths, most   important first
             */
            get_library_path(): string[]
            /**
             * Return the list of currently loaded namespaces.
             *
             * The list is guaranteed to be `NULL` terminated. The `NULL` terminator is not
             * counted in @n_namespaces_out.
             * @since 2.80
             * @returns    list of namespaces
             */
            get_loaded_namespaces(): string[]
            /**
             * This function returns the number of metadata entries in
             * given namespace @namespace_.
             *
             * The namespace must have already been loaded before calling this function.
             * @since 2.80
             * @param namespace_ Namespace to inspect
             * @returns number of metadata entries
             */
            get_n_infos(namespace_: string): number
            /**
             * Look up the implemented interfaces for @gtype.
             *
             * This function cannot fail per se; but for a totally ‘unknown’
             * [type@GObject.Type], it may return 0 implemented interfaces.
             *
             * The semantics of this function are designed for a dynamic binding,
             * where in certain cases (such as a function which returns an
             * interface which may have ‘hidden’ implementation classes), not all
             * data may be statically known, and will have to be determined from
             * the [type@GObject.Type] of the object.  An example is
             * [func@Gio.File.new_for_path] returning a concrete class of
             * `GLocalFile`, which is a [type@GObject.Type] we see at runtime, but
             * not statically.
             * @since 2.80
             * @param gtype a [type@GObject.Type] whose fundamental type is `G_TYPE_OBJECT`
             * @returns , Interfaces for `gtype`
             */
            get_object_gtype_interfaces(gtype: (GObject.GType | { $gtype: GObject.GType })): InterfaceInfo[]
            /**
             * Returns the current search path [class@GIRepository.Repository] will use when
             * loading typelib files.
             *
             * The list is internal to [class@GIRepository.Repository] and should not be
             * freed, nor should its string elements.
             *
             * The list is guaranteed to be `NULL` terminated. The `NULL` terminator is not
             * counted in @n_paths_out.
             * @since 2.80
             * @returns list of search paths, most   important first
             */
            get_search_path(): string[]
            /**
             * This function returns an array of paths to the
             * shared C libraries associated with the given namespace @namespace_.
             *
             * There may be no shared library path associated, in which case this
             * function will return `NULL`.
             *
             * Note: The namespace must have already been loaded using a function
             * such as [method@GIRepository.Repository.require] before calling this
             * function.
             *
             * The list is internal to [class@GIRepository.Repository] and should not be
             * freed, nor should its string elements.
             *
             * The list is guaranteed to be `NULL` terminated. The `NULL` terminator is not
             * counted in @out_n_elements.
             * @since 2.80
             * @param namespace_ Namespace to inspect
             * @returns Array of   paths to shared libraries, or `NULL` if none are associated
             */
            get_shared_libraries(namespace_: string): string[] | null
            /**
             * `.
             * @since 2.80
             * @param namespace_ GI namespace to use, e.g. `Gtk`
             * @returns `) if   successful, `NULL` if namespace is not loaded
             */
            get_typelib_path(namespace_: string): string | null
            /**
             * This function returns the loaded version associated with the given
             * namespace @namespace_.
             *
             * Note: The namespace must have already been loaded using a function
             * such as [method@GIRepository.Repository.require] before calling this
             * function.
             * @since 2.80
             * @param namespace_ Namespace to inspect
             * @returns Loaded version
             */
            get_version(namespace_: string): string
            /**
             * Check whether a particular namespace (and optionally, a specific
             * version thereof) is currently loaded.
             *
             * This function is likely to only be useful in unusual circumstances; in order
             * to act upon metadata in the namespace, you should call
             * [method@GIRepository.Repository.require] instead which will ensure the
             * namespace is loaded, and return as quickly as this function will if it has
             * already been loaded.
             * @since 2.80
             * @param namespace_ Namespace of interest
             * @param version Required version, may be `NULL` for latest
             * @returns `TRUE` if namespace-version is loaded, `FALSE` otherwise
             */
            is_registered(namespace_: string, version: string | null): boolean
            /**
             * Load the given @typelib into the repository.
             * @throws {GLib.Error}
             * @since 2.80
             * @param typelib the typelib to load
             * @param flags flags affecting the loading operation
             * @returns namespace of the loaded typelib
             */
            load_typelib(typelib: Typelib, flags: RepositoryLoadFlags): string
            /**
             * Prepends @directory to the search path that is used to
             * search shared libraries referenced by imported namespaces.
             *
             * Multiple calls to this function all contribute to the final
             * list of paths.
             *
             * The list of paths is unique to @repository. When a typelib is loaded by the
             * repository, the list of paths from the @repository at that instant is used
             * by the typelib for loading its modules.
             *
             * If the library is not found in the directories configured
             * in this way, loading will fall back to the system library
             * path (i.e. `LD_LIBRARY_PATH` and `DT_RPATH` in ELF systems).
             * See the documentation of your dynamic linker for full details.
             * @since 2.80
             * @param directory a single directory to scan for shared libraries
             */
            prepend_library_path(directory: string): void
            /**
             * Prepends @directory to the typelib search path.
             *
             * See also: gi_repository_get_search_path().
             * @since 2.80
             * @param directory directory name to prepend to the typelib
              search path
             */
            prepend_search_path(directory: string): void
            /**
             * Force the namespace @namespace_ to be loaded if it isn’t already.
             *
             * If @namespace_ is not loaded, this function will search for a
             * `.typelib` file using the repository search path.  In addition, a
             * version @version of namespace may be specified.  If @version is
             * not specified, the latest will be used.
             * @throws {GLib.Error}
             * @since 2.80
             * @param namespace_ GI namespace to use, e.g. `Gtk`
             * @param version Version of namespace, may be `NULL` for latest
             * @param flags Set of [flags@GIRepository.RepositoryLoadFlags], may be 0
             * @returns a pointer to the [type@GIRepository.Typelib] if   successful, `NULL` otherwise
             */
            require(namespace_: string, version: string | null, flags: RepositoryLoadFlags): Typelib
            /**
             * Force the namespace @namespace_ to be loaded if it isn’t already.
             *
             * If @namespace_ is not loaded, this function will search for a
             * `.typelib` file within the private directory only. In addition, a
             * version @version of namespace should be specified.  If @version is
             * not specified, the latest will be used.
             * @throws {GLib.Error}
             * @since 2.80
             * @param typelib_dir Private directory where to find the requested
              typelib
             * @param namespace_ GI namespace to use, e.g. `Gtk`
             * @param version Version of namespace, may be `NULL` for latest
             * @param flags Set of [flags@GIRepository.RepositoryLoadFlags], may be 0
             * @returns a pointer to the [type@GIRepository.Typelib] if   successful, `NULL` otherwise
             */
            require_private(typelib_dir: string, namespace_: string, version: string | null, flags: RepositoryLoadFlags): Typelib
        }

        interface RepositoryClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Repository>
            readonly prototype: Repository
            new (props?: Partial<GObject.ConstructorProps<Repository>>): Repository
            /**
             * Create a new [class@GIRepository.Repository].
             * @since 2.80
             * @returns a new [class@GIRepository.Repository]
             */
            "new"(): Repository
            /**
             * Dump the introspection data from the types specified in @input_filename to
             * @output_filename.
             *
             * The input file should be a
             * UTF-8 Unix-line-ending text file, with each line containing either
             * `get-type:` followed by the name of a [type@GObject.Type] `_get_type`
             * function, or `error-quark:` followed by the name of an error quark function.
             * No extra whitespace is allowed.
             *
             * This function will overwrite the contents of the output file.
             * @throws {GLib.Error}
             * @since 2.80
             * @param input_filename Input filename (for example `input.txt`)
             * @param output_filename Output filename (for example `output.xml`)
             * @returns true on success, false on error
             */
            dump(input_filename: string, output_filename: string): boolean
            /**
             * Gets the singleton process-global default `GIRepository`.
             *
             * The singleton is needed for situations where you must coordinate between
             * bindings and libraries which also need to interact with introspection which
             * could affect the bindings. For example, a Python application using a
             * GObject-based library through `GIRepository` to load plugins also written in
             * Python.
             * @since 2.86
             * @returns the global singleton repository
             */
            dup_default(): Repository
            /**
             */
            error_quark(): GLib.Quark
            /**
             * Obtain the option group for girepository.
             *
             * It’s used by the dumper and for programs that want to provide introspection
             * information
             * @since 2.80
             * @returns the option group
             */
            get_option_group(): GLib.OptionGroup
        }

        const Repository: RepositoryClass
        

        namespace SignalInfo {
            interface SignalSignatures extends CallableInfo.SignalSignatures {
            }

            interface ReadableProperties extends CallableInfo.ReadableProperties {
            }

            interface WritableProperties extends CallableInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends CallableInfo.ConstructOnlyProperties {
            }
        }

        /**
         * `GISignalInfo` represents a signal.
         *
         * It’s a sub-struct of [class@GIRepository.CallableInfo] and contains a set of
         * flags and a class closure.
         *
         * See [class@GIRepository.CallableInfo] for information on how to retrieve
         * arguments and other metadata from the signal.
         * @since 2.80
         */
        interface SignalInfo extends CallableInfo {
            readonly $signals: SignalInfo.SignalSignatures
            readonly $readableProperties: SignalInfo.ReadableProperties
            readonly $writableProperties: SignalInfo.WritableProperties
            readonly $constructOnlyProperties: SignalInfo.ConstructOnlyProperties
            /**
             * Obtain the class closure for this signal if one is set.
             *
             * The class closure is a virtual function on the type that the signal belongs
             * to. If the signal lacks a closure, `NULL` will be returned.
             * @since 2.80
             * @returns the class closure, or `NULL` if none is   set
             */
            get_class_closure(): VFuncInfo | null
            /**
             * Obtain the flags for this signal info.
             *
             * See [flags@GObject.SignalFlags] for more information about possible flag
             * values.
             * @since 2.80
             * @returns the flags
             */
            get_flags(): GObject.SignalFlags
            /**
             * Obtain if the returning `TRUE` in the signal handler will stop the emission
             * of the signal.
             * @since 2.80
             * @returns `TRUE` if returning `TRUE` stops the signal emission
             */
            true_stops_emit(): boolean
        }

        interface SignalInfoClass extends Omit<CallableInfoClass, "new"> {
            readonly $gtype: GObject.GType<SignalInfo>
            readonly prototype: SignalInfo
            new (props?: Partial<GObject.ConstructorProps<SignalInfo>>): SignalInfo
        }

        const SignalInfo: SignalInfoClass
        

        namespace StructInfo {
            interface SignalSignatures extends RegisteredTypeInfo.SignalSignatures {
            }

            interface ReadableProperties extends RegisteredTypeInfo.ReadableProperties {
            }

            interface WritableProperties extends RegisteredTypeInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends RegisteredTypeInfo.ConstructOnlyProperties {
            }
        }

        /**
         * `GIStructInfo` represents a generic C structure type.
         *
         * A structure has methods and fields.
         * @since 2.80
         */
        interface StructInfo extends RegisteredTypeInfo {
            readonly $signals: StructInfo.SignalSignatures
            readonly $readableProperties: StructInfo.ReadableProperties
            readonly $writableProperties: StructInfo.WritableProperties
            readonly $constructOnlyProperties: StructInfo.ConstructOnlyProperties
            /**
             * Obtain the type information for field named @name.
             * @since 2.80
             * @param name a field name
             * @returns The [class@GIRepository.FieldInfo], or   `NULL` if not found. Free it with [method@GIRepository.BaseInfo.unref] when   done.
             */
            find_field(name: string): FieldInfo | null
            /**
             * Obtain the type information for method named @name.
             * @since 2.80
             * @param name a method name
             * @returns The [class@GIRepository.FunctionInfo],   or `NULL` if none was found. Free it with   [method@GIRepository.BaseInfo.unref] when done.
             */
            find_method(name: string): FunctionInfo | null
            /**
             * Obtain the required alignment of the structure.
             * @since 2.80
             * @returns required alignment, in bytes
             */
            get_alignment(): number
            /**
             * Retrieves the name of the copy function for @info, if any is set.
             * @since 2.80
             * @returns the name of the copy function, or `NULL`   if the structure has no copy function
             */
            get_copy_function_name(): string | null
            /**
             * Obtain the type information for field with specified index.
             * @since 2.80
             * @param n a field index
             * @returns The [class@GIRepository.FieldInfo]. Free it with   [method@GIRepository.BaseInfo.unref] when done.
             */
            get_field(n: number): FieldInfo
            /**
             * Retrieves the name of the free function for @info, if any is set.
             * @since 2.80
             * @returns the name of the free function, or `NULL`   if the structure has no free function
             */
            get_free_function_name(): string | null
            /**
             * Obtain the type information for method with specified index.
             * @since 2.80
             * @param n a method index
             * @returns The [class@GIRepository.FunctionInfo]. Free it with   [method@GIRepository.BaseInfo.unref] when done.
             */
            get_method(n: number): FunctionInfo
            /**
             * Obtain the number of fields this structure has.
             * @since 2.80
             * @returns number of fields
             */
            get_n_fields(): number
            /**
             * Obtain the number of methods this structure has.
             * @since 2.80
             * @returns number of methods
             */
            get_n_methods(): number
            /**
             * Obtain the total size of the structure.
             * @since 2.80
             * @returns size of the structure, in bytes
             */
            get_size(): number
            /**
             * Gets whether the structure is foreign, i.e. if it’s expected to be overridden
             * by a native language binding instead of relying of introspected bindings.
             * @since 2.80
             * @returns `TRUE` if the structure is foreign
             */
            is_foreign(): boolean
            /**
             * Return true if this structure represents the ‘class structure’ for some
             * [class@GObject.Object] or `GInterface`.
             *
             * This function is mainly useful to hide this kind of structure from generated
             * public APIs.
             * @since 2.80
             * @returns `TRUE` if this is a class struct, `FALSE` otherwise
             */
            is_gtype_struct(): boolean
        }

        interface StructInfoClass extends Omit<RegisteredTypeInfoClass, "new"> {
            readonly $gtype: GObject.GType<StructInfo>
            readonly prototype: StructInfo
            new (props?: Partial<GObject.ConstructorProps<StructInfo>>): StructInfo
        }

        const StructInfo: StructInfoClass
        

        namespace TypeInfo {
            interface SignalSignatures extends BaseInfo.SignalSignatures {
            }

            interface ReadableProperties extends BaseInfo.ReadableProperties {
            }

            interface WritableProperties extends BaseInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends BaseInfo.ConstructOnlyProperties {
            }
        }

        /**
         * `GITypeInfo` represents a type, including information about direction and
         * transfer.
         *
         * You can retrieve a type info from an argument (see
         * [class@GIRepository.ArgInfo]), a function’s return value (see
         * [class@GIRepository.FunctionInfo]), a field (see
         * [class@GIRepository.FieldInfo]), a property (see
         * [class@GIRepository.PropertyInfo]), a constant (see
         * [class@GIRepository.ConstantInfo]) or for a union discriminator (see
         * [class@GIRepository.UnionInfo]).
         *
         * A type can either be a of a basic type which is a standard C primitive
         * type or an interface type. For interface types you need to call
         * [method@GIRepository.TypeInfo.get_interface] to get a reference to the base
         * info for that interface.
         * @since 2.80
         */
        interface TypeInfo extends BaseInfo {
            readonly $signals: TypeInfo.SignalSignatures
            readonly $readableProperties: TypeInfo.ReadableProperties
            readonly $writableProperties: TypeInfo.WritableProperties
            readonly $constructOnlyProperties: TypeInfo.ConstructOnlyProperties
            /**
             * Convert a data pointer from a GLib data structure to a
             * [type@GIRepository.Argument].
             *
             * GLib data structures, such as [type@GLib.List], [type@GLib.SList], and
             * [type@GLib.HashTable], all store data pointers.
             *
             * In the case where the list or hash table is storing single types rather than
             * structs, these data pointers may have values stuffed into them via macros
             * such as `GPOINTER_TO_INT`.
             *
             * Use this function to ensure that all values are correctly extracted from
             * stuffed pointers, regardless of the machine’s architecture or endianness.
             *
             * This function fills in the appropriate field of @arg with the value extracted
             * from @hash_pointer, depending on the storage type of @info.
             * @since 2.80
             * @param hash_pointer a pointer, such as a [struct@GLib.HashTable] data pointer
             * @returns , a [type@GIRepository.Argument] to fill in
             */
            argument_from_hash_pointer(hash_pointer: never | null): Argument
            /**
             * Obtain the fixed array size of the type, in number of elements (not bytes).
             *
             * The type tag must be a `GI_TYPE_TAG_ARRAY` with a fixed size, or `FALSE` will
             * be returned.
             * @since 2.80
             * @returns `TRUE` if the type is an array and has a fixed size, return location for the array size
             */
            get_array_fixed_size(): boolean
            /**
             * Obtain the position of the argument which gives the array length of the type.
             *
             * The type tag must be a `GI_TYPE_TAG_ARRAY` with a length argument, or `FALSE`
             * will be returned.
             * @since 2.80
             * @returns `TRUE` if the type is an array and has a length argument, return location for the length argument
             */
            get_array_length_index(): boolean
            /**
             * Obtain the array type for this type.
             *
             * See [enum@GIRepository.ArrayType] for a list of possible values.
             *
             * It is an error to call this on an @info which is not an array type. Use
             * [method@GIRepository.TypeInfo.get_tag] to check.
             * @since 2.80
             * @returns the array type
             */
            get_array_type(): ArrayType
            /**
             * For types which have `GI_TYPE_TAG_INTERFACE` such as [class@GObject.Object]s
             * and boxed values, this function returns full information about the referenced
             * type.
             *
             * You can then inspect the type of the returned [class@GIRepository.BaseInfo]
             * to further query whether it is a concrete [class@GObject.Object], an
             * interface, a structure, etc., using the type checking macros like
             * [func@GIRepository.IS_OBJECT_INFO], or raw [type@GObject.Type]s with
             * [func@GObject.TYPE_FROM_INSTANCE].
             * @since 2.80
             * @returns The [class@GIRepository.BaseInfo], or   `NULL`. Free it with gi_base_info_unref() when done.
             */
            get_interface(): BaseInfo | null
            /**
             * Obtain the parameter type @n, or `NULL` if the type is not an array.
             * @since 2.80
             * @param n index of the parameter
             * @returns the param type info, or `NULL` if the   type is not an array
             */
            get_param_type(n: number): TypeInfo | null
            /**
             * Obtain the type tag corresponding to the underlying storage type in C for
             * the type.
             *
             * See [type@GIRepository.TypeTag] for a list of type tags.
             * @since 2.80
             * @returns the type tag
             */
            get_storage_type(): TypeTag
            /**
             * Obtain the type tag for the type.
             *
             * See [type@GIRepository.TypeTag] for a list of type tags.
             * @since 2.80
             * @returns the type tag
             */
            get_tag(): TypeTag
            /**
             * Convert a [type@GIRepository.Argument] to data pointer for use in a GLib
             * data structure.
             *
             * GLib data structures, such as [type@GLib.List], [type@GLib.SList], and
             * [type@GLib.HashTable], all store data pointers.
             *
             * In the case where the list or hash table is storing single types rather than
             * structs, these data pointers may have values stuffed into them via macros
             * such as `GPOINTER_TO_INT`.
             *
             * Use this function to ensure that all values are correctly stuffed into
             * pointers, regardless of the machine’s architecture or endianness.
             *
             * This function returns a pointer stuffed with the appropriate field of @arg,
             * depending on the storage type of @info.
             * @since 2.80
             * @param arg a [struct@GIRepository.Argument] with the value to stuff into a pointer
             * @returns A stuffed pointer, that can be stored in a [struct@GLib.HashTable],   for example
             */
            hash_pointer_from_argument(arg: Argument): never | null
            /**
             * Obtain if the type is passed as a reference.
             *
             * Note that the types of `GI_DIRECTION_OUT` and `GI_DIRECTION_INOUT` parameters
             * will only be pointers if the underlying type being transferred is a pointer
             * (i.e. only if the type of the C function’s formal parameter is a pointer to a
             * pointer).
             * @since 2.80
             * @returns `TRUE` if it is a pointer
             */
            is_pointer(): boolean
            /**
             * Obtain if the last element of the array is `NULL`.
             *
             * The type tag must be a `GI_TYPE_TAG_ARRAY` or `FALSE` will be returned.
             * @since 2.80
             * @returns `TRUE` if zero terminated
             */
            is_zero_terminated(): boolean
        }

        interface TypeInfoClass extends Omit<BaseInfoClass, "new"> {
            readonly $gtype: GObject.GType<TypeInfo>
            readonly prototype: TypeInfo
            new (props?: Partial<GObject.ConstructorProps<TypeInfo>>): TypeInfo
        }

        const TypeInfo: TypeInfoClass
        

        namespace UnionInfo {
            interface SignalSignatures extends RegisteredTypeInfo.SignalSignatures {
            }

            interface ReadableProperties extends RegisteredTypeInfo.ReadableProperties {
            }

            interface WritableProperties extends RegisteredTypeInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends RegisteredTypeInfo.ConstructOnlyProperties {
            }
        }

        /**
         * `GIUnionInfo` represents a union type.
         *
         * A union has methods and fields.  Unions can optionally have a
         * discriminator, which is a field deciding what type of real union
         * fields is valid for specified instance.
         * @since 2.80
         */
        interface UnionInfo extends RegisteredTypeInfo {
            readonly $signals: UnionInfo.SignalSignatures
            readonly $readableProperties: UnionInfo.ReadableProperties
            readonly $writableProperties: UnionInfo.WritableProperties
            readonly $constructOnlyProperties: UnionInfo.ConstructOnlyProperties
            /**
             * Obtain the type information for the method named @name.
             * @since 2.80
             * @param name a method name
             * @returns The [type@GIRepository.FunctionInfo], or   `NULL` if none was found. Free it with [method@GIRepository.BaseInfo.unref]   when done.
             */
            find_method(name: string): FunctionInfo | null
            /**
             * Obtain the required alignment of the union.
             * @since 2.80
             * @returns required alignment, in bytes
             */
            get_alignment(): number
            /**
             * Retrieves the name of the copy function for @info, if any is set.
             * @since 2.80
             * @returns the name of the copy function, or `NULL`   if none is set
             */
            get_copy_function_name(): string | null
            /**
             * Obtain the discriminator value assigned for n-th union field, i.e. the n-th
             * union field is the active one if the discriminator contains this
             * constant.
             *
             * If the union is not discriminated, `NULL` is returned.
             * @since 2.80
             * @param n a union field index
             * @returns The [type@GIRepository.ConstantInfo], or   `NULL` if the union is not discriminated. Free it with   [method@GIRepository.BaseInfo.unref] when done.
             */
            get_discriminator(n: number): ConstantInfo | null
            /**
             * Obtain the offset of the discriminator field within the structure.
             *
             * The union must be discriminated, or `FALSE` will be returned.
             * @since 2.80
             * @returns `TRUE` if the union is discriminated, return location for the offset, in bytes, of   the discriminator
             */
            get_discriminator_offset(): boolean
            /**
             * Obtain the type information of the union discriminator.
             * @since 2.80
             * @returns the [type@GIRepository.TypeInfo], or   `NULL` if the union is not discriminated. Free it with   [method@GIRepository.BaseInfo.unref] when done.
             */
            get_discriminator_type(): TypeInfo | null
            /**
             * Obtain the type information for the field with the specified index.
             * @since 2.80
             * @param n a field index
             * @returns the [type@GIRepository.FieldInfo], free it with   [method@GIRepository.BaseInfo.unref] when done.
             */
            get_field(n: number): FieldInfo
            /**
             * Retrieves the name of the free function for @info, if any is set.
             * @since 2.80
             * @returns the name of the free function, or `NULL`   if none is set
             */
            get_free_function_name(): string | null
            /**
             * Obtain the type information for the method with the specified index.
             * @since 2.80
             * @param n a method index
             * @returns the [type@GIRepository.FunctionInfo], free it   with [method@GIRepository.BaseInfo.unref] when done.
             */
            get_method(n: number): FunctionInfo
            /**
             * Obtain the number of fields this union has.
             * @since 2.80
             * @returns number of fields
             */
            get_n_fields(): number
            /**
             * Obtain the number of methods this union has.
             * @since 2.80
             * @returns number of methods
             */
            get_n_methods(): number
            /**
             * Obtain the total size of the union.
             * @since 2.80
             * @returns size of the union, in bytes
             */
            get_size(): number
            /**
             * Return `TRUE` if this union contains a discriminator field.
             * @since 2.80
             * @returns `TRUE` if this is a discriminated union, `FALSE` otherwise
             */
            is_discriminated(): boolean
        }

        interface UnionInfoClass extends Omit<RegisteredTypeInfoClass, "new"> {
            readonly $gtype: GObject.GType<UnionInfo>
            readonly prototype: UnionInfo
            new (props?: Partial<GObject.ConstructorProps<UnionInfo>>): UnionInfo
        }

        const UnionInfo: UnionInfoClass
        

        namespace UnresolvedInfo {
            interface SignalSignatures extends BaseInfo.SignalSignatures {
            }

            interface ReadableProperties extends BaseInfo.ReadableProperties {
            }

            interface WritableProperties extends BaseInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends BaseInfo.ConstructOnlyProperties {
            }
        }

        /**
         * `GIUnresolvedInfo` represents an unresolved symbol.
         * @since 2.80
         */
        interface UnresolvedInfo extends BaseInfo {
            readonly $signals: UnresolvedInfo.SignalSignatures
            readonly $readableProperties: UnresolvedInfo.ReadableProperties
            readonly $writableProperties: UnresolvedInfo.WritableProperties
            readonly $constructOnlyProperties: UnresolvedInfo.ConstructOnlyProperties
        }

        interface UnresolvedInfoClass extends Omit<BaseInfoClass, "new"> {
            readonly $gtype: GObject.GType<UnresolvedInfo>
            readonly prototype: UnresolvedInfo
            new (props?: Partial<GObject.ConstructorProps<UnresolvedInfo>>): UnresolvedInfo
        }

        const UnresolvedInfo: UnresolvedInfoClass
        

        namespace VFuncInfo {
            interface SignalSignatures extends CallableInfo.SignalSignatures {
            }

            interface ReadableProperties extends CallableInfo.ReadableProperties {
            }

            interface WritableProperties extends CallableInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends CallableInfo.ConstructOnlyProperties {
            }
        }

        /**
         * `GIVFuncInfo` represents a virtual function.
         *
         * A virtual function is a callable object that belongs to either a
         * [type@GIRepository.ObjectInfo] or a [type@GIRepository.InterfaceInfo].
         * @since 2.80
         */
        interface VFuncInfo extends CallableInfo {
            readonly $signals: VFuncInfo.SignalSignatures
            readonly $readableProperties: VFuncInfo.ReadableProperties
            readonly $writableProperties: VFuncInfo.WritableProperties
            readonly $constructOnlyProperties: VFuncInfo.ConstructOnlyProperties
            /**
             * Looks up where the implementation for @info is inside the type struct of
             * @implementor_gtype.
             * @throws {GLib.Error}
             * @since 2.80
             * @param implementor_gtype [type@GObject.Type] implementing this virtual function
             * @returns address to a function
             */
            get_address(implementor_gtype: (GObject.GType | { $gtype: GObject.GType })): never | null
            /**
             * Obtain the flags for this virtual function info.
             *
             * See [flags@GIRepository.VFuncInfoFlags] for more information about possible
             * flag values.
             * @since 2.80
             * @returns the flags
             */
            get_flags(): VFuncInfoFlags
            /**
             * If this virtual function has an associated invoker method, this
             * method will return it.  An invoker method is a C entry point.
             *
             * Not all virtuals will have invokers.
             * @since 2.80
             * @returns The [type@GIRepository.FunctionInfo] or   `NULL` if none is set. Free it with [method@GIRepository.BaseInfo.unref]   when done.
             */
            get_invoker(): FunctionInfo | null
            /**
             * Obtain the offset of the function pointer in the class struct.
             *
             * The value `0xFFFF` indicates that the struct offset is unknown.
             * @since 2.80
             * @returns the struct offset or `0xFFFF` if it’s unknown
             */
            get_offset(): number
            /**
             * Obtain the signal for the virtual function if one is set.
             *
             * The signal comes from the object or interface to which
             * this virtual function belongs.
             * @since 2.80
             * @returns the signal, or `NULL` if none is set
             */
            get_signal(): SignalInfo | null
        }

        interface VFuncInfoClass extends Omit<CallableInfoClass, "new"> {
            readonly $gtype: GObject.GType<VFuncInfo>
            readonly prototype: VFuncInfo
            new (props?: Partial<GObject.ConstructorProps<VFuncInfo>>): VFuncInfo
        }

        const VFuncInfo: VFuncInfoClass
        

        namespace ValueInfo {
            interface SignalSignatures extends BaseInfo.SignalSignatures {
            }

            interface ReadableProperties extends BaseInfo.ReadableProperties {
            }

            interface WritableProperties extends BaseInfo.WritableProperties {
            }

            interface ConstructOnlyProperties extends BaseInfo.ConstructOnlyProperties {
            }
        }

        /**
         * A `GIValueInfo` represents a value in an enumeration.
         *
         * The `GIValueInfo` is fetched by calling
         * [method@GIRepository.EnumInfo.get_value] on a [class@GIRepository.EnumInfo].
         * @since 2.80
         */
        interface ValueInfo extends BaseInfo {
            readonly $signals: ValueInfo.SignalSignatures
            readonly $readableProperties: ValueInfo.ReadableProperties
            readonly $writableProperties: ValueInfo.WritableProperties
            readonly $constructOnlyProperties: ValueInfo.ConstructOnlyProperties
            /**
             * Obtain the enumeration value of the `GIValueInfo`.
             * @since 2.80
             * @returns the enumeration value. This will always be representable   as a 32-bit signed or unsigned value. The use of `int64_t` as the   return type is to allow both.
             */
            get_value(): number
        }

        interface ValueInfoClass extends Omit<BaseInfoClass, "new"> {
            readonly $gtype: GObject.GType<ValueInfo>
            readonly prototype: ValueInfo
            new (props?: Partial<GObject.ConstructorProps<ValueInfo>>): ValueInfo
        }

        const ValueInfo: ValueInfoClass
        /**
         * An opaque structure used to iterate over attributes
         * in a [class@GIRepository.BaseInfo] struct.
         * @since 2.80
         */
        abstract class AttributeIter {
            static readonly $gtype: GObject.GType<AttributeIter>

            
        }
        none
        /**
         */
        abstract class BaseInfoStack {
            static readonly $gtype: GObject.GType<BaseInfoStack>

            
        }
        none
        /**
         * `GITypelib` represents a loaded `.typelib` file, which contains a description
         * of a single module’s API.
         * @since 2.80
         */
        abstract class Typelib {
            static readonly $gtype: GObject.GType<Typelib>

            
            /**
             * Creates a new [type@GIRepository.Typelib] from a [type@GLib.Bytes].
             *
             * The [type@GLib.Bytes] can point to a memory location or a mapped file, and
             * the typelib will hold a reference to it until the repository is destroyed.
             * @throws {GLib.Error}
             * @since 2.80
             * @param bytes memory chunk containing the typelib
             * @returns the new [type@GIRepository.Typelib]
             */
            static new_from_bytes(bytes: GLib.Bytes): Typelib
            /**
             * Get the name of the namespace represented by @typelib.
             * @since 2.80
             * @returns name of the namespace represented by `typelib`
             */
            get_namespace(): string
            /**
             * Increment the reference count of a [type@GIRepository.Typelib].
             * @since 2.80
             * @returns the same `typelib` pointer
             */
            ref(): Typelib
            /**
             * Loads a symbol from a `GITypelib`.
             * @since 2.80
             * @param symbol_name name of symbol to be loaded
             * @returns `TRUE` on success, returns a pointer to the symbol value, or `NULL`   on failure
             */
            symbol(symbol_name: string): [boolean, never | null]
            /**
             * Decrement the reference count of a [type@GIRepository.Typelib].
             *
             * Once the reference count reaches zero, the typelib is freed.
             * @since 2.80
             */
            unref(): void
        }
        none
        /**
         * Get the error quark which represents [type@GIRepository.InvokeError].
         * @since 2.80
         * @returns error quark
         */
        function invoke_error_quark(): GLib.Quark
        /**
         * Convert a data pointer from a GLib data structure to a
         * [type@GIRepository.Argument].
         *
         * GLib data structures, such as [type@GLib.List], [type@GLib.SList], and
         * [type@GLib.HashTable], all store data pointers.
         *
         * In the case where the list or hash table is storing single types rather than
         * structs, these data pointers may have values stuffed into them via macros
         * such as `GPOINTER_TO_INT`.
         *
         * Use this function to ensure that all values are correctly extracted from
         * stuffed pointers, regardless of the machine’s architecture or endianness.
         *
         * This function fills in the appropriate field of @arg with the value extracted
         * from @hash_pointer, depending on @storage_type.
         * @since 2.80
         * @param storage_type a [type@GIRepository.TypeTag] obtained from
          [method@GIRepository.TypeInfo.get_storage_type]
         * @param hash_pointer a pointer, such as a [struct@GLib.HashTable] data pointer
         * @returns , a [type@GIRepository.Argument]   to fill in
         */
        function type_tag_argument_from_hash_pointer(storage_type: TypeTag, hash_pointer: never | null): Argument
        /**
         * Convert a [type@GIRepository.Argument] to data pointer for use in a GLib
         * data structure.
         *
         * GLib data structures, such as [type@GLib.List], [type@GLib.SList], and
         * [type@GLib.HashTable], all store data pointers.
         *
         * In the case where the list or hash table is storing single types rather than
         * structs, these data pointers may have values stuffed into them via macros
         * such as `GPOINTER_TO_INT`.
         *
         * Use this function to ensure that all values are correctly stuffed into
         * pointers, regardless of the machine’s architecture or endianness.
         *
         * This function returns a pointer stuffed with the appropriate field of @arg,
         * depending on @storage_type.
         * @since 2.80
         * @param storage_type a [type@GIRepository.TypeTag] obtained from
          [method@GIRepository.TypeInfo.get_storage_type]
         * @param arg a [type@GIRepository.Argument] with the value to stuff into a pointer
         * @returns A stuffed pointer, that can be stored in a [struct@GLib.HashTable],   for example
         */
        function type_tag_hash_pointer_from_argument(storage_type: TypeTag, arg: Argument): never | null
        /**
         * Obtain a string representation of @type
         * @since 2.80
         * @param type the type_tag
         * @returns the string
         */
        function type_tag_to_string(type: TypeTag): string
        const TYPE_TAG_N_TYPES: 22
        /**
         * Stores an argument of varying type.
         * @since 2.80
         */
        abstract class Argument {
            static readonly $gtype: GObject.GType<Argument>

            
            /**
             * boolean value
             */
            v_boolean: boolean
            /**
             * 8-bit signed integer value
             */
            v_int8: number
            /**
             * 8-bit unsigned integer value
             */
            v_uint8: number
            /**
             * 16-bit signed integer value
             */
            v_int16: number
            /**
             * 16-bit unsigned integer value
             */
            v_uint16: number
            /**
             * 32-bit signed integer value
             */
            v_int32: number
            /**
             * 32-bit unsigned integer value
             */
            v_uint32: number
            /**
             * 64-bit signed integer value
             */
            v_int64: number
            /**
             * 64-bit unsigned integer value
             */
            v_uint64: number
            /**
             * single float value
             */
            v_float: number
            /**
             * double float value
             */
            v_double: number
            /**
             * signed short integer value
             */
            v_short: number
            /**
             * unsigned short integer value
             */
            v_ushort: number
            /**
             * signed integer value
             */
            v_int: number
            /**
             * unsigned integer value
             */
            v_uint: number
            /**
             * signed long integer value
             */
            v_long: number
            /**
             * unsigned long integer value
             */
            v_ulong: number
            /**
             * sized `size_t` value
             */
            v_ssize: number
            /**
             * unsigned `size_t` value
             */
            v_size: number
            /**
             * nul-terminated string value
             */
            v_string: string
            /**
             * arbitrary pointer value
             */
            v_pointer: never
        }
        
        namespace ArrayType {
            const $gtype: GObject.GType<ArrayType>
        }

        /**
         * The type of array in a [class@GIRepository.TypeInfo].
         * @since 2.80
         */
        enum ArrayType {
            /**
             * a C array, `char[]` for instance
             */
            "C" = 0,
            /**
             * a [type@GLib.Array] array
             */
            "ARRAY" = 1,
            /**
             * a [type@GLib.PtrArray] array
             */
            "PTR_ARRAY" = 2,
            /**
             * a [type@GLib.ByteArray] array
             */
            "BYTE_ARRAY" = 3,
        }
        
        namespace Direction {
            const $gtype: GObject.GType<Direction>
        }

        /**
         * The direction of a [class@GIRepository.ArgInfo].
         * @since 2.80
         */
        enum Direction {
            /**
             * ‘in’ argument.
             */
            "IN" = 0,
            /**
             * ‘out’ argument.
             */
            "OUT" = 1,
            /**
             * ‘in and out’ argument.
             */
            "INOUT" = 2,
        }
        
        abstract class InvokeError extends GLib.Error {
            static readonly $gtype: GObject.GType<InvokeError>
            /**
             * invocation failed, unknown error.
             */
            static readonly "FAILED": 0
            /**
             * symbol couldn’t be found in any of the
             *   libraries associated with the typelib of the function.
             */
            static readonly "SYMBOL_NOT_FOUND": 1
            /**
             * the arguments provided didn’t match
             *   the expected arguments for the function’s type signature.
             */
            static readonly "ARGUMENT_MISMATCH": 2
        }
        
        namespace RepositoryError {
            const $gtype: GObject.GType<RepositoryError>
        }

        /**
         * An error code used with `GI_REPOSITORY_ERROR` in a [type@GLib.Error]
         * returned from a [class@GIRepository.Repository] routine.
         * @since 2.80
         */
        enum RepositoryError {
            /**
             * the typelib could not be found.
             */
            "TYPELIB_NOT_FOUND" = 0,
            /**
             * the namespace does not match the
             *   requested namespace.
             */
            "NAMESPACE_MISMATCH" = 1,
            /**
             * the version of the
             *   typelib does not match the requested version.
             */
            "NAMESPACE_VERSION_CONFLICT" = 2,
            /**
             * the library used by the typelib
             *   could not be found.
             */
            "LIBRARY_NOT_FOUND" = 3,
        }
        
        namespace ScopeType {
            const $gtype: GObject.GType<ScopeType>
        }

        /**
         * Scope type of a [class@GIRepository.ArgInfo] representing callback,
         * determines how the callback is invoked and is used to decided when the invoke
         * structs can be freed.
         * @since 2.80
         */
        enum ScopeType {
            /**
             * The argument is not of callback type.
             */
            "INVALID" = 0,
            /**
             * The callback and associated `user_data` is only
             *   used during the call to this function.
             */
            "CALL" = 1,
            /**
             * The callback and associated `user_data` is
             *   only used until the callback is invoked, and the callback.
             *   is invoked always exactly once.
             */
            "ASYNC" = 2,
            /**
             * The callback and associated
             *   `user_data` is used until the caller is notified via the
             *   [type@GLib.DestroyNotify].
             */
            "NOTIFIED" = 3,
            /**
             * The callback and associated `user_data` is
             *   used until the process terminates
             */
            "FOREVER" = 4,
        }
        
        namespace Transfer {
            const $gtype: GObject.GType<Transfer>
        }

        /**
         * `GITransfer` specifies who’s responsible for freeing the resources after an
         * ownership transfer is complete.
         *
         * The transfer is the exchange of data between two parts, from the callee to
         * the caller.
         *
         * The callee is either a function/method/signal or an object/interface where a
         * property is defined. The caller is the side accessing a property or calling a
         * function.
         *
         * In the case of a containing type such as a list, an array or a hash table the
         * container itself is specified differently from the items within the
         * container. Each container is freed differently, check the documentation for
         * the types themselves for information on how to free them.
         * @since 2.80
         */
        enum Transfer {
            /**
             * Transfer nothing from the callee (function or the type
             *   instance the property belongs to) to the caller. The callee retains the
             *   ownership of the transfer and the caller doesn’t need to do anything to
             *   free up the resources of this transfer.
             */
            "NOTHING" = 0,
            /**
             * Transfer the container (list, array, hash table) from
             *   the callee to the caller. The callee retains the ownership of the
             *   individual items in the container and the caller has to free up the
             *   container resources ([func@GLib.List.free],
             *   [func@GLib.HashTable.destroy], etc) of this transfer.
             */
            "CONTAINER" = 1,
            /**
             * Transfer everything, e.g. the container and its
             *   contents from the callee to the caller. This is the case when the callee
             *   creates a copy of all the data it returns. The caller is responsible for
             *   cleaning up the container and item resources of this transfer.
             */
            "EVERYTHING" = 2,
        }
        
        namespace TypeTag {
            const $gtype: GObject.GType<TypeTag>
        }

        /**
         * The type tag of a [class@GIRepository.TypeInfo].
         * @since 2.80
         */
        enum TypeTag {
            /**
             * void
             */
            "VOID" = 0,
            /**
             * boolean
             */
            "BOOLEAN" = 1,
            /**
             * 8-bit signed integer
             */
            "INT8" = 2,
            /**
             * 8-bit unsigned integer
             */
            "UINT8" = 3,
            /**
             * 16-bit signed integer
             */
            "INT16" = 4,
            /**
             * 16-bit unsigned integer
             */
            "UINT16" = 5,
            /**
             * 32-bit signed integer
             */
            "INT32" = 6,
            /**
             * 32-bit unsigned integer
             */
            "UINT32" = 7,
            /**
             * 64-bit signed integer
             */
            "INT64" = 8,
            /**
             * 64-bit unsigned integer
             */
            "UINT64" = 9,
            /**
             * float
             */
            "FLOAT" = 10,
            /**
             * double floating point
             */
            "DOUBLE" = 11,
            /**
             * a [type@GObject.Type]
             */
            "GTYPE" = 12,
            /**
             * a UTF-8 encoded string
             */
            "UTF8" = 13,
            /**
             * a filename, encoded in the same encoding
             *   as the native filesystem is using.
             */
            "FILENAME" = 14,
            /**
             * an array
             */
            "ARRAY" = 15,
            /**
             * an extended interface object
             */
            "INTERFACE" = 16,
            /**
             * a [type@GLib.List]
             */
            "GLIST" = 17,
            /**
             * a [type@GLib.SList]
             */
            "GSLIST" = 18,
            /**
             * a [type@GLib.HashTable]
             */
            "GHASH" = 19,
            /**
             * a [type@GLib.Error]
             */
            "ERROR" = 20,
            /**
             * Unicode character
             */
            "UNICHAR" = 21,
        }
        
        namespace FieldInfoFlags {
            const $gtype: GObject.GType<FieldInfoFlags>
        }

        /**
         * Flags for a [class@GIRepository.FieldInfo].
         * @since 2.80
         */
        enum FieldInfoFlags {
            /**
             * no flags set (since: 2.86)
             */
            "INFO_FLAGS_NONE" = 0,
            /**
             * field is readable.
             */
            "IS_READABLE" = 1,
            /**
             * field is writable.
             */
            "IS_WRITABLE" = 2,
        }
        
        namespace FunctionInfoFlags {
            const $gtype: GObject.GType<FunctionInfoFlags>
        }

        /**
         * Flags for a [class@GIRepository.FunctionInfo] struct.
         * @since 2.80
         */
        enum FunctionInfoFlags {
            /**
             * no flags set (since: 2.86)
             */
            "INFO_FLAGS_NONE" = 0,
            /**
             * is a method.
             */
            "IS_METHOD" = 1,
            /**
             * is a constructor.
             */
            "IS_CONSTRUCTOR" = 2,
            /**
             * is a getter of a [class@GIRepository.PropertyInfo].
             */
            "IS_GETTER" = 4,
            /**
             * is a setter of a [class@GIRepository.PropertyInfo].
             */
            "IS_SETTER" = 8,
            /**
             * represents a virtual function.
             */
            "WRAPS_VFUNC" = 16,
            /**
             */
            "IS_ASYNC" = 32,
        }
        
        namespace RepositoryLoadFlags {
            const $gtype: GObject.GType<RepositoryLoadFlags>
        }

        /**
         * Flags that control how a typelib is loaded.
         * @since 2.80
         */
        enum RepositoryLoadFlags {
            /**
             * No flags set.
             */
            "NONE" = 0,
            /**
             * Lazily load the typelib.
             */
            "LAZY" = 1,
        }
        
        namespace VFuncInfoFlags {
            const $gtype: GObject.GType<VFuncInfoFlags>
        }

        /**
         * Flags of a [class@GIRepository.VFuncInfo] struct.
         * @since 2.80
         */
        enum VFuncInfoFlags {
            /**
             * no flags set (since: 2.86)
             */
            "INFO_FLAGS_NONE" = 0,
            /**
             * chains up to the parent type
             */
            "MUST_CHAIN_UP" = 1,
            /**
             * overrides
             */
            "MUST_OVERRIDE" = 2,
            /**
             * does not override
             */
            "MUST_NOT_OVERRIDE" = 4,
        }
        none
        none
        none
        none
    }

    export default GIRepository
}