
/// <reference path="./GLib-2.0.d.ts" />
/// <reference path="./GModule-2.0.d.ts" />
/// <reference path="./GObject-2.0.d.ts" />
/// <reference path="./Gio-2.0.d.ts" />

/**
 * Type Definitions for GJS (https://gjs.guide/), generated by [GirGen](https://github.com/aylur/girgen)
 * If you found a bug, create a bug report on [GirGen's Repository](https://github.com/aylur/girgen/issues/new)
 */
declare module "gi://Gly?version=2" {
    import type GLib from "gi://GLib?version=2.0"
    import type GModule from "gi://GModule?version=2.0"
    import type GObject from "gi://GObject?version=2.0"
    import type Gio from "gi://Gio?version=2.0"

    


    namespace Gly {
        const __name__: "Gly"
        const __version: "2"
        

        namespace Creator {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "mime-type": string
                "sandbox-selector": SandboxSelector
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "mime-type": string
                "sandbox-selector": SandboxSelector
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         *
         *
         * GlyCreator *creator = gly_creator_new("image/jpeg", NULL);
         *
         * if (!creator)
         *   return;
         *
         * // Create frame with a single red pixel
         * guint8 data[] = {255, 0, 0};
         * gsize length = sizeof(data);
         * GBytes *texture = g_bytes_new(data, length);
         * GlyNewFrame *new_frame = gly_creator_add_frame(creator, 1, 1, GLY_MEMORY_R8G8B8, texture);
         *
         * // Create JPEG
         * GlyEncodedImage *encoded_image = gly_creator_create(creator, NULL);
         *
         * if (encoded_image)
         * {
         *   GBytes *binary_data = gly_encoded_image_get_data(encoded_image);
         *   if (binary_data)
         *   {
         *     // Write image to file
         *     GFile *file = g_file_new_for_path("test.jpg");
         *     g_file_replace_contents(
         *         file,
         *         g_bytes_get_data(binary_data, NULL),
         *         g_bytes_get_size(binary_data),
         *         NULL,
         *         FALSE,
         *         G_FILE_CREATE_NONE,
         *         NULL,
         *         NULL,
         *         NULL);
         *   }
         * }
         * ```
         * @since 2.0
         */
        interface Creator extends GObject.Object {
            readonly $signals: Creator.SignalSignatures
            readonly $readableProperties: Creator.ReadableProperties
            readonly $writableProperties: Creator.WritableProperties
            readonly $constructOnlyProperties: Creator.ConstructOnlyProperties
            /**
             * @default NULL
             */
            get mimeType(): string
            set mimeType(value: string)
            /**
             * @default Auto
             */
            get sandboxSelector(): SandboxSelector
            set sandboxSelector(value: SandboxSelector)
            /**
             * @throws {GLib.Error}
             * @since 2.0
             * @param width
             * @param height
             * @param memory_format
             * @param texture Texture data
             * @returns a new [class@NewFrame]
             */
            add_frame(width: number, height: number, memory_format: MemoryFormat, texture: GLib.Bytes): NewFrame
            /**
             * @throws {GLib.Error}
             * @since 2.0
             * @param width
             * @param height @stride
             * @param stride
             * @param memory_format
             * @param texture Texture data
             * @returns a new [class@NewFrame]
             */
            add_frame_with_stride(width: number, height: number, stride: number, memory_format: MemoryFormat, texture: GLib.Bytes): NewFrame
            /**
             * Add metadata that are stored as key-value pairs.
             * A prominent example are PNG's `tEXt` chunks.
             *
             * If an entry with `key` already exists, it will be replaced.
             * @since 2.0
             * @param key A null-terminated string.
             * @param value A null-terminated string.
             * @returns `TRUE` if format supports key-value storage.
             */
            add_metadata_key_value(key: string, value: string): boolean
            /**
             * @throws {GLib.Error}
             * @since 2.0
             * @returns The encoded image.
             */
            create(): EncodedImage | null
            /**
             * Asynchronous version of [method@Creator.create].
             * @since 2.0
             * @param cancellable A [class@Gio.Cancellable] to cancel the operation
             * @param callback A callback to call when the operation is complete
             */
            create_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Finishes the [method@Creator.create_async] call.
             * @throws {GLib.Error}
             * @since 2.0
             * @param result A `GAsyncResult`
             * @returns Encoded image.
             */
            create_finish(result: Gio.AsyncResult): EncodedImage
            /**
             * @since 2.0
             * @param compression Value between 0 and 100
             * @returns `TRUE` if the format supports compression setting.
             */
            set_encoding_compression(compression: number): boolean
            /**
             * @since 2.0
             * @param quality Value between 0 and 100
             * @returns `TRUE` if format supports a quality setting.
             */
            set_encoding_quality(quality: number): boolean
            /**
             * Selects which sandbox mechanism should be used. The default without calling this function is [enum@SandboxSelector]`.AUTO`.
             * @since 2.0
             * @param sandbox_selector Method by which the sandbox mechanism is selected
             */
            set_sandbox_selector(sandbox_selector: SandboxSelector): boolean
        }

        interface CreatorClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Creator>
            readonly prototype: Creator
            new (props?: Partial<GObject.ConstructorProps<Creator>>): Creator
            /**
             * @throws {GLib.Error}
             * @since 2.0
             * @param mime_type A null-terminated string.
             * @returns a new [class@Creator]
             */
            "new"(mime_type: string): Creator
        }

        const Creator: CreatorClass
        

        namespace EncodedImage {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "data": GLib.Bytes
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "data": GLib.Bytes
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * Encoded image
         * @since 2.0
         */
        interface EncodedImage extends GObject.Object {
            readonly $signals: EncodedImage.SignalSignatures
            readonly $readableProperties: EncodedImage.ReadableProperties
            readonly $writableProperties: EncodedImage.WritableProperties
            readonly $constructOnlyProperties: EncodedImage.ConstructOnlyProperties
            /**
             */
            get data(): GLib.Bytes
            set data(value: GLib.Bytes)
            /**
             * @since 2.0
             * @returns The encoded image data
             */
            get_data(): GLib.Bytes
        }

        interface EncodedImageClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<EncodedImage>
            readonly prototype: EncodedImage
            new (props?: Partial<GObject.ConstructorProps<EncodedImage>>): EncodedImage
        }

        const EncodedImage: EncodedImageClass
        

        namespace Frame {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * A frame of an image often being the complete image.
         * @since 2.0
         */
        interface Frame extends GObject.Object {
            readonly $signals: Frame.SignalSignatures
            readonly $readableProperties: Frame.ReadableProperties
            readonly $writableProperties: Frame.WritableProperties
            readonly $constructOnlyProperties: Frame.ConstructOnlyProperties
            /**
             * Image data arranged according to [method@Frame.get_memory_format]
             * @since 2.0
             * @returns Image data
             */
            get_buf_bytes(): GLib.Bytes
            /**
             * Returns the CICP (coding-independent code point) for the frames texture.
             * This value is `NULL` if no CICP is used.
             * @since 2.0
             * @returns CICP
             */
            get_color_cicp(): Cicp | null
            /**
             * Duration to show frame for animations.
             *
             * If the value is zero, the image is not animated.
             * @since 2.0
             * @returns Duration in microseconds.
             */
            get_delay(): number
            /**
             * Height for image data in pixels
             * @since 2.0
             * @returns Height in pixels
             */
            get_height(): number
            /**
             * Format of the image data in [method@Gly.Frame.get_buf_bytes]
             * @since 2.0
             * @returns Format of image data
             */
            get_memory_format(): MemoryFormat
            /**
             * Width of a row for image data in bytes
             * @since 2.0
             * @returns Row stride in bytes
             */
            get_stride(): number
            /**
             * Width for image data in pixels
             * @since 2.0
             * @returns Width in pixels
             */
            get_width(): number
        }

        interface FrameClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Frame>
            readonly prototype: Frame
            new (props?: Partial<GObject.ConstructorProps<Frame>>): Frame
        }

        const Frame: FrameClass
        

        namespace FrameRequest {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "loop-animation": boolean
                "scale-height": number
                "scale-width": number
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "loop-animation": boolean
                "scale-height": number
                "scale-width": number
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * Defines which parts of an image to load.
         *
         * ::: warning
         *     Loaders can and frequently will ignore instructions set in
         *     `GlyFrameRequest`. The reason is that for most loaders
         *     many instructions don't have a meaningful interpretation.
         * @since 2.0
         */
        interface FrameRequest extends GObject.Object {
            readonly $signals: FrameRequest.SignalSignatures
            readonly $readableProperties: FrameRequest.ReadableProperties
            readonly $writableProperties: FrameRequest.WritableProperties
            readonly $constructOnlyProperties: FrameRequest.ConstructOnlyProperties
            /**
             * @default FALSE
             */
            get loopAnimation(): boolean
            set loopAnimation(value: boolean)
            /**
             * @default 0
             */
            get scaleHeight(): number
            set scaleHeight(value: number)
            /**
             * @default 0
             */
            get scaleWidth(): number
            set scaleWidth(value: number)
            /**
             * Controls if first frame is returned after last frame
             *
             * By default, this option is set to `TRUE`, returning the first frame, if
             * the previously requested frame was the last frame.
             * @since 2.0.1
             * @param loop_animation
             */
            set_loop_animation(loop_animation: boolean): void
            /**
             * Set maximum dimensions for the frame. The texture will be scaled
             * to be within the maximum dimensions while keeping its aspect ratio.
             * This option is especially useful to SVGs which will be rendered at
             * the respective size.
             *
             * ::: warning
             *     Most loaders will ignore this option. Currently, only the SVG
             *     loader is known to obey it.
             * @since 2.0
             * @param width Maximum width
             * @param height Maximum height
             */
            set_scale(width: number, height: number): void
        }

        interface FrameRequestClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<FrameRequest>
            readonly prototype: FrameRequest
            new (props?: Partial<GObject.ConstructorProps<FrameRequest>>): FrameRequest
            /**
             * Creates a new frame request.
             * @since 2.0
             * @returns a new [class@FrameRequest]
             */
            "new"(): FrameRequest
        }

        const FrameRequest: FrameRequestClass
        

        namespace Image {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * Image handle containing metadata and allowing frame requests.
         * @since 2.0
         */
        interface Image extends GObject.Object {
            readonly $signals: Image.SignalSignatures
            readonly $readableProperties: Image.ReadableProperties
            readonly $writableProperties: Image.WritableProperties
            readonly $constructOnlyProperties: Image.ConstructOnlyProperties
            /**
             * See [method@Image.get_width]
             * @since 2.0
             * @returns height
             */
            get_height(): number
            /**
             * Get metadata that are stored as key-value pairs.
             * A prominent example are PNG's `tEXt` and `zTXt` chunks.
             *
             * ::: note
             *     In contrast to gdk-pixbuf's *option* feature, the
             *     keys do not carry prefixes like `tEXt::` or `zTXt::`.
             * @since 2.0
             * @param key A null-terminated string.
             * @returns The UTF-8 encoded value associated with `key`.
             */
            get_metadata_key_value(key: string): string | null
            /**
             * Get the list of available keys for [method@Image.get_metadata_key_value].
             * @since 2.0
             * @returns List of existing keys.
             */
            get_metadata_keys(): string[]
            /**
             * Returns detected MIME type of the file
             * @since 2.0
             * @returns MIME type
             */
            get_mime_type(): string
            /**
             * @throws {GLib.Error}
             * @since 2.0
             * @param frame_request
             * @returns Loaded frame.
             */
            get_specific_frame(frame_request: FrameRequest): Frame
            /**
             * Asynchronous version of [method@Image.get_specific_frame].
             * @since 2.0
             * @param frame_request
             * @param cancellable A [class@Gio.Cancellable] to cancel the operation
             * @param callback A callback to call when the operation is complete
             */
            get_specific_frame_async(frame_request: FrameRequest, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Finishes the [method@Image.get_specific_frame_async] call.
             * @throws {GLib.Error}
             * @since 2.0
             * @param result a `GAsyncResult`
             * @returns Loaded frame.
             */
            get_specific_frame_finish(result: Gio.AsyncResult): Frame
            /**
             * Get the image orientation
             *
             * The image orientation is given in Exif format. The function is
             * guaranteed to only return values from 1 to 8.
             *
             * If [method@Loader.set_apply_transformations] is set to `FALSE`,
             * the orientation has to be corrected manually to display the image
             * correctly.
             * @since 2.0
             */
            get_transformation_orientation(): number
            /**
             * Early width information.
             *
             * This information is often correct. However, it should only be used for
             * an early rendering estimates. For everything else, the specific frame
             * information should be used. See [method@Frame.get_width].
             * @since 2.0
             * @returns Width
             */
            get_width(): number
            /**
             * Synchronously loads texture and information of the next frame.
             *
             * For single still images, this can only be called once.
             * For animated images, this function will loop to the first frame, when the last frame is reached.
             * @throws {GLib.Error}
             * @since 2.0
             * @returns a new [class@Frame] on success, or `NULL` with `error` filled in
             */
            next_frame(): Frame
            /**
             * Asynchronous version of [method@Image.next_frame].
             * @since 2.0
             * @param cancellable A [class@Gio.Cancellable] to cancel the operation
             * @param callback A callback to call when the operation is complete
             */
            next_frame_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Finishes the [method@Image.next_frame_async] call.
             * @throws {GLib.Error}
             * @since 2.0
             * @param result a `GAsyncResult`
             * @returns Loaded frame.
             */
            next_frame_finish(result: Gio.AsyncResult): Frame
        }

        interface ImageClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Image>
            readonly prototype: Image
            new (props?: Partial<GObject.ConstructorProps<Image>>): Image
        }

        const Image: ImageClass
        

        namespace Loader {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "apply-transformation": boolean
                "bytes": GLib.Bytes
                "cancellable": Gio.Cancellable
                "file": Gio.File
                "memory-format-selection": MemoryFormatSelection
                "sandbox-selector": SandboxSelector
                "stream": Gio.InputStream
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "apply-transformation": boolean
                "bytes": GLib.Bytes
                "cancellable": Gio.Cancellable
                "file": Gio.File
                "memory-format-selection": MemoryFormatSelection
                "sandbox-selector": SandboxSelector
                "stream": Gio.InputStream
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         *
         *
         * file = g_file_new_for_path ("test.png");
         * loader = gly_loader_new (file);
         * image = gly_loader_load (loader, NULL);
         * if (image)
         *   {
         *     frame = gly_image_next_frame (image, NULL);
         *     if (frame)
         *       {
         *         texture = gly_gtk_frame_get_texture (frame);
         *         g_print ("Image height: %d\n", gdk_texture_get_height (texture));
         *         image_widget = gtk_image_new_from_paintable (GDK_PAINTABLE (texture));
         *       }
         *   }
         * ```
         * @since 2.0
         */
        interface Loader extends GObject.Object {
            readonly $signals: Loader.SignalSignatures
            readonly $readableProperties: Loader.ReadableProperties
            readonly $writableProperties: Loader.WritableProperties
            readonly $constructOnlyProperties: Loader.ConstructOnlyProperties
            /**
             * @default FALSE
             */
            get applyTransformation(): boolean
            set applyTransformation(value: boolean)
            /**
             */
            get bytes(): GLib.Bytes
            set bytes(value: GLib.Bytes)
            /**
             */
            get cancellable(): Gio.Cancellable
            set cancellable(value: Gio.Cancellable)
            /**
             */
            get file(): Gio.File
            set file(value: Gio.File)
            /**
             * @default 0
             */
            get memoryFormatSelection(): MemoryFormatSelection
            set memoryFormatSelection(value: MemoryFormatSelection)
            /**
             * @default Auto
             */
            get sandboxSelector(): SandboxSelector
            set sandboxSelector(value: SandboxSelector)
            /**
             */
            get stream(): Gio.InputStream
            set stream(value: Gio.InputStream)
            /**
             * Synchronously loads an image and returns an [class@Image] when successful.
             * @throws {GLib.Error}
             * @since 2.0
             * @returns a new [class@Image] on success, or `NULL` with `error` filled in
             */
            load(): Image
            /**
             * Asynchronous version of [method@Loader.load].
             * @since 2.0
             * @param cancellable A [class@Gio.Cancellable] to cancel the operation
             * @param callback A callback to call when the operation is complete
             */
            load_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Finishes the [method@Loader.load_async] call.
             * @throws {GLib.Error}
             * @since 2.0
             * @param result A `GAsyncResult`
             * @returns Loaded image.
             */
            load_finish(result: Gio.AsyncResult): Image
            /**
             * Sets which memory formats can be returned by the loader
             *
             * If the memory format doesn't match one of the selected formats, the
             * format will be transformed into the best suitable format selected.
             * @since 2.0
             * @param memory_format_selection Accepted memory formats
             */
            set_accepted_memory_formats(memory_format_selection: MemoryFormatSelection): void
            /**
             * Set whether to apply transformations to texture
             *
             * When enabled, transformations like image orientation are applied to the
             * texture data.
             *
             * This option is enabled by default.
             * @since 2.0
             * @param apply_transformations
             */
            set_apply_transformations(apply_transformations: boolean): void
            /**
             * Selects which sandbox mechanism should be used. The default without calling this function is [enum@SandboxSelector]`.AUTO`.
             * @since 2.0
             * @param sandbox_selector Method by which the sandbox mechanism is selected
             */
            set_sandbox_selector(sandbox_selector: SandboxSelector): void
        }

        interface LoaderClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Loader>
            readonly prototype: Loader
            new (props?: Partial<GObject.ConstructorProps<Loader>>): Loader
            /**
             * Creates a new loader for a file.
             * @since 2.0
             * @param file A file from which to load the image data
             * @returns a new [class@Loader]
             */
            "new"(file: Gio.File): Loader
            /**
             * Creates a new loader for bytes.
             * @since 2.0
             * @param bytes Data from which to load the image
             * @returns a new [class@Loader]
             */
            new_for_bytes(bytes: GLib.Bytes): Loader
            /**
             * Creates a new loader for a stream.
             * @since 2.0
             * @param stream A stream from which to load the image data
             * @returns a new [class@Loader]
             */
            new_for_stream(stream: Gio.InputStream): Loader
            /**
             * Returns a list of MIME types currently supported for loading images.
             *
             * This list is generated from the config on first use of a loader or
             * call of this function and cached afterwards. Hence, the first call
             * can be blocking.
             * @since 2.0
             * @returns List of supported MIME types
             */
            get_mime_types(): string[]
            /**
             * Async variant of [func@Loader.get_mime_types]
             * @since 2.0
             * @param cancellable
             * @param callback
             */
            get_mime_types_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
            /**
             * Finishes the [func@Loader.get_mime_types_async] call.
             * @throws {GLib.Error}
             * @since 2.0
             * @param result A `GAsyncResult`
             * @returns Mime types.
             */
            get_mime_types_finish(result: Gio.AsyncResult): string[]
        }

        const Loader: LoaderClass
        

        namespace NewFrame {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * New frame
         * @since 2.0
         */
        interface NewFrame extends GObject.Object {
            readonly $signals: NewFrame.SignalSignatures
            readonly $readableProperties: NewFrame.ReadableProperties
            readonly $writableProperties: NewFrame.WritableProperties
            readonly $constructOnlyProperties: NewFrame.ConstructOnlyProperties
            /**
             * @since 2.0
             * @param icc_profile ICC profile
             * @returns `TRUE` if format supports ICC color profiles.
             */
            set_color_icc_profile(icc_profile: GLib.Bytes): boolean
        }

        interface NewFrameClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<NewFrame>
            readonly prototype: NewFrame
            new (props?: Partial<GObject.ConstructorProps<NewFrame>>): NewFrame
        }

        const NewFrame: NewFrameClass
        /**
         * See ITU-T H.273
         * @since 2.0
         */
        abstract class Cicp {
            static readonly $gtype: GObject.GType<Cicp>

            
            /**
             */
            color_primaries: number
            /**
             */
            transfer_characteristics: number
            /**
             */
            matrix_coefficients: number
            /**
             */
            video_full_range_flag: number
            /**
             */
            copy(): Cicp
            /**
             */
            free(): void
        }
        none
        none
        none
        none
        none
        none
        none
        /**
         * Error quark for [error@GlyLoaderError]
         * @returns The error domain
         */
        function loader_error_quark(): GLib.Quark
        /**
         * Whether a memory format has an alpha channel
         * @since 2.0
         * @param memory_format
         * @returns Returns `TRUE` if the memory format has an alpha channel
         */
        function memory_format_has_alpha(memory_format: MemoryFormat): boolean
        /**
         * Whether a memory format has an alpha channel and the color values are
         * premultiplied with the alpha value
         * @since 2.0
         * @param memory_format
         * @returns Returns `TRUE` if color channels are premultiplied
         */
        function memory_format_is_premultiplied(memory_format: MemoryFormat): boolean
        
        abstract class LoaderError extends GLib.Error {
            static readonly $gtype: GObject.GType<LoaderError>
            /**
             * Generic type for all other errors.
             * @since 2.0
             */
            static readonly "FAILED": 0
            /**
             * Unknown image format.
             * @since 2.0
             */
            static readonly "UNKNOWN_IMAGE_FORMAT": 1
            /**
             * Reached last frame in an animation with [method@FrameRequest.set_loop_animation] to `FALSE`.
             * @since 2.0.1
             */
            static readonly "NO_MORE_FRAMES": 2
        }
        /**
         * Error quark for [error@GlyLoaderError]
         * @returns The error domain
         */
        function quark(): GLib.Quark
        
        namespace MemoryFormat {
            const $gtype: GObject.GType<MemoryFormat>
        }

        /**
         * Memory format
         * @since 2.0
         */
        enum MemoryFormat {
            /**
             * 8-bit RGRA premultiplied
             */
            "B8G8R8A8_PREMULTIPLIED" = 0,
            /**
             * 8-bit ARGB premultiplied
             */
            "A8R8G8B8_PREMULTIPLIED" = 1,
            /**
             * 8-bit RGBA premultiplied
             */
            "R8G8B8A8_PREMULTIPLIED" = 2,
            /**
             * 8-bit RGBA
             */
            "B8G8R8A8" = 3,
            /**
             * 8-bit AGBR
             */
            "A8R8G8B8" = 4,
            /**
             * 8-bit RGBA
             */
            "R8G8B8A8" = 5,
            /**
             * 8-bit ABGR
             */
            "A8B8G8R8" = 6,
            /**
             * 8-bit RGB
             */
            "R8G8B8" = 7,
            /**
             * 8-bit BGR
             */
            "B8G8R8" = 8,
            /**
             * 16-bit RGB
             */
            "R16G16B16" = 9,
            /**
             * 16-bit RGBA premultiplied
             */
            "R16G16B16A16_PREMULTIPLIED" = 10,
            /**
             * 16-bit RGBA
             */
            "R16G16B16A16" = 11,
            /**
             * 16-bit float RGB
             */
            "R16G16B16_FLOAT" = 12,
            /**
             * 16-bit float RGBA
             */
            "R16G16B16A16_FLOAT" = 13,
            /**
             * 32-bit float RGB
             */
            "R32G32B32_FLOAT" = 14,
            /**
             * 32-bit float RGBA premultiplied
             */
            "R32G32B32A32_FLOAT_PREMULTIPLIED" = 15,
            /**
             * 16-bit float RGBA
             */
            "R32G32B32A32_FLOAT" = 16,
            /**
             * 8-bit gray with alpha premultiplied
             */
            "G8A8_PREMULTIPLIED" = 17,
            /**
             * 8-bit gray with alpha
             */
            "G8A8" = 18,
            /**
             * 8-bit gray
             */
            "G8" = 19,
            /**
             * 16-bit gray with alpha premultiplied
             */
            "G16A16_PREMULTIPLIED" = 20,
            /**
             * 16-bit gray with alpha
             */
            "G16A16" = 21,
            /**
             * 16-bit gray
             */
            "G16" = 22,
        }
        /**
         * Whether a memory format has an alpha channel
         * @since 2.0
         * @param memory_format
         * @returns Returns `TRUE` if the memory format has an alpha channel
         */
        function has_alpha(memory_format: MemoryFormat): boolean
        /**
         * Whether a memory format has an alpha channel and the color values are
         * premultiplied with the alpha value
         * @since 2.0
         * @param memory_format
         * @returns Returns `TRUE` if color channels are premultiplied
         */
        function is_premultiplied(memory_format: MemoryFormat): boolean
        
        namespace SandboxSelector {
            const $gtype: GObject.GType<SandboxSelector>
        }

        /**
         * Sandbox mechanisms
         *
         * ::: warning
         *     Using @GLY_SANDBOX_SELECTOR_NOT_SANDBOXED will disable an important security layer that sandboxes loaders. It is only intended for testing and development purposes.
         * @since 2.0
         */
        enum SandboxSelector {
            /**
             * This mode selects `bwrap` outside of Flatpaks and usually
             *  `flatpak-spawn` inside of Flatpaks. The sandbox is disabled
             *  automatically inside of Flatpak development environments.
             *  Inside of Flatpaks, `flatpak-spawn` is used to create the sandbox. This
             *  mechanism starts an installed Flatpak with the same app id. For
             *  development, Flatpak are usually not installed and the sandbox can
             *  therefore not be used. If the sandbox has been started via
             *  `flatpak-builder --run` (i.e. without installed Flatpak) and the app id
             *  ends with `Devel`, the sandbox is disabled.
             */
            "AUTO" = 0,
            /**
             * bwrap
             */
            "BWRAP" = 1,
            /**
             * flatpak-spawn
             */
            "FLATPAK_SPAWN" = 2,
            /**
             * Disable sandbox. Unsafe, only use for testing and development.
             */
            "NOT_SANDBOXED" = 3,
        }
        
        namespace MemoryFormatSelection {
            const $gtype: GObject.GType<MemoryFormatSelection>
        }

        /**
         * Memory format selection
         * @since 2.0
         */
        enum MemoryFormatSelection {
            /**
             * 8-bit BGRA premultiplied
             */
            "B8G8R8A8_PREMULTIPLIED" = 1,
            /**
             * 8-bit ARGB premultiplied
             */
            "A8R8G8B8_PREMULTIPLIED" = 2,
            /**
             * 8-bit RGBA premultiplied
             */
            "R8G8B8A8_PREMULTIPLIED" = 4,
            /**
             * 8-bit BGRA
             */
            "B8G8R8A8" = 8,
            /**
             * 8-bit ARGB
             */
            "A8R8G8B8" = 16,
            /**
             * 8-bit RGBA
             */
            "R8G8B8A8" = 32,
            /**
             * 8-bit ABGR
             */
            "A8B8G8R8" = 64,
            /**
             * 8-bit RGB
             */
            "R8G8B8" = 128,
            /**
             * 8-bit BGR
             */
            "B8G8R8" = 256,
            /**
             * 16-bit RGB
             */
            "R16G16B16" = 512,
            /**
             * 16-bit RGBA premultiplied
             */
            "R16G16B16A16_PREMULTIPLIED" = 1024,
            /**
             * 16-bit RGBA
             */
            "R16G16B16A16" = 2048,
            /**
             * 16-bit float RGB
             */
            "R16G16B16_FLOAT" = 4096,
            /**
             * 16-bit float RGBA
             */
            "R16G16B16A16_FLOAT" = 8192,
            /**
             * 32-bit float RGB
             */
            "R32G32B32_FLOAT" = 16384,
            /**
             * 32-bit float RGBA premultiplied
             */
            "R32G32B32A32_FLOAT_PREMULTIPLIED" = 32768,
            /**
             * 16-bit float RGBA
             */
            "R32G32B32A32_FLOAT" = 65536,
            /**
             * 8-bit gray with alpha premultiplied
             */
            "G8A8_PREMULTIPLIED" = 131072,
            /**
             * 8-bit gray with alpha
             */
            "G8A8" = 262144,
            /**
             * 8-bit gray
             */
            "G8" = 524288,
            /**
             * 16-bit gray with alpha premultiplied
             */
            "G16A16_PREMULTIPLIED" = 1048576,
            /**
             * 16-bit gray with alpha
             */
            "G16A16" = 2097152,
            /**
             * 16-bit gray
             */
            "G16" = 4194304,
        }
        /**
         * @param mime_types
         * @param data
         */
        type LoaderGetMimeTypesDoneFunc = (mime_types: string[], data: never | null) => void
    }

    export default Gly
}