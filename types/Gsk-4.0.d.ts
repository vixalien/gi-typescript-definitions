
/// <reference path="./GLib-2.0.d.ts" />
/// <reference path="./GModule-2.0.d.ts" />
/// <reference path="./GObject-2.0.d.ts" />
/// <reference path="./Gio-2.0.d.ts" />
/// <reference path="./freetype2-2.0.d.ts" />
/// <reference path="./HarfBuzz-0.0.d.ts" />
/// <reference path="./cairo-1.0.d.ts" />
/// <reference path="./Pango-1.0.d.ts" />
/// <reference path="./GdkPixbuf-2.0.d.ts" />
/// <reference path="./PangoCairo-1.0.d.ts" />
/// <reference path="./Gdk-4.0.d.ts" />
/// <reference path="./Graphene-1.0.d.ts" />

/**
 * Type Definitions for GJS (https://gjs.guide/), generated by [GirGen](https://github.com/aylur/girgen)
 * If you found a bug, create a bug report on [GirGen's Repository](https://github.com/aylur/girgen/issues/new)
 */
declare module "gi://Gsk?version=4.0" {
    import type GLib from "gi://GLib?version=2.0"
    import type GModule from "gi://GModule?version=2.0"
    import type GObject from "gi://GObject?version=2.0"
    import type Gio from "gi://Gio?version=2.0"
    import type freetype2 from "gi://freetype2?version=2.0"
    import type HarfBuzz from "gi://HarfBuzz?version=0.0"
    import type cairo from "gi://cairo?version=1.0"
    import type Pango from "gi://Pango?version=1.0"
    import type GdkPixbuf from "gi://GdkPixbuf?version=2.0"
    import type PangoCairo from "gi://PangoCairo?version=1.0"
    import type Gdk from "gi://Gdk?version=4.0"
    import type Graphene from "gi://Graphene?version=1.0"

    


    namespace Gsk {
        const __name__: "Gsk"
        const __version: "4.0"
        

        namespace BlendNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node applying a blending function between its two child nodes.
         */
        interface BlendNode extends RenderNode {
            readonly $signals: BlendNode.SignalSignatures
            readonly $readableProperties: BlendNode.ReadableProperties
            readonly $writableProperties: BlendNode.WritableProperties
            readonly $constructOnlyProperties: BlendNode.ConstructOnlyProperties
            /**
             * Retrieves the blend mode used by @node.
             * @returns the blend mode
             */
            get_blend_mode(): BlendMode
            /**
             * Retrieves the bottom `GskRenderNode` child of the @node.
             * @returns the bottom child node
             */
            get_bottom_child(): RenderNode
            /**
             * Retrieves the top `GskRenderNode` child of the @node.
             * @returns the top child node
             */
            get_top_child(): RenderNode
        }

        interface BlendNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<BlendNode>
            readonly prototype: BlendNode
            new (props?: Partial<GObject.ConstructorProps<BlendNode>>): BlendNode
            /**
             * Creates a `GskRenderNode` that will use @blend_mode to blend the @top
             * node onto the @bottom node.
             * @param bottom The bottom node to be drawn
             * @param top The node to be blended onto the @bottom node
             * @param blend_mode The blend mode to use
             * @returns A new `GskRenderNode`
             */
            "new"(bottom: RenderNode, top: RenderNode, blend_mode: BlendMode): BlendNode
        }

        const BlendNode: BlendNodeClass
        

        namespace BlurNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node applying a blur effect to its single child.
         */
        interface BlurNode extends RenderNode {
            readonly $signals: BlurNode.SignalSignatures
            readonly $readableProperties: BlurNode.ReadableProperties
            readonly $writableProperties: BlurNode.WritableProperties
            readonly $constructOnlyProperties: BlurNode.ConstructOnlyProperties
            /**
             * Retrieves the child `GskRenderNode` of the blur @node.
             * @returns the blurred child node
             */
            get_child(): RenderNode
            /**
             * Retrieves the blur radius of the @node.
             * @returns the blur radius
             */
            get_radius(): number
        }

        interface BlurNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<BlurNode>
            readonly prototype: BlurNode
            new (props?: Partial<GObject.ConstructorProps<BlurNode>>): BlurNode
            /**
             * Creates a render node that blurs the child.
             * @param child the child node to blur
             * @param radius the blur radius. Must be positive
             * @returns a new `GskRenderNode`
             */
            "new"(child: RenderNode, radius: number): BlurNode
        }

        const BlurNode: BlurNodeClass
        

        namespace BorderNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node for a border.
         */
        interface BorderNode extends RenderNode {
            readonly $signals: BorderNode.SignalSignatures
            readonly $readableProperties: BorderNode.ReadableProperties
            readonly $writableProperties: BorderNode.WritableProperties
            readonly $constructOnlyProperties: BorderNode.ConstructOnlyProperties
            /**
             * Retrieves the colors of the border.
             * @returns an array of 4 `GdkRGBA`   structs for the top, right, bottom and left color of the border
             */
            get_colors(): Gdk.RGBA[]
            /**
             * Retrieves the outline of the border.
             * @returns the outline of the border
             */
            get_outline(): RoundedRect
            /**
             * Retrieves the stroke widths of the border.
             * @returns an array of 4 floats   for the top, right, bottom and left stroke width of the border,   respectively
             */
            get_widths(): number[]
        }

        interface BorderNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<BorderNode>
            readonly prototype: BorderNode
            new (props?: Partial<GObject.ConstructorProps<BorderNode>>): BorderNode
            /**
             * Creates a `GskRenderNode` that will stroke a border rectangle inside the
             * given @outline.
             *
             * The 4 sides of the border can have different widths and colors.
             * @param outline a `GskRoundedRect` describing the outline of the border
             * @param border_width the stroke width of the border on
                the top, right, bottom and left side respectively.
             * @param border_color the color used on the top, right,
                bottom and left side.
             * @returns A new `GskRenderNode`
             */
            "new"(outline: RoundedRect, border_width: number[], border_color: Gdk.RGBA[]): BorderNode
        }

        const BorderNode: BorderNodeClass
        

        namespace BroadwayRenderer {
            interface SignalSignatures extends Renderer.SignalSignatures {
            }

            interface ReadableProperties extends Renderer.ReadableProperties {
            }

            interface WritableProperties extends Renderer.WritableProperties {
            }

            interface ConstructOnlyProperties extends Renderer.ConstructOnlyProperties {
            }
        }

        /**
         * A Broadway based renderer.
         *
         * See [class@Gsk.Renderer].
         */
        interface BroadwayRenderer extends Renderer {
            readonly $signals: BroadwayRenderer.SignalSignatures
            readonly $readableProperties: BroadwayRenderer.ReadableProperties
            readonly $writableProperties: BroadwayRenderer.WritableProperties
            readonly $constructOnlyProperties: BroadwayRenderer.ConstructOnlyProperties
        }

        interface BroadwayRendererClass extends Omit<RendererClass, "new"> {
            readonly $gtype: GObject.GType<BroadwayRenderer>
            readonly prototype: BroadwayRenderer
            new (props?: Partial<GObject.ConstructorProps<BroadwayRenderer>>): BroadwayRenderer
            /**
             * Creates a new Broadway renderer.
             *
             * The Broadway renderer is the default renderer for the broadway backend.
             * It will only work with broadway surfaces, otherwise it will fail the
             * call to gsk_renderer_realize().
             *
             * This function is only available when GTK was compiled with Broadway
             * support.
             * @deprecated since 4.20 Broadway will be retired in GTK 5
             * @returns a new Broadway renderer.
             */
            "new"(): BroadwayRenderer
        }

        const BroadwayRenderer: BroadwayRendererClass
        

        namespace CairoNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node for a Cairo surface.
         */
        interface CairoNode extends RenderNode {
            readonly $signals: CairoNode.SignalSignatures
            readonly $readableProperties: CairoNode.ReadableProperties
            readonly $writableProperties: CairoNode.WritableProperties
            readonly $constructOnlyProperties: CairoNode.ConstructOnlyProperties
            /**
             * Creates a Cairo context for drawing using the surface associated
             * to the render node.
             *
             * If no surface exists yet, a surface will be created optimized for
             * rendering to @renderer.
             * @returns a Cairo context used for drawing; use   cairo_destroy() when done drawing
             */
            get_draw_context(): cairo.Context
            /**
             * Retrieves the Cairo surface used by the render node.
             * @returns a Cairo surface
             */
            get_surface(): cairo.Surface
        }

        interface CairoNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<CairoNode>
            readonly prototype: CairoNode
            new (props?: Partial<GObject.ConstructorProps<CairoNode>>): CairoNode
            /**
             * Creates a `GskRenderNode` that will render a cairo surface
             * into the area given by @bounds.
             *
             * You can draw to the cairo surface using [method@Gsk.CairoNode.get_draw_context].
             * @param bounds the rectangle to render to
             * @returns A new `GskRenderNode`
             */
            "new"(bounds: Graphene.Rect): CairoNode
        }

        const CairoNode: CairoNodeClass
        

        namespace CairoRenderer {
            interface SignalSignatures extends Renderer.SignalSignatures {
            }

            interface ReadableProperties extends Renderer.ReadableProperties {
            }

            interface WritableProperties extends Renderer.WritableProperties {
            }

            interface ConstructOnlyProperties extends Renderer.ConstructOnlyProperties {
            }
        }

        /**
         * Renders a GSK rendernode tree with cairo.
         *
         * Since it is using cairo, this renderer cannot support
         * 3D transformations.
         */
        interface CairoRenderer extends Renderer {
            readonly $signals: CairoRenderer.SignalSignatures
            readonly $readableProperties: CairoRenderer.ReadableProperties
            readonly $writableProperties: CairoRenderer.WritableProperties
            readonly $constructOnlyProperties: CairoRenderer.ConstructOnlyProperties
        }

        interface CairoRendererClass extends Omit<RendererClass, "new"> {
            readonly $gtype: GObject.GType<CairoRenderer>
            readonly prototype: CairoRenderer
            new (props?: Partial<GObject.ConstructorProps<CairoRenderer>>): CairoRenderer
            /**
             * Creates a new Cairo renderer.
             *
             * The Cairo renderer is the fallback renderer drawing in ways similar
             * to how GTK 3 drew its content. Its primary use is as comparison tool.
             *
             * The Cairo renderer is incomplete. It cannot render 3D transformed
             * content and will instead render an error marker. Its usage should be
             * avoided.
             * @returns a new Cairo renderer.
             */
            "new"(): CairoRenderer
        }

        const CairoRenderer: CairoRendererClass
        

        namespace ClipNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node applying a rectangular clip to its single child node.
         */
        interface ClipNode extends RenderNode {
            readonly $signals: ClipNode.SignalSignatures
            readonly $readableProperties: ClipNode.ReadableProperties
            readonly $writableProperties: ClipNode.WritableProperties
            readonly $constructOnlyProperties: ClipNode.ConstructOnlyProperties
            /**
             * Gets the child node that is getting clipped by the given @node.
             * @returns The child that is getting clipped
             */
            get_child(): RenderNode
            /**
             * Retrieves the clip rectangle for @node.
             * @returns a clip rectangle
             */
            get_clip(): Graphene.Rect
        }

        interface ClipNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<ClipNode>
            readonly prototype: ClipNode
            new (props?: Partial<GObject.ConstructorProps<ClipNode>>): ClipNode
            /**
             * Creates a `GskRenderNode` that will clip the @child to the area
             * given by @clip.
             * @param child The node to draw
             * @param clip The clip to apply
             * @returns A new `GskRenderNode`
             */
            "new"(child: RenderNode, clip: Graphene.Rect): ClipNode
        }

        const ClipNode: ClipNodeClass
        

        namespace ColorMatrixNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node controlling the color matrix of its single child node.
         */
        interface ColorMatrixNode extends RenderNode {
            readonly $signals: ColorMatrixNode.SignalSignatures
            readonly $readableProperties: ColorMatrixNode.ReadableProperties
            readonly $writableProperties: ColorMatrixNode.WritableProperties
            readonly $constructOnlyProperties: ColorMatrixNode.ConstructOnlyProperties
            /**
             * Gets the child node that is getting its colors modified by the given @node.
             * @returns The child that is getting its colors modified
             */
            get_child(): RenderNode
            /**
             * Retrieves the color matrix used by the @node.
             * @returns a 4x4 color matrix
             */
            get_color_matrix(): Graphene.Matrix
            /**
             * Retrieves the color offset used by the @node.
             * @returns a color vector
             */
            get_color_offset(): Graphene.Vec4
        }

        interface ColorMatrixNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<ColorMatrixNode>
            readonly prototype: ColorMatrixNode
            new (props?: Partial<GObject.ConstructorProps<ColorMatrixNode>>): ColorMatrixNode
            /**
             * Creates a `GskRenderNode` that will drawn the @child with
             * @color_matrix.
             *
             * In particular, the node will transform colors by applying
             *
             *     pixel = transpose(color_matrix) * pixel + color_offset
             *
             * for every pixel. The transformation operates on unpremultiplied
             * colors, with color components ordered R, G, B, A.
             * @param child The node to draw
             * @param color_matrix The matrix to apply
             * @param color_offset Values to add to the color
             * @returns A new `GskRenderNode`
             */
            "new"(child: RenderNode, color_matrix: Graphene.Matrix, color_offset: Graphene.Vec4): ColorMatrixNode
        }

        const ColorMatrixNode: ColorMatrixNodeClass
        

        namespace ColorNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node for a solid color.
         */
        interface ColorNode extends RenderNode {
            readonly $signals: ColorNode.SignalSignatures
            readonly $readableProperties: ColorNode.ReadableProperties
            readonly $writableProperties: ColorNode.WritableProperties
            readonly $constructOnlyProperties: ColorNode.ConstructOnlyProperties
            /**
             * Retrieves the color of the given @node.
             *
             * The value returned by this function will not be correct
             * if the render node was created for a non-sRGB color.
             * @returns the color of the node
             */
            get_color(): Gdk.RGBA
        }

        interface ColorNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<ColorNode>
            readonly prototype: ColorNode
            new (props?: Partial<GObject.ConstructorProps<ColorNode>>): ColorNode
            /**
             * Creates a `GskRenderNode` that will render the color specified by @rgba into
             * the area given by @bounds.
             * @param rgba a `GdkRGBA` specifying a color
             * @param bounds the rectangle to render the color into
             * @returns A new `GskRenderNode`
             */
            "new"(rgba: Gdk.RGBA, bounds: Graphene.Rect): ColorNode
        }

        const ColorNode: ColorNodeClass
        

        namespace ComponentTransferNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node for applying a `GskComponentTransfer` for each color
         * component of the child node.
         * @since 4.20
         */
        interface ComponentTransferNode extends RenderNode {
            readonly $signals: ComponentTransferNode.SignalSignatures
            readonly $readableProperties: ComponentTransferNode.ReadableProperties
            readonly $writableProperties: ComponentTransferNode.WritableProperties
            readonly $constructOnlyProperties: ComponentTransferNode.ConstructOnlyProperties
            /**
             * Gets the child node that is getting drawn by the given @node.
             * @since 4.20
             * @returns the child `GskRenderNode`
             */
            get_child(): RenderNode
            /**
             * Gets the component transfer for one of the components.
             * @since 4.20
             * @param component the component to get the transfer for
             * @returns the `GskComponentTransfer`
             */
            get_transfer(component: Gdk.ColorChannel): ComponentTransfer
        }

        interface ComponentTransferNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<ComponentTransferNode>
            readonly prototype: ComponentTransferNode
            new (props?: Partial<GObject.ConstructorProps<ComponentTransferNode>>): ComponentTransferNode
            /**
             * Creates a render node that will apply component
             * transfers to a child node.
             * @since 4.20
             * @param child The child to apply component transfers to
             * @param r transfer for the red component
             * @param g transfer for the green component
             * @param b transfer for the blue component
             * @param a transfer for the alpha component
             * @returns A new `GskRenderNode`
             */
            "new"(child: RenderNode, r: ComponentTransfer, g: ComponentTransfer, b: ComponentTransfer, a: ComponentTransfer): ComponentTransferNode
        }

        const ComponentTransferNode: ComponentTransferNodeClass
        

        namespace CompositeNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node that uses Porter/Duff compositing operators to combine
         * its child with the background.
         * @since 4.22
         */
        interface CompositeNode extends RenderNode {
            readonly $signals: CompositeNode.SignalSignatures
            readonly $readableProperties: CompositeNode.ReadableProperties
            readonly $writableProperties: CompositeNode.WritableProperties
            readonly $constructOnlyProperties: CompositeNode.ConstructOnlyProperties
            /**
             * Gets the child node that is getting composited by the given @node.
             * @since 4.22
             * @returns the child `GskRenderNode`
             */
            get_child(): RenderNode
            /**
             * Gets the mask node that describes the region where the compositing
             * applies.
             * @since 4.22
             * @returns the mask `GskRenderNode`
             */
            get_mask(): RenderNode
            /**
             * Gets the compositing operator used by this node.
             * @since 4.22
             * @returns The compositing operator
             */
            get_operator(): PorterDuff
        }

        interface CompositeNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<CompositeNode>
            readonly prototype: CompositeNode
            new (props?: Partial<GObject.ConstructorProps<CompositeNode>>): CompositeNode
            /**
             * Creates a `GskRenderNode` that will composite the child onto the
             * background with the given operator wherever the mask is set.
             *
             * Note that various operations can modify the background outside of
             * the child's bounds, so the mask may cause visual changes outside
             * of the child.
             * @since 4.22
             * @param child The child to composite
             * @param mask The mask where the compositing will apply
             * @param op The compositing operator
             * @returns A new `GskRenderNode`
             */
            "new"(child: RenderNode, mask: RenderNode, op: PorterDuff): CompositeNode
        }

        const CompositeNode: CompositeNodeClass
        

        namespace ConicGradientNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node for a conic gradient.
         */
        interface ConicGradientNode extends RenderNode {
            readonly $signals: ConicGradientNode.SignalSignatures
            readonly $readableProperties: ConicGradientNode.ReadableProperties
            readonly $writableProperties: ConicGradientNode.WritableProperties
            readonly $constructOnlyProperties: ConicGradientNode.ConstructOnlyProperties
            /**
             * Retrieves the angle for the gradient in radians, normalized in [0, 2 * PI].
             *
             * The angle is starting at the top and going clockwise, as expressed
             * in the css specification:
             *
             *     angle = 90 - gsk_conic_gradient_node_get_rotation()
             * @since 4.2
             * @returns the angle for the gradient
             */
            get_angle(): number
            /**
             * Retrieves the center pointer for the gradient.
             * @returns the center point for the gradient
             */
            get_center(): Graphene.Point
            /**
             * Retrieves the color stops in the gradient.
             * @returns the color stops in the gradient
             */
            get_color_stops(): ColorStop[]
            /**
             * Retrieves the number of color stops in the gradient.
             * @returns the number of color stops
             */
            get_n_color_stops(): number
            /**
             * Retrieves the rotation for the gradient in degrees.
             * @returns the rotation for the gradient
             */
            get_rotation(): number
        }

        interface ConicGradientNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<ConicGradientNode>
            readonly prototype: ConicGradientNode
            new (props?: Partial<GObject.ConstructorProps<ConicGradientNode>>): ConicGradientNode
            /**
             * Creates a `GskRenderNode` that draws a conic gradient.
             *
             * The conic gradient
             * starts around @center in the direction of @rotation. A rotation of 0 means
             * that the gradient points up. Color stops are then added clockwise.
             * @param bounds the bounds of the node
             * @param center the center of the gradient
             * @param rotation the rotation of the gradient in degrees
             * @param color_stops = 1.
             * @returns A new `GskRenderNode`
             */
            "new"(bounds: Graphene.Rect, center: Graphene.Point, rotation: number, color_stops: ColorStop[]): ConicGradientNode
        }

        const ConicGradientNode: ConicGradientNodeClass
        

        namespace ContainerNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node that can contain other render nodes.
         */
        interface ContainerNode extends RenderNode {
            readonly $signals: ContainerNode.SignalSignatures
            readonly $readableProperties: ContainerNode.ReadableProperties
            readonly $writableProperties: ContainerNode.WritableProperties
            readonly $constructOnlyProperties: ContainerNode.ConstructOnlyProperties
            /**
             * Gets one of the children of @container.
             * @param idx the position of the child to get
             * @returns the `idx`'th child of `container`
             */
            get_child(idx: number): RenderNode
            /**
             * Retrieves the number of direct children of @node.
             * @returns the number of children of the `GskRenderNode`
             */
            get_n_children(): number
        }

        interface ContainerNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<ContainerNode>
            readonly prototype: ContainerNode
            new (props?: Partial<GObject.ConstructorProps<ContainerNode>>): ContainerNode
            /**
             * Creates a new `GskRenderNode` instance for holding the given @children.
             *
             * The new node will acquire a reference to each of the children.
             * @param children The children of the node
             * @returns the new `GskRenderNode`
             */
            "new"(children: RenderNode[]): ContainerNode
        }

        const ContainerNode: ContainerNodeClass
        

        namespace CopyNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node that copies the current state of the rendering canvas
         * so a [class@Gsk.PasteNode] can draw it.
         * @since 4.22
         */
        interface CopyNode extends RenderNode {
            readonly $signals: CopyNode.SignalSignatures
            readonly $readableProperties: CopyNode.ReadableProperties
            readonly $writableProperties: CopyNode.WritableProperties
            readonly $constructOnlyProperties: CopyNode.ConstructOnlyProperties
            /**
             * Gets the child node that is getting drawn by the given @node.
             * @since 4.22
             * @returns the child `GskRenderNode`
             */
            get_child(): RenderNode
        }

        interface CopyNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<CopyNode>
            readonly prototype: CopyNode
            new (props?: Partial<GObject.ConstructorProps<CopyNode>>): CopyNode
            /**
             * Creates a `GskRenderNode` that copies the current rendering
             * canvas for playback by paste nodes that are part of the child.
             * @since 4.22
             * @param child The child
             * @returns A new `GskRenderNode`
             */
            "new"(child: RenderNode): CopyNode
        }

        const CopyNode: CopyNodeClass
        

        namespace CrossFadeNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node cross fading between two child nodes.
         */
        interface CrossFadeNode extends RenderNode {
            readonly $signals: CrossFadeNode.SignalSignatures
            readonly $readableProperties: CrossFadeNode.ReadableProperties
            readonly $writableProperties: CrossFadeNode.WritableProperties
            readonly $constructOnlyProperties: CrossFadeNode.ConstructOnlyProperties
            /**
             * Retrieves the child `GskRenderNode` at the end of the cross-fade.
             * @returns a `GskRenderNode`
             */
            get_end_child(): RenderNode
            /**
             * Retrieves the progress value of the cross fade.
             * @returns the progress value, between 0 and 1
             */
            get_progress(): number
            /**
             * Retrieves the child `GskRenderNode` at the beginning of the cross-fade.
             * @returns a `GskRenderNode`
             */
            get_start_child(): RenderNode
        }

        interface CrossFadeNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<CrossFadeNode>
            readonly prototype: CrossFadeNode
            new (props?: Partial<GObject.ConstructorProps<CrossFadeNode>>): CrossFadeNode
            /**
             * Creates a `GskRenderNode` that will do a cross-fade between @start and @end.
             * @param start The start node to be drawn
             * @param end The node to be cross_fadeed onto the @start node
             * @param progress How far the fade has progressed from start to end. The value will
                be clamped to the range [0 ... 1]
             * @returns A new `GskRenderNode`
             */
            "new"(start: RenderNode, end: RenderNode, progress: number): CrossFadeNode
        }

        const CrossFadeNode: CrossFadeNodeClass
        

        namespace DebugNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node that emits a debugging message when drawing its
         * child node.
         */
        interface DebugNode extends RenderNode {
            readonly $signals: DebugNode.SignalSignatures
            readonly $readableProperties: DebugNode.ReadableProperties
            readonly $writableProperties: DebugNode.WritableProperties
            readonly $constructOnlyProperties: DebugNode.ConstructOnlyProperties
            /**
             * Gets the child node that is getting drawn by the given @node.
             * @returns the child `GskRenderNode`
             */
            get_child(): RenderNode
            /**
             * Gets the debug message that was set on this node
             * @returns The debug message
             */
            get_message(): string
        }

        interface DebugNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<DebugNode>
            readonly prototype: DebugNode
            new (props?: Partial<GObject.ConstructorProps<DebugNode>>): DebugNode
            /**
             * Creates a `GskRenderNode` that will add debug information about
             * the given @child.
             *
             * Adding this node has no visual effect.
             * @param child The child to add debug info for
             * @param message The debug message
             * @returns A new `GskRenderNode`
             */
            "new"(child: RenderNode, message: string): DebugNode
        }

        const DebugNode: DebugNodeClass
        

        namespace FillNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node filling the area given by [struct@Gsk.Path]
         * and [enum@Gsk.FillRule] with the child node.
         * @since 4.14
         */
        interface FillNode extends RenderNode {
            readonly $signals: FillNode.SignalSignatures
            readonly $readableProperties: FillNode.ReadableProperties
            readonly $writableProperties: FillNode.WritableProperties
            readonly $constructOnlyProperties: FillNode.ConstructOnlyProperties
            /**
             * Gets the child node that is getting drawn by the given @node.
             * @since 4.14
             * @returns The child that is getting drawn
             */
            get_child(): RenderNode
            /**
             * Retrieves the fill rule used to determine how the path is filled.
             * @since 4.14
             * @returns a `GskFillRule`
             */
            get_fill_rule(): FillRule
            /**
             * Retrieves the path used to describe the area filled with the contents of
             * the @node.
             * @since 4.14
             * @returns a `GskPath`
             */
            get_path(): Path
        }

        interface FillNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<FillNode>
            readonly prototype: FillNode
            new (props?: Partial<GObject.ConstructorProps<FillNode>>): FillNode
            /**
             * Creates a `GskRenderNode` that will fill the @child in the area
             * given by @path and @fill_rule.
             * @since 4.14
             * @param child The node to fill the area with
             * @param path The path describing the area to fill
             * @param fill_rule The fill rule to use
             * @returns A new `GskRenderNode`
             */
            "new"(child: RenderNode, path: Path, fill_rule: FillRule): FillNode
        }

        const FillNode: FillNodeClass
        

        namespace GLRenderer {
            interface SignalSignatures extends Renderer.SignalSignatures {
            }

            interface ReadableProperties extends Renderer.ReadableProperties {
            }

            interface WritableProperties extends Renderer.WritableProperties {
            }

            interface ConstructOnlyProperties extends Renderer.ConstructOnlyProperties {
            }
        }

        /**
         * Renders a GSK rendernode tree with OpenGL.
         *
         * See [class@Gsk.Renderer].
         * @since 4.2
         */
        interface GLRenderer extends Renderer {
            readonly $signals: GLRenderer.SignalSignatures
            readonly $readableProperties: GLRenderer.ReadableProperties
            readonly $writableProperties: GLRenderer.WritableProperties
            readonly $constructOnlyProperties: GLRenderer.ConstructOnlyProperties
        }

        interface GLRendererClass extends Omit<RendererClass, "new"> {
            readonly $gtype: GObject.GType<GLRenderer>
            readonly prototype: GLRenderer
            new (props?: Partial<GObject.ConstructorProps<GLRenderer>>): GLRenderer
            /**
             * Creates an instance of the GL renderer.
             * @returns a GL renderer
             */
            "new"(): GLRenderer
        }

        const GLRenderer: GLRendererClass
        

        namespace GLShader {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "resource": string | null
                "source": GLib.Bytes
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "resource": string | null
                "source": GLib.Bytes
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * Implements a fragment shader using GLSL.
         *
         * A fragment shader gets the coordinates being rendered as input and
         * produces the pixel values for that particular pixel. Additionally,
         * the shader can declare a set of other input arguments, called
         * uniforms (as they are uniform over all the calls to your shader in
         * each instance of use). A shader can also receive up to 4
         * textures that it can use as input when producing the pixel data.
         *
         * `GskGLShader` is usually used with gtk_snapshot_push_gl_shader()
         * to produce a [class@Gsk.GLShaderNode] in the rendering hierarchy,
         * and then its input textures are constructed by rendering the child
         * nodes to textures before rendering the shader node itself. (You can
         * pass texture nodes as children if you want to directly use a texture
         * as input).
         *
         * The actual shader code is GLSL code that gets combined with
         * some other code into the fragment shader. Since the exact
         * capabilities of the GPU driver differs between different OpenGL
         * drivers and hardware, GTK adds some defines that you can use
         * to ensure your GLSL code runs on as many drivers as it can.
         *
         * If the OpenGL driver is GLES, then the shader language version
         * is set to 100, and GSK_GLES will be defined in the shader.
         *
         * Otherwise, if the OpenGL driver does not support the 3.2 core profile,
         * then the shader will run with language version 110 for GL2 and 130 for GL3,
         * and GSK_LEGACY will be defined in the shader.
         *
         * If the OpenGL driver supports the 3.2 code profile, it will be used,
         * the shader language version is set to 150, and GSK_GL3 will be defined
         * in the shader.
         *
         * The main function the shader must implement is:
         *
         * ```glsl
         *  void mainImage(out vec4 fragColor,
         *                 in vec2 fragCoord,
         *                 in vec2 resolution,
         *                 in vec2 uv)
         * ```
         *
         * Where the input @fragCoord is the coordinate of the pixel we're
         * currently rendering, relative to the boundary rectangle that was
         * specified in the `GskGLShaderNode`, and @resolution is the width and
         * height of that rectangle. This is in the typical GTK coordinate
         * system with the origin in the top left. @uv contains the u and v
         * coordinates that can be used to index a texture at the
         * corresponding point. These coordinates are in the [0..1]x[0..1]
         * region, with 0, 0 being in the lower left corder (which is typical
         * for OpenGL).
         *
         * The output @fragColor should be a RGBA color (with
         * premultiplied alpha) that will be used as the output for the
         * specified pixel location. Note that this output will be
         * automatically clipped to the clip region of the glshader node.
         *
         * In addition to the function arguments the shader can define
         * up to 4 uniforms for textures which must be called u_textureN
         * (i.e. u_texture1 to u_texture4) as well as any custom uniforms
         * you want of types int, uint, bool, float, vec2, vec3 or vec4.
         *
         * All textures sources contain premultiplied alpha colors, but if some
         * there are outer sources of colors there is a gsk_premultiply() helper
         * to compute premultiplication when needed.
         *
         * Note that GTK parses the uniform declarations, so each uniform has to
         * be on a line by itself with no other code, like so:
         *
         * ```glsl
         * uniform float u_time;
         * uniform vec3 u_color;
         * uniform sampler2D u_texture1;
         * uniform sampler2D u_texture2;
         * ```
         *
         * GTK uses the "gsk" namespace in the symbols it uses in the
         * shader, so your code should not use any symbols with the prefix gsk
         * or GSK. There are some helper functions declared that you can use:
         *
         * ```glsl
         * vec4 GskTexture(sampler2D sampler, vec2 texCoords);
         * ```
         *
         * This samples a texture (e.g. u_texture1) at the specified
         * coordinates, and contains some helper ifdefs to ensure that
         * it works on all OpenGL versions.
         *
         * You can compile the shader yourself using [method@Gsk.GLShader.compile],
         * otherwise the GSK renderer will do it when it handling the glshader
         * node. If errors occurs, the returned @error will include the glsl
         * sources, so you can see what GSK was passing to the compiler. You
         * can also set GSK_DEBUG=shaders in the environment to see the sources
         * and other relevant information about all shaders that GSK is handling.
         *
         * # An example shader
         *
         * ```glsl
         * uniform float position;
         * uniform sampler2D u_texture1;
         * uniform sampler2D u_texture2;
         *
         * void mainImage(out vec4 fragColor,
         *                in vec2 fragCoord,
         *                in vec2 resolution,
         *                in vec2 uv) {
         *   vec4 source1 = GskTexture(u_texture1, uv);
         *   vec4 source2 = GskTexture(u_texture2, uv);
         *
         *   fragColor = position * source1 + (1.0 - position) * source2;
         * }
         * ```
         * @deprecated since 4.16 This feature was deprecated in GTK 4.16 after the new rendering infrastructure introduced in 4.14 did not support it. The lack of Vulkan integration would have made it a very hard feature to support. If you want to use OpenGL directly, you should look at [GtkGLArea](../gtk4/class.GLArea.html), which uses a different approach and is still well-supported.
         */
        interface GLShader extends GObject.Object {
            readonly $signals: GLShader.SignalSignatures
            readonly $readableProperties: GLShader.ReadableProperties
            readonly $writableProperties: GLShader.WritableProperties
            readonly $constructOnlyProperties: GLShader.ConstructOnlyProperties
            /**
             * Resource containing the source code for the shader.
             *
             * If the shader source is not coming from a resource, this
             * will be %NULL.
             * @default NULL
             */
            get resource(): string | null
            set resource(value: string | null)
            /**
             * The source code for the shader, as a `GBytes`.
             */
            get source(): GLib.Bytes
            set source(value: GLib.Bytes)
            /**
             * Tries to compile the @shader for the given @renderer.
             *
             * If there is a problem, this function returns %FALSE and reports
             * an error. You should use this function before relying on the shader
             * for rendering and use a fallback with a simpler shader or without
             * shaders if it fails.
             *
             * Note that this will modify the rendering state (for example
             * change the current GL context) and requires the renderer to be
             * set up. This means that the widget has to be realized. Commonly you
             * want to call this from the realize signal of a widget, or during
             * widget snapshot.
             * @throws {GLib.Error}
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param renderer a `GskRenderer`
             * @returns %TRUE on success, %FALSE if an error occurred
             */
            compile(renderer: Renderer): boolean
            /**
             * Looks for a uniform by the name @name, and returns the index
             * of the uniform, or -1 if it was not found.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param name uniform name
             * @returns The index of the uniform, or -1
             */
            find_uniform_by_name(name: string): number
            /**
             * Gets the value of the uniform @idx in the @args block.
             *
             * The uniform must be of bool type.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param args uniform arguments
             * @param idx index of the uniform
             * @returns The value
             */
            get_arg_bool(args: GLib.Bytes, idx: number): boolean
            /**
             * Gets the value of the uniform @idx in the @args block.
             *
             * The uniform must be of float type.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param args uniform arguments
             * @param idx index of the uniform
             * @returns The value
             */
            get_arg_float(args: GLib.Bytes, idx: number): number
            /**
             * Gets the value of the uniform @idx in the @args block.
             *
             * The uniform must be of int type.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param args uniform arguments
             * @param idx index of the uniform
             * @returns The value
             */
            get_arg_int(args: GLib.Bytes, idx: number): number
            /**
             * Gets the value of the uniform @idx in the @args block.
             *
             * The uniform must be of uint type.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param args uniform arguments
             * @param idx index of the uniform
             * @returns The value
             */
            get_arg_uint(args: GLib.Bytes, idx: number): number
            /**
             * Gets the value of the uniform @idx in the @args block.
             *
             * The uniform must be of vec2 type.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param args uniform arguments
             * @param idx index of the uniform
             * @param out_value location to store the uniform value in
             */
            get_arg_vec2(args: GLib.Bytes, idx: number, out_value: Graphene.Vec2): void
            /**
             * Gets the value of the uniform @idx in the @args block.
             *
             * The uniform must be of vec3 type.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param args uniform arguments
             * @param idx index of the uniform
             * @param out_value location to store the uniform value in
             */
            get_arg_vec3(args: GLib.Bytes, idx: number, out_value: Graphene.Vec3): void
            /**
             * Gets the value of the uniform @idx in the @args block.
             *
             * The uniform must be of vec4 type.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param args uniform arguments
             * @param idx index of the uniform
             * @param out_value location to store set the uniform value in
             */
            get_arg_vec4(args: GLib.Bytes, idx: number, out_value: Graphene.Vec4): void
            /**
             * Get the size of the data block used to specify arguments for this shader.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @returns The size of the data block
             */
            get_args_size(): number
            /**
             * Returns the number of textures that the shader requires.
             *
             * This can be used to check that the a passed shader works
             * in your usecase. It is determined by looking at the highest
             * u_textureN value that the shader defines.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @returns The number of texture inputs required by `shader`
             */
            get_n_textures(): number
            /**
             * Get the number of declared uniforms for this shader.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @returns The number of declared uniforms
             */
            get_n_uniforms(): number
            /**
             * Gets the resource path for the GLSL sourcecode being used
             * to render this shader.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @returns The resource path for the shader
             */
            get_resource(): string | null
            /**
             * Gets the GLSL sourcecode being used to render this shader.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @returns The source code for the shader
             */
            get_source(): GLib.Bytes
            /**
             * Get the name of the declared uniform for this shader at index @idx.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param idx index of the uniform
             * @returns The name of the declared uniform
             */
            get_uniform_name(idx: number): string
            /**
             * Get the offset into the data block where data for this uniforms is stored.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param idx index of the uniform
             * @returns The data offset
             */
            get_uniform_offset(idx: number): number
            /**
             * Get the type of the declared uniform for this shader at index @idx.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param idx index of the uniform
             * @returns The type of the declared uniform
             */
            get_uniform_type(idx: number): GLUniformType
        }

        interface GLShaderClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<GLShader>
            readonly prototype: GLShader
            new (props?: Partial<GObject.ConstructorProps<GLShader>>): GLShader
            /**
             * Creates a `GskGLShader` that will render pixels using the specified code.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param sourcecode GLSL sourcecode for the shader, as a `GBytes`
             * @returns A new `GskGLShader`
             */
            new_from_bytes(sourcecode: GLib.Bytes): GLShader
            /**
             * Creates a `GskGLShader` that will render pixels using the specified code.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param resource_path path to a resource that contains the GLSL sourcecode for
                the shader
             * @returns A new `GskGLShader`
             */
            new_from_resource(resource_path: string): GLShader
        }

        const GLShader: GLShaderClass
        

        namespace GLShaderNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node using a GL shader when drawing its children nodes.
         */
        interface GLShaderNode extends RenderNode {
            readonly $signals: GLShaderNode.SignalSignatures
            readonly $readableProperties: GLShaderNode.ReadableProperties
            readonly $writableProperties: GLShaderNode.WritableProperties
            readonly $constructOnlyProperties: GLShaderNode.ConstructOnlyProperties
            /**
             * Gets args for the node.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @returns A `GBytes` with the uniform arguments
             */
            get_args(): GLib.Bytes
            /**
             * Gets one of the children.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param idx the position of the child to get
             * @returns the `idx`'th child of `node`
             */
            get_child(idx: number): RenderNode
            /**
             * Returns the number of children
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @returns The number of children
             */
            get_n_children(): number
            /**
             * Gets shader code for the node.
             * @returns the `GskGLShader` shader
             */
            get_shader(): GLShader
        }

        interface GLShaderNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<GLShaderNode>
            readonly prototype: GLShaderNode
            new (props?: Partial<GObject.ConstructorProps<GLShaderNode>>): GLShaderNode
            /**
             * Creates a `GskRenderNode` that will render the given @shader into the
             * area given by @bounds.
             *
             * The @args is a block of data to use for uniform input, as per types and
             * offsets defined by the @shader. Normally this is generated by
             * [method@Gsk.GLShader.format_args] or [struct@Gsk.ShaderArgsBuilder].
             *
             * See [class@Gsk.GLShader] for details about how the shader should be written.
             *
             * All the children will be rendered into textures (if they aren't already
             * `GskTextureNodes`, which will be used directly). These textures will be
             * sent as input to the shader.
             *
             * If the renderer doesn't support GL shaders, or if there is any problem
             * when compiling the shader, then the node will draw pink. You should use
             * [method@Gsk.GLShader.compile] to ensure the @shader will work for the
             * renderer before using it.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param shader the `GskGLShader`
             * @param bounds the rectangle to render the shader into
             * @param args Arguments for the uniforms
             * @param children array of child nodes,
              these will be rendered to textures and used as input.
             * @returns A new `GskRenderNode`
             */
            "new"(shader: GLShader, bounds: Graphene.Rect, args: GLib.Bytes, children: RenderNode[] | null): GLShaderNode
        }

        const GLShaderNode: GLShaderNodeClass
        

        namespace InsetShadowNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node for an inset shadow.
         */
        interface InsetShadowNode extends RenderNode {
            readonly $signals: InsetShadowNode.SignalSignatures
            readonly $readableProperties: InsetShadowNode.ReadableProperties
            readonly $writableProperties: InsetShadowNode.WritableProperties
            readonly $constructOnlyProperties: InsetShadowNode.ConstructOnlyProperties
            /**
             * Retrieves the blur radius to apply to the shadow.
             * @returns the blur radius, in pixels
             */
            get_blur_radius(): number
            /**
             * Retrieves the color of the inset shadow.
             *
             * The value returned by this function will not be correct
             * if the render node was created for a non-sRGB color.
             * @returns the color of the shadow
             */
            get_color(): Gdk.RGBA
            /**
             * Retrieves the horizontal offset of the inset shadow.
             * @returns an offset, in pixels
             */
            get_dx(): number
            /**
             * Retrieves the vertical offset of the inset shadow.
             * @returns an offset, in pixels
             */
            get_dy(): number
            /**
             * Retrieves the outline rectangle of the inset shadow.
             * @returns a rounded rectangle
             */
            get_outline(): RoundedRect
            /**
             * Retrieves how much the shadow spreads inwards.
             * @returns the size of the shadow, in pixels
             */
            get_spread(): number
        }

        interface InsetShadowNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<InsetShadowNode>
            readonly prototype: InsetShadowNode
            new (props?: Partial<GObject.ConstructorProps<InsetShadowNode>>): InsetShadowNode
            /**
             * Creates a `GskRenderNode` that will render an inset shadow
             * into the box given by @outline.
             * @param outline outline of the region containing the shadow
             * @param color color of the shadow
             * @param dx horizontal offset of shadow
             * @param dy vertical offset of shadow
             * @param spread how far the shadow spreads towards the inside
             * @param blur_radius how much blur to apply to the shadow
             * @returns A new `GskRenderNode`
             */
            "new"(outline: RoundedRect, color: Gdk.RGBA, dx: number, dy: number, spread: number, blur_radius: number): InsetShadowNode
        }

        const InsetShadowNode: InsetShadowNodeClass
        

        namespace IsolationNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node that isolates its child from surrounding rendernodes.
         * @since 4.22
         */
        interface IsolationNode extends RenderNode {
            readonly $signals: IsolationNode.SignalSignatures
            readonly $readableProperties: IsolationNode.ReadableProperties
            readonly $writableProperties: IsolationNode.WritableProperties
            readonly $constructOnlyProperties: IsolationNode.ConstructOnlyProperties
            /**
             * Gets the child node that is getting drawn by the given @node.
             * @since 4.22
             * @returns the child `GskRenderNode`
             */
            get_child(): RenderNode
            /**
             * Gets the isolation features that are enforced by this node.
             * @since 4.22
             * @returns the isolation features
             */
            get_isolations(): Isolation
        }

        interface IsolationNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<IsolationNode>
            readonly prototype: IsolationNode
            new (props?: Partial<GObject.ConstructorProps<IsolationNode>>): IsolationNode
            /**
             *  ~(GSK_ISOLATION_BACKGROUND | GSK_ISOLATION_COPY_PASTE)`
             * will isolate everything but background and copy/paste.
             *
             * For the available isolations, see [flags@Gsk.Isolation].
             * @since 4.22
             * @param child The child
             * @param isolations features to isolate
             * @returns A new `GskRenderNode`
             */
            "new"(child: RenderNode, isolations: Isolation): IsolationNode
        }

        const IsolationNode: IsolationNodeClass
        

        namespace LinearGradientNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node for a linear gradient.
         */
        interface LinearGradientNode extends RenderNode {
            readonly $signals: LinearGradientNode.SignalSignatures
            readonly $readableProperties: LinearGradientNode.ReadableProperties
            readonly $writableProperties: LinearGradientNode.WritableProperties
            readonly $constructOnlyProperties: LinearGradientNode.ConstructOnlyProperties
            /**
             * Retrieves the color stops in the gradient.
             * @returns the color stops in the gradient
             */
            get_color_stops(): ColorStop[]
            /**
             * Retrieves the final point of the linear gradient.
             * @returns the final point
             */
            get_end(): Graphene.Point
            /**
             * Retrieves the number of color stops in the gradient.
             * @returns the number of color stops
             */
            get_n_color_stops(): number
            /**
             * Retrieves the initial point of the linear gradient.
             * @returns the initial point
             */
            get_start(): Graphene.Point
        }

        interface LinearGradientNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<LinearGradientNode>
            readonly prototype: LinearGradientNode
            new (props?: Partial<GObject.ConstructorProps<LinearGradientNode>>): LinearGradientNode
            /**
             * Creates a `GskRenderNode` that will create a linear gradient from the given
             * points and color stops, and render that into the area given by @bounds.
             * @param bounds the rectangle to render the linear gradient into
             * @param start the point at which the linear gradient will begin
             * @param end the point at which the linear gradient will finish
             * @param color_stops = 1.
             * @returns A new `GskRenderNode`
             */
            "new"(bounds: Graphene.Rect, start: Graphene.Point, end: Graphene.Point, color_stops: ColorStop[]): LinearGradientNode
        }

        const LinearGradientNode: LinearGradientNodeClass
        

        namespace MaskNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node masking one child node with another.
         * @since 4.10
         */
        interface MaskNode extends RenderNode {
            readonly $signals: MaskNode.SignalSignatures
            readonly $readableProperties: MaskNode.ReadableProperties
            readonly $writableProperties: MaskNode.WritableProperties
            readonly $constructOnlyProperties: MaskNode.ConstructOnlyProperties
            /**
             * Retrieves the mask `GskRenderNode` child of the @node.
             * @since 4.10
             * @returns the mask child node
             */
            get_mask(): RenderNode
            /**
             * Retrieves the mask mode used by @node.
             * @since 4.10
             * @returns the mask mode
             */
            get_mask_mode(): MaskMode
            /**
             * Retrieves the source `GskRenderNode` child of the @node.
             * @since 4.10
             * @returns the source child node
             */
            get_source(): RenderNode
        }

        interface MaskNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<MaskNode>
            readonly prototype: MaskNode
            new (props?: Partial<GObject.ConstructorProps<MaskNode>>): MaskNode
            /**
             * Creates a `GskRenderNode` that will mask a given node by another.
             *
             * The @mask_mode determines how the 'mask values' are derived from
             * the colors of the @mask. Applying the mask consists of multiplying
             * the 'mask value' with the alpha of the source.
             * @since 4.10
             * @param source The source node to be drawn
             * @param mask The node to be used as mask
             * @param mask_mode The mask mode to use
             * @returns A new `GskRenderNode`
             */
            "new"(source: RenderNode, mask: RenderNode, mask_mode: MaskMode): MaskNode
        }

        const MaskNode: MaskNodeClass
        

        namespace NglRenderer {
            interface SignalSignatures extends Renderer.SignalSignatures {
            }

            interface ReadableProperties extends Renderer.ReadableProperties {
            }

            interface WritableProperties extends Renderer.WritableProperties {
            }

            interface ConstructOnlyProperties extends Renderer.ConstructOnlyProperties {
            }
        }

        /**
         * A GL based renderer.
         *
         * See [class@Gsk.Renderer].
         */
        interface NglRenderer extends Renderer {
            readonly $signals: NglRenderer.SignalSignatures
            readonly $readableProperties: NglRenderer.ReadableProperties
            readonly $writableProperties: NglRenderer.WritableProperties
            readonly $constructOnlyProperties: NglRenderer.ConstructOnlyProperties
        }

        interface NglRendererClass extends Omit<RendererClass, "new"> {
            readonly $gtype: GObject.GType<NglRenderer>
            readonly prototype: NglRenderer
            new (props?: Partial<GObject.ConstructorProps<NglRenderer>>): NglRenderer
            /**
             * Same as gsk_gl_renderer_new().
             * @deprecated since 4.18 Use gsk_gl_renderer_new()
             * @returns a GL renderer
             */
            "new"(): NglRenderer
        }

        const NglRenderer: NglRendererClass
        

        namespace OpacityNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node controlling the opacity of its single child node.
         */
        interface OpacityNode extends RenderNode {
            readonly $signals: OpacityNode.SignalSignatures
            readonly $readableProperties: OpacityNode.ReadableProperties
            readonly $writableProperties: OpacityNode.WritableProperties
            readonly $constructOnlyProperties: OpacityNode.ConstructOnlyProperties
            /**
             * Gets the child node that is getting opacityed by the given @node.
             * @returns The child that is getting opacityed
             */
            get_child(): RenderNode
            /**
             * Gets the transparency factor for an opacity node.
             * @returns the opacity factor
             */
            get_opacity(): number
        }

        interface OpacityNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<OpacityNode>
            readonly prototype: OpacityNode
            new (props?: Partial<GObject.ConstructorProps<OpacityNode>>): OpacityNode
            /**
             * Creates a `GskRenderNode` that will drawn the @child with reduced
             * @opacity.
             * @param child The node to draw
             * @param opacity The opacity to apply
             * @returns A new `GskRenderNode`
             */
            "new"(child: RenderNode, opacity: number): OpacityNode
        }

        const OpacityNode: OpacityNodeClass
        

        namespace OutsetShadowNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node for an outset shadow.
         */
        interface OutsetShadowNode extends RenderNode {
            readonly $signals: OutsetShadowNode.SignalSignatures
            readonly $readableProperties: OutsetShadowNode.ReadableProperties
            readonly $writableProperties: OutsetShadowNode.WritableProperties
            readonly $constructOnlyProperties: OutsetShadowNode.ConstructOnlyProperties
            /**
             * Retrieves the blur radius of the shadow.
             * @returns the blur radius, in pixels
             */
            get_blur_radius(): number
            /**
             * Retrieves the color of the outset shadow.
             *
             * The value returned by this function will not be correct
             * if the render node was created for a non-sRGB color.
             * @returns a color
             */
            get_color(): Gdk.RGBA
            /**
             * Retrieves the horizontal offset of the outset shadow.
             * @returns an offset, in pixels
             */
            get_dx(): number
            /**
             * Retrieves the vertical offset of the outset shadow.
             * @returns an offset, in pixels
             */
            get_dy(): number
            /**
             * Retrieves the outline rectangle of the outset shadow.
             * @returns a rounded rectangle
             */
            get_outline(): RoundedRect
            /**
             * Retrieves how much the shadow spreads outwards.
             * @returns the size of the shadow, in pixels
             */
            get_spread(): number
        }

        interface OutsetShadowNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<OutsetShadowNode>
            readonly prototype: OutsetShadowNode
            new (props?: Partial<GObject.ConstructorProps<OutsetShadowNode>>): OutsetShadowNode
            /**
             * Creates a `GskRenderNode` that will render an outset shadow
             * around the box given by @outline.
             * @param outline outline of the region surrounded by shadow
             * @param color color of the shadow
             * @param dx horizontal offset of shadow
             * @param dy vertical offset of shadow
             * @param spread how far the shadow spreads towards the inside
             * @param blur_radius how much blur to apply to the shadow
             * @returns A new `GskRenderNode`
             */
            "new"(outline: RoundedRect, color: Gdk.RGBA, dx: number, dy: number, spread: number, blur_radius: number): OutsetShadowNode
        }

        const OutsetShadowNode: OutsetShadowNodeClass
        

        namespace PasteNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node for a paste.
         * @since 4.22
         */
        interface PasteNode extends RenderNode {
            readonly $signals: PasteNode.SignalSignatures
            readonly $readableProperties: PasteNode.ReadableProperties
            readonly $writableProperties: PasteNode.WritableProperties
            readonly $constructOnlyProperties: PasteNode.ConstructOnlyProperties
            /**
             * Retrieves the index of the copy that should be pasted.
             * @since 4.22
             * @returns the index of the copy to paste.
             */
            get_depth(): number
        }

        interface PasteNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<PasteNode>
            readonly prototype: PasteNode
            new (props?: Partial<GObject.ConstructorProps<PasteNode>>): PasteNode
            /**
             * Creates a `GskRenderNode` that will paste copied contents.
             * @since 4.22
             * @param bounds the rectangle to render the paste into
             * @param depth the index of which copy to paste. This will usually be 0.
             * @returns A new `GskRenderNode`
             */
            "new"(bounds: Graphene.Rect, depth: number): PasteNode
        }

        const PasteNode: PasteNodeClass
        

        namespace RadialGradientNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node for a radial gradient.
         */
        interface RadialGradientNode extends RenderNode {
            readonly $signals: RadialGradientNode.SignalSignatures
            readonly $readableProperties: RadialGradientNode.ReadableProperties
            readonly $writableProperties: RadialGradientNode.WritableProperties
            readonly $constructOnlyProperties: RadialGradientNode.ConstructOnlyProperties
            /**
             * Retrieves the center pointer for the gradient.
             * @returns the center point for the gradient
             */
            get_center(): Graphene.Point
            /**
             * Retrieves the color stops in the gradient.
             * @returns the color stops in the gradient
             */
            get_color_stops(): ColorStop[]
            /**
             * Retrieves the end value for the gradient.
             * @returns the end value for the gradient
             */
            get_end(): number
            /**
             * Retrieves the horizontal radius for the gradient.
             * @returns the horizontal radius for the gradient
             */
            get_hradius(): number
            /**
             * Retrieves the number of color stops in the gradient.
             * @returns the number of color stops
             */
            get_n_color_stops(): number
            /**
             * Retrieves the start value for the gradient.
             * @returns the start value for the gradient
             */
            get_start(): number
            /**
             * Retrieves the vertical radius for the gradient.
             * @returns the vertical radius for the gradient
             */
            get_vradius(): number
        }

        interface RadialGradientNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<RadialGradientNode>
            readonly prototype: RadialGradientNode
            new (props?: Partial<GObject.ConstructorProps<RadialGradientNode>>): RadialGradientNode
            /**
             * Creates a `GskRenderNode` that draws a radial gradient.
             *
             * The radial gradient
             * starts around @center. The size of the gradient is dictated by @hradius
             * in horizontal orientation and by @vradius in vertical orientation.
             * @param bounds the bounds of the node
             * @param center the center of the gradient
             * @param hradius the horizontal radius
             * @param vradius the vertical radius
             * @param start = 0 that defines the start of the gradient around @center
             * @param end = 0 that defines the end of the gradient around @center
             * @param color_stops = 1.
             * @returns A new `GskRenderNode`
             */
            "new"(bounds: Graphene.Rect, center: Graphene.Point, hradius: number, vradius: number, start: number, end: number, color_stops: ColorStop[]): RadialGradientNode
        }

        const RadialGradientNode: RadialGradientNodeClass
        

        namespace RenderNode {
            interface SignalSignatures  {
            }

            interface ReadableProperties  {
            }

            interface WritableProperties  {
            }

            interface ConstructOnlyProperties  {
            }
        }

        /**
         * The basic block in a scene graph to be rendered using [class@Gsk.Renderer].
         *
         * Each node has a parent, except the top-level node; each node may have
         * children nodes.
         *
         * Each node has an associated drawing surface, which has the size of
         * the rectangle set when creating it.
         *
         * Render nodes are meant to be transient; once they have been associated
         * to a [class@Gsk.Renderer] it's safe to release any reference you have on
         * them. All [class@Gsk.RenderNode]s are immutable, you can only specify their
         * properties during construction.
         */
        interface RenderNode  {
            readonly $signals: RenderNode.SignalSignatures
            readonly $readableProperties: RenderNode.ReadableProperties
            readonly $writableProperties: RenderNode.WritableProperties
            readonly $constructOnlyProperties: RenderNode.ConstructOnlyProperties
            /**
             * Draws the contents of a render node on a cairo context.
             *
             * Typically, you'll use this function to implement fallback rendering
             * of render nodes on an intermediate Cairo context, instead of using
             * the drawing context associated to a [class@Gdk.Surface]'s rendering buffer.
             *
             * For advanced nodes that cannot be supported using Cairo, in particular
             * for nodes doing 3D operations, this function may fail.
             * @param cr cairo context to draw to
             */
            draw(cr: cairo.Context): void
            /**
             * Retrieves the boundaries of the @node.
             *
             * The node will not draw outside of its boundaries.
             * @returns , return location for the boundaries
             */
            get_bounds(): Graphene.Rect
            /**
             * Gets a list of all children nodes of the rendernode.
             *
             * Keep in mind that for various rendernodes, their children have different
             * semantics, like the mask vs the source of a mask node. If you care about
             * thse semantics, don't use this function, use the specific getters instead.
             * @returns The children
             */
            get_children(): RenderNode[] | null
            /**
             * Returns the type of the render node.
             * @returns the type of `node`
             */
            get_node_type(): RenderNodeType
            /**
             * Gets an opaque rectangle inside the node that GTK can determine to
             * be fully opaque.
             *
             * There is no guarantee that this is indeed the largest opaque rectangle or
             * that regions outside the rectangle are not opaque. This function is a best
             * effort with that goal.
             *
             * The rectangle will be fully contained in the bounds of the node.
             * @since 4.16
             * @returns true if part or all of the rendernode is opaque, false if no   opaque region could be found., return location for the opaque rect
             */
            get_opaque_rect(): [boolean, Graphene.Rect]
            /**
             * Acquires a reference on the given `GskRenderNode`.
             * @returns the render node with an additional reference
             */
            ref(): RenderNode
            /**
             * Serializes the @node for later deserialization via
             * gsk_render_node_deserialize(). No guarantees are made about the format
             * used other than that the same version of GTK will be able to deserialize
             * the result of a call to gsk_render_node_serialize() and
             * gsk_render_node_deserialize() will correctly reject files it cannot open
             * that were created with previous versions of GTK.
             *
             * The intended use of this functions is testing, benchmarking and debugging.
             * The format is not meant as a permanent storage format.
             * @returns a `GBytes` representing the node.
             */
            serialize(): GLib.Bytes
            /**
             * Releases a reference on the given `GskRenderNode`.
             *
             * If the reference was the last, the resources associated to the @node are
             * freed.
             */
            unref(): void
            /**
             * This function is equivalent to calling [method@Gsk.RenderNode.serialize]
             * followed by [func@GLib.file_set_contents].
             *
             * See those two functions for details on the arguments.
             *
             * It is mostly intended for use inside a debugger to quickly dump a render
             * node to a file for later inspection.
             * @throws {GLib.Error}
             * @param filename the file to save it to
             * @returns true if saving was successful
             */
            write_to_file(filename: string): boolean
        }

        interface RenderNodeClass {
            readonly $gtype: GObject.GType<RenderNode>
            readonly prototype: RenderNode
            new (props?: Partial<GObject.ConstructorProps<RenderNode>>): RenderNode
            /**
             * Loads data previously created via [method@Gsk.RenderNode.serialize].
             *
             * For a discussion of the supported format, see that function.
             * @param bytes the bytes containing the data
             * @param error_func callback on parsing errors
             * @returns a new render node
             */
            deserialize(bytes: GLib.Bytes, error_func: ParseErrorFunc | null): RenderNode | null
        }

        const RenderNode: RenderNodeClass
        

        namespace Renderer {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "realized": boolean
                "surface": Gdk.Surface | null
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "realized": boolean
                "surface": Gdk.Surface | null
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * Renders a scene graph defined via a tree of [class@Gsk.RenderNode] instances.
         *
         * Typically you will use a `GskRenderer` instance to repeatedly call
         * [method@Gsk.Renderer.render] to update the contents of its associated
         * [class@Gdk.Surface].
         *
         * It is necessary to realize a `GskRenderer` instance using
         * [method@Gsk.Renderer.realize] before calling [method@Gsk.Renderer.render],
         * in order to create the appropriate windowing system resources needed
         * to render the scene.
         */
        interface Renderer extends GObject.Object {
            readonly $signals: Renderer.SignalSignatures
            readonly $readableProperties: Renderer.ReadableProperties
            readonly $writableProperties: Renderer.WritableProperties
            readonly $constructOnlyProperties: Renderer.ConstructOnlyProperties
            /**
             * Whether the renderer has been associated with a surface or draw context.
             * @default FALSE
             */
            get realized(): boolean
            set realized(value: boolean)
            /**
             * The surface associated with renderer.
             */
            get surface(): Gdk.Surface | null
            set surface(value: Gdk.Surface | null)
            /**
             * Retrieves the surface that the renderer is associated with.
             *
             * If the renderer has not been realized yet, `NULL` will be returned.
             * @returns the surface
             */
            get_surface(): Gdk.Surface | null
            /**
             * Checks whether the renderer is realized or not.
             * @returns true if the renderer was realized, false otherwise
             */
            is_realized(): boolean
            /**
             * Creates the resources needed by the renderer.
             *
             * Since GTK 4.6, the surface may be `NULL`, which allows using
             * renderers without having to create a surface. Since GTK 4.14,
             * it is recommended to use [method@Gsk.Renderer.realize_for_display]
             * for this case.
             *
             * Note that it is mandatory to call [method@Gsk.Renderer.unrealize]
             * before destroying the renderer.
             * @throws {GLib.Error}
             * @param surface the surface that renderer will be used on
             * @returns whether the renderer was successfully realized
             */
            realize(surface: Gdk.Surface | null): boolean
            /**
             * Creates the resources needed by the renderer.
             *
             * Note that it is mandatory to call [method@Gsk.Renderer.unrealize]
             * before destroying the renderer.
             * @throws {GLib.Error}
             * @since 4.14
             * @param display the display that the renderer will be used on
             * @returns whether the renderer was successfully realized
             */
            realize_for_display(display: Gdk.Display): boolean
            /**
             * Renders the scene graph, described by a tree of `GskRenderNode` instances
             * to the renderer's surface, ensuring that the given region gets redrawn.
             *
             * If the renderer has no associated surface, this function does nothing.
             *
             * Renderers must ensure that changes of the contents given by the @root
             * node as well as the area given by @region are redrawn. They are however
             * free to not redraw any pixel outside of @region if they can guarantee that
             * it didn't change.
             *
             * The renderer will acquire a reference on the `GskRenderNode` tree while
             * the rendering is in progress.
             * @param root the render node to render
             * @param region the `cairo_region_t` that must be redrawn or `NULL`
              for the whole surface
             */
            render(root: RenderNode, region: cairo.Region | null): void
            /**
             * Renders a scene graph, described by a tree of `GskRenderNode` instances,
             * to a texture.
             *
             * The renderer will acquire a reference on the `GskRenderNode` tree while
             * the rendering is in progress.
             *
             * If you want to apply any transformations to @root, you should put it into a
             * transform node and pass that node instead.
             * @param root the render node to render
             * @param viewport the section to draw or `NULL` to use @root's bounds
             * @returns a texture with the rendered contents of `root`
             */
            render_texture(root: RenderNode, viewport: Graphene.Rect | null): Gdk.Texture
            /**
             * Releases all the resources created by [method@Gsk.Renderer.realize].
             */
            unrealize(): void
        }

        interface RendererClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Renderer>
            readonly prototype: Renderer
            new (props?: Partial<GObject.ConstructorProps<Renderer>>): Renderer
            /**
             * Creates an appropriate `GskRenderer` instance for the given surface.
             *
             * If the `GSK_RENDERER` environment variable is set, GSK will
             * try that renderer first, before trying the backend-specific
             * default. The ultimate fallback is the cairo renderer.
             *
             * The renderer will be realized before it is returned.
             * @param surface a surface
             * @returns the realized renderer
             */
            new_for_surface(surface: Gdk.Surface): Renderer | null
        }

        const Renderer: RendererClass
        

        namespace RepeatNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node repeating its single child node.
         */
        interface RepeatNode extends RenderNode {
            readonly $signals: RepeatNode.SignalSignatures
            readonly $readableProperties: RepeatNode.ReadableProperties
            readonly $writableProperties: RepeatNode.WritableProperties
            readonly $constructOnlyProperties: RepeatNode.ConstructOnlyProperties
            /**
             * Retrieves the child of @node.
             * @returns a `GskRenderNode`
             */
            get_child(): RenderNode
            /**
             * Retrieves the bounding rectangle of the child of @node.
             * @returns a bounding rectangle
             */
            get_child_bounds(): Graphene.Rect
        }

        interface RepeatNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<RepeatNode>
            readonly prototype: RepeatNode
            new (props?: Partial<GObject.ConstructorProps<RepeatNode>>): RepeatNode
            /**
             * Creates a `GskRenderNode` that will repeat the drawing of @child across
             * the given @bounds.
             * @param bounds The bounds of the area to be painted
             * @param child The child to repeat
             * @param child_bounds The area of the child to repeat or %NULL to
                use the child's bounds
             * @returns A new `GskRenderNode`
             */
            "new"(bounds: Graphene.Rect, child: RenderNode, child_bounds: Graphene.Rect | null): RepeatNode
        }

        const RepeatNode: RepeatNodeClass
        

        namespace RepeatingLinearGradientNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node for a repeating linear gradient.
         */
        interface RepeatingLinearGradientNode extends RenderNode {
            readonly $signals: RepeatingLinearGradientNode.SignalSignatures
            readonly $readableProperties: RepeatingLinearGradientNode.ReadableProperties
            readonly $writableProperties: RepeatingLinearGradientNode.WritableProperties
            readonly $constructOnlyProperties: RepeatingLinearGradientNode.ConstructOnlyProperties
        }

        interface RepeatingLinearGradientNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<RepeatingLinearGradientNode>
            readonly prototype: RepeatingLinearGradientNode
            new (props?: Partial<GObject.ConstructorProps<RepeatingLinearGradientNode>>): RepeatingLinearGradientNode
            /**
             * Creates a `GskRenderNode` that will create a repeating linear gradient
             * from the given points and color stops, and render that into the area
             * given by @bounds.
             * @param bounds the rectangle to render the linear gradient into
             * @param start the point at which the linear gradient will begin
             * @param end the point at which the linear gradient will finish
             * @param color_stops = 1.
             * @returns A new `GskRenderNode`
             */
            "new"(bounds: Graphene.Rect, start: Graphene.Point, end: Graphene.Point, color_stops: ColorStop[]): RepeatingLinearGradientNode
        }

        const RepeatingLinearGradientNode: RepeatingLinearGradientNodeClass
        

        namespace RepeatingRadialGradientNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node for a repeating radial gradient.
         */
        interface RepeatingRadialGradientNode extends RenderNode {
            readonly $signals: RepeatingRadialGradientNode.SignalSignatures
            readonly $readableProperties: RepeatingRadialGradientNode.ReadableProperties
            readonly $writableProperties: RepeatingRadialGradientNode.WritableProperties
            readonly $constructOnlyProperties: RepeatingRadialGradientNode.ConstructOnlyProperties
        }

        interface RepeatingRadialGradientNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<RepeatingRadialGradientNode>
            readonly prototype: RepeatingRadialGradientNode
            new (props?: Partial<GObject.ConstructorProps<RepeatingRadialGradientNode>>): RepeatingRadialGradientNode
            /**
             * Creates a `GskRenderNode` that draws a repeating radial gradient.
             *
             * The radial gradient starts around @center. The size of the gradient
             * is dictated by @hradius in horizontal orientation and by @vradius
             * in vertical orientation.
             * @param bounds the bounds of the node
             * @param center the center of the gradient
             * @param hradius the horizontal radius
             * @param vradius the vertical radius
             * @param start = 0 that defines the start of the gradient around @center
             * @param end = 0 that defines the end of the gradient around @center
             * @param color_stops = 1.
             * @returns A new `GskRenderNode`
             */
            "new"(bounds: Graphene.Rect, center: Graphene.Point, hradius: number, vradius: number, start: number, end: number, color_stops: ColorStop[]): RepeatingRadialGradientNode
        }

        const RepeatingRadialGradientNode: RepeatingRadialGradientNodeClass
        

        namespace RoundedClipNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node applying a rounded rectangle clip to its single child.
         */
        interface RoundedClipNode extends RenderNode {
            readonly $signals: RoundedClipNode.SignalSignatures
            readonly $readableProperties: RoundedClipNode.ReadableProperties
            readonly $writableProperties: RoundedClipNode.WritableProperties
            readonly $constructOnlyProperties: RoundedClipNode.ConstructOnlyProperties
            /**
             * Gets the child node that is getting clipped by the given @node.
             * @returns The child that is getting clipped
             */
            get_child(): RenderNode
            /**
             * Retrieves the rounded rectangle used to clip the contents of the @node.
             * @returns a rounded rectangle
             */
            get_clip(): RoundedRect
        }

        interface RoundedClipNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<RoundedClipNode>
            readonly prototype: RoundedClipNode
            new (props?: Partial<GObject.ConstructorProps<RoundedClipNode>>): RoundedClipNode
            /**
             * Creates a `GskRenderNode` that will clip the @child to the area
             * given by @clip.
             * @param child The node to draw
             * @param clip The clip to apply
             * @returns A new `GskRenderNode`
             */
            "new"(child: RenderNode, clip: RoundedRect): RoundedClipNode
        }

        const RoundedClipNode: RoundedClipNodeClass
        

        namespace ShadowNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node drawing one or more shadows behind its single child node.
         */
        interface ShadowNode extends RenderNode {
            readonly $signals: ShadowNode.SignalSignatures
            readonly $readableProperties: ShadowNode.ReadableProperties
            readonly $writableProperties: ShadowNode.WritableProperties
            readonly $constructOnlyProperties: ShadowNode.ConstructOnlyProperties
            /**
             * Retrieves the child `GskRenderNode` of the shadow @node.
             * @returns the child render node
             */
            get_child(): RenderNode
            /**
             * Retrieves the number of shadows in the @node.
             * @returns the number of shadows.
             */
            get_n_shadows(): number
            /**
             * Retrieves the shadow data at the given index @i.
             * @param i the given index
             * @returns the shadow data
             */
            get_shadow(i: number): Shadow
        }

        interface ShadowNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<ShadowNode>
            readonly prototype: ShadowNode
            new (props?: Partial<GObject.ConstructorProps<ShadowNode>>): ShadowNode
            /**
             * Creates a `GskRenderNode` that will draw a @child with the given
             * @shadows below it.
             * @param child The node to draw
             * @param shadows The shadows to apply
             * @returns A new `GskRenderNode`
             */
            "new"(child: RenderNode, shadows: Shadow[]): ShadowNode
        }

        const ShadowNode: ShadowNodeClass
        

        namespace StrokeNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node that will fill the area determined by stroking the the given
         * [struct@Gsk.Path] using the [struct@Gsk.Stroke] attributes.
         * @since 4.14
         */
        interface StrokeNode extends RenderNode {
            readonly $signals: StrokeNode.SignalSignatures
            readonly $readableProperties: StrokeNode.ReadableProperties
            readonly $writableProperties: StrokeNode.WritableProperties
            readonly $constructOnlyProperties: StrokeNode.ConstructOnlyProperties
            /**
             * Gets the child node that is getting drawn by the given @node.
             * @since 4.14
             * @returns The child that is getting drawn
             */
            get_child(): RenderNode
            /**
             * Retrieves the path that will be stroked with the contents of
             * the @node.
             * @since 4.14
             * @returns a #GskPath
             */
            get_path(): Path
            /**
             * Retrieves the stroke attributes used in this @node.
             * @since 4.14
             * @returns a #GskStroke
             */
            get_stroke(): Stroke
        }

        interface StrokeNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<StrokeNode>
            readonly prototype: StrokeNode
            new (props?: Partial<GObject.ConstructorProps<StrokeNode>>): StrokeNode
            /**
             * Creates a #GskRenderNode that will fill the outline generated by stroking
             * the given @path using the attributes defined in @stroke.
             *
             * The area is filled with @child.
             *
             * GSK aims to follow the SVG semantics for stroking paths.
             * E.g. zero-length contours will get round or square line
             * caps drawn, regardless whether they are closed or not.
             * @since 4.14
             * @param child The node to stroke the area with
             * @param path The path describing the area to stroke
             * @param stroke The stroke attributes to use
             * @returns A new #GskRenderNode
             */
            "new"(child: RenderNode, path: Path, stroke: Stroke): StrokeNode
        }

        const StrokeNode: StrokeNodeClass
        

        namespace SubsurfaceNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node that potentially diverts a part of the scene graph to a subsurface.
         * @since 4.14
         */
        interface SubsurfaceNode extends RenderNode {
            readonly $signals: SubsurfaceNode.SignalSignatures
            readonly $readableProperties: SubsurfaceNode.ReadableProperties
            readonly $writableProperties: SubsurfaceNode.WritableProperties
            readonly $constructOnlyProperties: SubsurfaceNode.ConstructOnlyProperties
            /**
             * Gets the child node that is getting drawn by the given @node.
             * @since 4.14
             * @returns the child `GskRenderNode`
             */
            get_child(): RenderNode
        }

        interface SubsurfaceNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<SubsurfaceNode>
            readonly prototype: SubsurfaceNode
            new (props?: Partial<GObject.ConstructorProps<SubsurfaceNode>>): SubsurfaceNode
        }

        const SubsurfaceNode: SubsurfaceNodeClass
        

        namespace TextNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node drawing a set of glyphs.
         */
        interface TextNode extends RenderNode {
            readonly $signals: TextNode.SignalSignatures
            readonly $readableProperties: TextNode.ReadableProperties
            readonly $writableProperties: TextNode.WritableProperties
            readonly $constructOnlyProperties: TextNode.ConstructOnlyProperties
            /**
             * Retrieves the color used by the text @node.
             *
             * The value returned by this function will not be correct
             * if the render node was created for a non-sRGB color.
             * @returns the text color
             */
            get_color(): Gdk.RGBA
            /**
             * Returns the font used by the text @node.
             * @returns the font
             */
            get_font(): Pango.Font
            /**
             * Retrieves the glyph information in the @node.
             * @returns the glyph information
             */
            get_glyphs(): Pango.GlyphInfo[]
            /**
             * Retrieves the number of glyphs in the text node.
             * @returns the number of glyphs
             */
            get_num_glyphs(): number
            /**
             * Retrieves the offset applied to the text.
             * @returns a point with the horizontal and vertical offsets
             */
            get_offset(): Graphene.Point
            /**
             * Checks whether the text @node has color glyphs.
             * @since 4.2
             * @returns %TRUE if the text node has color glyphs
             */
            has_color_glyphs(): boolean
        }

        interface TextNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<TextNode>
            readonly prototype: TextNode
            new (props?: Partial<GObject.ConstructorProps<TextNode>>): TextNode
            /**
             * Creates a render node that renders the given glyphs.
             *
             * Note that @color may not be used if the font contains
             * color glyphs.
             * @param font the `PangoFont` containing the glyphs
             * @param glyphs the `PangoGlyphString` to render
             * @param color the foreground color to render with
             * @param offset offset of the baseline
             * @returns a new `GskRenderNode`
             */
            "new"(font: Pango.Font, glyphs: Pango.GlyphString, color: Gdk.RGBA, offset: Graphene.Point): TextNode | null
        }

        const TextNode: TextNodeClass
        

        namespace TextureNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node for a `GdkTexture`.
         */
        interface TextureNode extends RenderNode {
            readonly $signals: TextureNode.SignalSignatures
            readonly $readableProperties: TextureNode.ReadableProperties
            readonly $writableProperties: TextureNode.WritableProperties
            readonly $constructOnlyProperties: TextureNode.ConstructOnlyProperties
            /**
             * Retrieves the `GdkTexture` used when creating this `GskRenderNode`.
             * @returns the `GdkTexture`
             */
            get_texture(): Gdk.Texture
        }

        interface TextureNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<TextureNode>
            readonly prototype: TextureNode
            new (props?: Partial<GObject.ConstructorProps<TextureNode>>): TextureNode
            /**
             * Creates a `GskRenderNode` that will render the given
             * @texture into the area given by @bounds.
             *
             * Note that GSK applies linear filtering when textures are
             * scaled and transformed. See [class@Gsk.TextureScaleNode]
             * for a way to influence filtering.
             * @param texture the `GdkTexture`
             * @param bounds the rectangle to render the texture into
             * @returns A new `GskRenderNode`
             */
            "new"(texture: Gdk.Texture, bounds: Graphene.Rect): TextureNode
        }

        const TextureNode: TextureNodeClass
        

        namespace TextureScaleNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node for a `GdkTexture`, with control over scaling.
         * @since 4.10
         */
        interface TextureScaleNode extends RenderNode {
            readonly $signals: TextureScaleNode.SignalSignatures
            readonly $readableProperties: TextureScaleNode.ReadableProperties
            readonly $writableProperties: TextureScaleNode.WritableProperties
            readonly $constructOnlyProperties: TextureScaleNode.ConstructOnlyProperties
            /**
             * Retrieves the `GskScalingFilter` used when creating this `GskRenderNode`.
             * @since 4.10
             * @returns the `GskScalingFilter`
             */
            get_filter(): ScalingFilter
            /**
             * Retrieves the `GdkTexture` used when creating this `GskRenderNode`.
             * @since 4.10
             * @returns the `GdkTexture`
             */
            get_texture(): Gdk.Texture
        }

        interface TextureScaleNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<TextureScaleNode>
            readonly prototype: TextureScaleNode
            new (props?: Partial<GObject.ConstructorProps<TextureScaleNode>>): TextureScaleNode
            /**
             * Creates a node that scales the texture to the size given by the
             * bounds using the filter and then places it at the bounds' position.
             *
             * Note that further scaling and other transformations which are
             * applied to the node will apply linear filtering to the resulting
             * texture, as usual.
             *
             * This node is intended for tight control over scaling applied
             * to a texture, such as in image editors and requires the
             * application to be aware of the whole render tree as further
             * transforms may be applied that conflict with the desired effect
             * of this node.
             * @since 4.10
             * @param texture the texture to scale
             * @param bounds the size of the texture to scale to
             * @param filter how to scale the texture
             * @returns A new `GskRenderNode`
             */
            "new"(texture: Gdk.Texture, bounds: Graphene.Rect, filter: ScalingFilter): TextureScaleNode
        }

        const TextureScaleNode: TextureScaleNodeClass
        

        namespace TransformNode {
            interface SignalSignatures extends RenderNode.SignalSignatures {
            }

            interface ReadableProperties extends RenderNode.ReadableProperties {
            }

            interface WritableProperties extends RenderNode.WritableProperties {
            }

            interface ConstructOnlyProperties extends RenderNode.ConstructOnlyProperties {
            }
        }

        /**
         * A render node applying a `GskTransform` to its single child node.
         */
        interface TransformNode extends RenderNode {
            readonly $signals: TransformNode.SignalSignatures
            readonly $readableProperties: TransformNode.ReadableProperties
            readonly $writableProperties: TransformNode.WritableProperties
            readonly $constructOnlyProperties: TransformNode.ConstructOnlyProperties
            /**
             * Gets the child node that is getting transformed by the given @node.
             * @returns The child that is getting transformed
             */
            get_child(): RenderNode
            /**
             * Retrieves the `GskTransform` used by the @node.
             * @returns a `GskTransform`
             */
            get_transform(): Transform
        }

        interface TransformNodeClass extends Omit<RenderNodeClass, "new"> {
            readonly $gtype: GObject.GType<TransformNode>
            readonly prototype: TransformNode
            new (props?: Partial<GObject.ConstructorProps<TransformNode>>): TransformNode
            /**
             * Creates a `GskRenderNode` that will transform the given @child
             * with the given @transform.
             * @param child The node to transform
             * @param transform The transform to apply
             * @returns A new `GskRenderNode`
             */
            "new"(child: RenderNode, transform: Transform | null): TransformNode
        }

        const TransformNode: TransformNodeClass
        

        namespace VulkanRenderer {
            interface SignalSignatures extends Renderer.SignalSignatures {
            }

            interface ReadableProperties extends Renderer.ReadableProperties {
            }

            interface WritableProperties extends Renderer.WritableProperties {
            }

            interface ConstructOnlyProperties extends Renderer.ConstructOnlyProperties {
            }
        }

        /**
         * Renders a GSK rendernode tree with Vulkan.
         *
         * This renderer will fail to realize if Vulkan is not supported.
         */
        interface VulkanRenderer extends Renderer {
            readonly $signals: VulkanRenderer.SignalSignatures
            readonly $readableProperties: VulkanRenderer.ReadableProperties
            readonly $writableProperties: VulkanRenderer.WritableProperties
            readonly $constructOnlyProperties: VulkanRenderer.ConstructOnlyProperties
        }

        interface VulkanRendererClass extends Omit<RendererClass, "new"> {
            readonly $gtype: GObject.GType<VulkanRenderer>
            readonly prototype: VulkanRenderer
            new (props?: Partial<GObject.ConstructorProps<VulkanRenderer>>): VulkanRenderer
            /**
             * Creates a new Vulkan renderer.
             *
             * The Vulkan renderer is a renderer that uses the Vulkan library for
             * rendering.
             *
             * This renderer will fail to realize when GTK was not compiled with
             * Vulkan support.
             * @returns a new Vulkan renderer
             */
            "new"(): VulkanRenderer
        }

        const VulkanRenderer: VulkanRendererClass
        none
        none
        /**
         * A color stop in a gradient node.
         */
        abstract class ColorStop {
            static readonly $gtype: GObject.GType<ColorStop>

            
            /**
             * the offset of the color stop
             */
            offset: number
            /**
             * the color at the given offset
             */
            color: Gdk.RGBA
        }
        /**
         * Specifies a transfer function for a color component to be applied
         * while rendering.
         *
         * The available functions include linear, piecewise-linear,
         * gamma and step functions.
         *
         * Note that the transfer function is applied to un-premultiplied
         * values, and all results are clamped to the [0, 1] range.
         * @since 4.20
         */
        abstract class ComponentTransfer {
            static readonly $gtype: GObject.GType<ComponentTransfer>

            
            /**
             * >
             * @since 4.20
             * @param values Values
             * @returns a new `GskComponentTransfer`
             */
            static new_discrete(values: number[]): ComponentTransfer
            /**
             * >
             * @since 4.20
             * @param amp Amplitude
             * @param exp Exponent
             * @param ofs Offset
             * @returns a new `GskComponentTransfer`
             */
            static new_gamma(amp: number, exp: number, ofs: number): ComponentTransfer
            /**
             * >
             * @since 4.20
             * @returns a new `GskComponentTransfer`
             */
            static new_identity(): ComponentTransfer
            /**
             * >
             * @since 4.20
             * @param n Number of levels
             * @returns a new `GskComponentTransfer`
             */
            static new_levels(n: number): ComponentTransfer
            /**
             * >
             * @since 4.20
             * @param m Slope
             * @param b Offset
             * @returns a new `GskComponentTransfer`
             */
            static new_linear(m: number, b: number): ComponentTransfer
            /**
             * >
             * @since 4.20
             * @param values Values
             * @returns a new `GskComponentTransfer`
             */
            static new_table(values: number[]): ComponentTransfer
            /**
             * Compares two component transfers for equality.
             * @since 4.20
             * @param self a component transfer
             * @param other another component transfer
             * @returns true if `self` and `other` are equal
             */
            static equal(self: never, other: never): boolean
            /**
             * Creates a copy of @other.
             * @since 4.20
             * @returns a newly allocated copy of `other`
             */
            copy(): ComponentTransfer
            /**
             * Frees a component transfer.
             * @since 4.20
             */
            free(): void
        }
        none
        none
        /**
         * A location in a parse buffer.
         */
        abstract class ParseLocation {
            static readonly $gtype: GObject.GType<ParseLocation>

            
            /**
             * the offset of the location in the parse buffer, as bytes
             */
            bytes: number
            /**
             * the offset of the location in the parse buffer, as characters
             */
            chars: number
            /**
             * the line of the location in the parse buffer
             */
            lines: number
            /**
             * the position in the line, as bytes
             */
            line_bytes: number
            /**
             * the position in the line, as characters
             */
            line_chars: number
        }
        /**
         * >
         * @since 4.14
         */
        abstract class Path {
            static readonly $gtype: GObject.GType<Path>

            
            /**
             * Constructs a path from a serialized form.
             *
             * The string is expected to be in (a superset of)
             * [SVG path syntax](https://www.w3.org/TR/SVG11/paths.html#PathData),
             * as e.g. produced by [method@Gsk.Path.to_string].
             *
             * A high-level summary of the syntax:
             *
             * - `M x y` Move to `(x, y)`
             * - `L x y` Add a line from the current point to `(x, y)`
             * - `Q x1 y1 x2 y2` Add a quadratic Bzier from the current point to `(x2, y2)`, with control point `(x1, y1)`
             * - `C x1 y1 x2 y2 x3 y3` Add a cubic Bzier from the current point to `(x3, y3)`, with control points `(x1, y1)` and `(x2, y2)`
             * - `Z` Close the contour by drawing a line back to the start point
             * - `H x` Add a horizontal line from the current point to the given x value
             * - `V y` Add a vertical line from the current point to the given y value
             * - `T x2 y2` Add a quadratic Bzier, using the reflection of the previous segments' control point as control point
             * - `S x2 y2 x3 y3` Add a cubic Bzier, using the reflection of the previous segments' second control point as first control point
             * - `A rx ry r l s x y` Add an elliptical arc from the current point to `(x, y)` with radii rx and ry. See the SVG documentation for how the other parameters influence the arc.
             * - `O x1 y1 x2 y2 w` Add a rational quadratic Bzier from the current point to `(x2, y2)` with control point `(x1, y1)` and weight `w`.
             *
             * All the commands have lowercase variants that interpret coordinates
             * relative to the current point.
             *
             * The `O` command is an extension that is not supported in SVG.
             * @since 4.14
             * @param string a string
             * @returns a new `GskPath`, or `NULL` if `string` could not be parsed
             */
            static parse(string: string): Path | null
            /**
             * Returns whether two paths have identical structure.
             *
             * Note that it is possible to construct paths that render
             * identical even though they don't have the same structure.
             * @since 4.22
             * @param path2 another path
             * @returns true if `path1` and `path2` have identical structure
             */
            equal(path2: Path): boolean
            /**
             * Calls @func for every operation of the path.
             *
             * Note that this may only approximate @self, because paths can contain
             * optimizations for various specialized contours, and depending on the
             * @flags, the path may be decomposed into simpler curves than the ones
             * that it contained originally.
             *
             * This function serves two purposes:
             *
             * - When the @flags allow everything, it provides access to the raw,
             *   unmodified data of the path.
             * - When the @flags disallow certain operations, it provides
             *   an approximation of the path using just the allowed operations.
             * @since 4.14
             * @param flags flags to pass to the foreach function
             * @param func the function to call for operations
             * @returns false if `func` returned false, true otherwise.
             */
            foreach(flags: PathForeachFlags, func: PathForeachFunc): boolean
            /**
             * Finds intersections between two paths.
             *
             * This function finds intersections between @path1 and @path2,
             * and calls @func for each of them, in increasing order for @path1.
             *
             * If @path2 is not provided or equal to @path1, the function finds
             * non-trivial self-intersections of @path1.
             *
             * When segments of the paths coincide, the callback is called once
             * for the start of the segment, with @GSK_PATH_INTERSECTION_START, and
             * once for the end of the segment, with @GSK_PATH_INTERSECTION_END.
             * Note that other intersections may occur between the start and end
             * of such a segment.
             *
             * If @func returns `FALSE`, the iteration is stopped.
             * @since 4.20
             * @param path2 the second path
             * @param func the function to call for intersections
             * @returns `FALSE` if `func` returned FALSE`, `TRUE` otherwise.
             */
            foreach_intersection(path2: Path | null, func: PathIntersectionFunc): boolean
            /**
             * Computes the bounds of the given path.
             *
             * The returned bounds may be larger than necessary, because this
             * function aims to be fast, not accurate. The bounds are guaranteed
             * to contain the path. For accurate bounds, use
             * [method@Gsk.Path.get_tight_bounds].
             *
             * It is possible that the returned rectangle has 0 width and/or height.
             * This can happen when the path only describes a point or an
             * axis-aligned line.
             *
             * If the path is empty, false is returned and @bounds are set to
             * graphene_rect_zero(). This is different from the case where the path
             * is a single point at the origin, where the @bounds will also be set to
             * the zero rectangle but true will be returned.
             * @since 4.14
             * @returns true if the path has bounds, false if the path is known   to be empty and have no bounds, return location for the bounds
             */
            get_bounds(): [boolean, Graphene.Rect]
            /**
             * Computes the closest point on the path to the given point.
             *
             * If there is no point closer than the given threshold,
             * false is returned.
             * @since 4.14
             * @param point the point
             * @param threshold maximum allowed distance
             * @returns true if `point` was set to the closest point   on `self`, false if no point is closer than `threshold`, return location for the closest point, return location for the distance
             */
            get_closest_point(point: Graphene.Point, threshold: number): [boolean, PathPoint]
            /**
             * Gets the end point of the path.
             *
             * An empty path has no points, so false
             * is returned in this case.
             * @since 4.14
             * @returns true if `result` was filled, return location for point
             */
            get_end_point(): [boolean, PathPoint]
            /**
             * Moves @point to the next vertex.
             *
             * An empty path has no points, so false
             * is returned in this case.
             * @since 4.22
             * @returns true if `point` was set, the current point
             */
            get_next(): [boolean, PathPoint]
            /**
             * Moves @point to the previous vertex.
             *
             * An empty path has no points, so false
             * is returned in this case.
             * @since 4.22
             * @returns true if `point` was set, the current point
             */
            get_previous(): [boolean, PathPoint]
            /**
             * Gets the start point of the path.
             *
             * An empty path has no points, so false
             * is returned in this case.
             * @since 4.14
             * @returns true if `result` was filled, return location for point
             */
            get_start_point(): [boolean, PathPoint]
            /**
             * Computes the bounds for stroking the given path with the
             * given parameters.
             *
             * The returned bounds may be larger than necessary, because this
             * function aims to be fast, not accurate. The bounds are guaranteed
             * to contain the area affected by the stroke, including protrusions
             * like miters.
             * @since 4.14
             * @param stroke stroke parameters
             * @returns true if the path has bounds, false if the path is known   to be empty and have no bounds., the bounds to fill in
             */
            get_stroke_bounds(stroke: Stroke): [boolean, Graphene.Rect]
            /**
             * Computes the tight bounds of the given path.
             *
             * This function works harder than [method@Gsk.Path.get_bounds] to
             * produce the smallest possible bounds.
             * @since 4.22
             * @returns true if the path has bounds, false if the path is known   to be empty and have no bounds, return location for the bounds
             */
            get_tight_bounds(): [boolean, Graphene.Rect]
            /**
             * Returns whether a point is inside the fill area of a path.
             *
             * Note that this function assumes that filling a contour
             * implicitly closes it.
             * @since 4.14
             * @param point the point to test
             * @param fill_rule the fill rule to follow
             * @returns true if `point` is inside
             */
            in_fill(point: Graphene.Point, fill_rule: FillRule): boolean
            /**
             * Returns if the path represents a single closed contour.
             * @since 4.14
             * @returns true if the path is closed
             */
            is_closed(): boolean
            /**
             * Checks if the path is empty, i.e. contains no lines or curves.
             * @since 4.14
             * @returns true if the path is empty
             */
            is_empty(): boolean
            /**
             * Converts the path into a human-readable representation.
             *
             * The string is compatible with (a superset of)
             * [SVG path syntax](https://www.w3.org/TR/SVG11/paths.html#PathData),
             * see [func@Gsk.Path.parse] for a summary of the syntax.
             * @since 4.14
             * @param string the string to print into
             */
            print(string: GLib.String): void
            /**
             * Increases the reference count of a path by one.
             * @since 4.14
             * @returns the passed in `GskPath`
             */
            ref(): Path
            /**
             * Appends the path to a cairo context for drawing with Cairo.
             *
             * This may cause some suboptimal conversions to be performed as
             * Cairo does not support all features of `GskPath`.
             *
             * This function does not clear the existing Cairo path. Call
             * cairo_new_path() if you want this.
             * @since 4.14
             * @param cr a cairo context
             */
            to_cairo(cr: cairo.Context): void
            /**
             * Converts the path into a human-readable string.
             *
             * You can use this function in a debugger to get a quick overview
             * of the path.
             *
             * This is a wrapper around [method@Gsk.Path.print], see that function
             * for details.
             * @since 4.14
             * @returns a new string for `self`
             */
            to_string(): string
            /**
             * Decreases the reference count of a path by one.
             *
             * If the resulting reference count is zero, frees the path.
             * @since 4.14
             */
            unref(): void
        }
        /**
         * Constructs `GskPath` objects.
         *
         * A path is constructed like this:
         *
         * ```c
         * GskPath *
         * construct_path (void)
         * {
         *   GskPathBuilder *builder;
         *
         *   builder = gsk_path_builder_new ();
         *
         *   // add contours to the path here
         *
         *   return gsk_path_builder_free_to_path (builder);
         * ```
         *
         * Adding contours to the path can be done in two ways.
         * The easiest option is to use the `gsk_path_builder_add_*` group
         * of functions that add predefined contours to the current path,
         * either common shapes like [method@Gsk.PathBuilder.add_circle]
         * or by adding from other paths like [method@Gsk.PathBuilder.add_path].
         *
         * The `gsk_path_builder_add_*` methods always add complete contours,
         * and do not use or modify the current point.
         *
         * The other option is to define each line and curve manually with
         * the `gsk_path_builder_*_to` group of functions. You start with
         * a call to [method@Gsk.PathBuilder.move_to] to set the starting point
         * and then use multiple calls to any of the drawing functions to
         * move the pen along the plane. Once you are done, you can call
         * [method@Gsk.PathBuilder.close] to close the path by connecting it
         * back with a line to the starting point.
         *
         * This is similar to how paths are drawn in Cairo.
         *
         * Note that `GskPathBuilder` will reduce the degree of added Bzier
         * curves as much as possible, to simplify rendering.
         * @since 4.14
         */
        abstract class PathBuilder {
            static readonly $gtype: GObject.GType<PathBuilder>

            
            /**
             * Create a new `GskPathBuilder` object.
             *
             * The resulting builder would create an empty `GskPath`.
             * Use addition functions to add types to it.
             * @since 4.14
             * @returns a new `GskPathBuilder`
             */
            static "new"(): PathBuilder
            /**
             * Adds a Cairo path to the builder.
             *
             * You can use cairo_copy_path() to access the path
             * from a Cairo context.
             * @since 4.14
             * @param path a path
             */
            add_cairo_path(path: cairo.Path): void
            /**
             * Adds a circle as a new contour.
             *
             * The path is going around the circle in clockwise direction.
             *
             * If @radius is zero, the contour will be a closed point.
             * @since 4.14
             * @param center the center of the circle
             * @param radius the radius of the circle
             */
            add_circle(center: Graphene.Point, radius: number): void
            /**
             * Adds the outlines for the glyphs in @layout to the builder.
             * @since 4.14
             * @param layout the pango layout to add
             */
            add_layout(layout: Pango.Layout): void
            /**
             * Appends all of @path to the builder.
             * @since 4.14
             * @param path the path to append
             */
            add_path(path: Path): void
            /**
             * Adds a rectangle as a new contour.
             *
             * The path is going around the rectangle in clockwise direction.
             *
             * If the the width or height are 0, the path will be a closed
             * horizontal or vertical line. If both are 0, it'll be a closed dot.
             * @since 4.14
             * @param rect the rectangle to create a path for
             */
            add_rect(rect: Graphene.Rect): void
            /**
             * Appends all of @path to the builder, in reverse order.
             * @since 4.14
             * @param path the path to append
             */
            add_reverse_path(path: Path): void
            /**
             * Adds a rounded rectangle as a new contour.
             *
             * The path is going around the rectangle in clockwise direction.
             * @since 4.14
             * @param rect the rounded rect
             */
            add_rounded_rect(rect: RoundedRect): void
            /**
             * Adds a segment of a path to the builder.
             *
             * If @start is equal to or after @end, the path will first add the
             * segment from @start to the end of the path, and then add the segment
             * from the beginning to @end. If the path is closed, these segments
             * will be connected.
             *
             * Note that this method always adds a path with the given start point
             * and end point. To add a closed path, use [method@Gsk.PathBuilder.add_path].
             * @since 4.14
             * @param path the path to take the segment to
             * @param start the point on @path to start at
             * @param end the point on @path to end at
             */
            add_segment(path: Path, start: PathPoint, end: PathPoint): void
            /**
             * >
             * @since 4.14
             * @param x1 x coordinate of first control point
             * @param y1 y coordinate of first control point
             * @param x2 x coordinate of second control point
             * @param y2 y coordinate of second control point
             */
            arc_to(x1: number, y1: number, x2: number, y2: number): void
            /**
             * Ends the current contour with a line back to the start point.
             *
             * Note that this is different from calling [method@Gsk.PathBuilder.line_to]
             * with the start point in that the contour will be closed. A closed
             * contour behaves differently from an open one. When stroking, its
             * start and end point are considered connected, so they will be
             * joined via the line join, and not ended with line caps.
             * @since 4.14
             */
            close(): void
            /**
             * >
             * @since 4.14
             * @param x1 x coordinate of control point
             * @param y1 y coordinate of control point
             * @param x2 x coordinate of the end of the curve
             * @param y2 y coordinate of the end of the curve
             * @param weight weight of the control point, must be greater than zero
             */
            conic_to(x1: number, y1: number, x2: number, y2: number, weight: number): void
            /**
             * >
             * @since 4.14
             * @param x1 x coordinate of first control point
             * @param y1 y coordinate of first control point
             * @param x2 x coordinate of second control point
             * @param y2 y coordinate of second control point
             * @param x3 x coordinate of the end of the curve
             * @param y3 y coordinate of the end of the curve
             */
            cubic_to(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void
            /**
             * Gets the current point.
             *
             * The current point is used for relative drawing commands and
             * updated after every operation.
             *
             * When the builder is created, the default current point is set
             * to `0, 0`. Note that this is different from cairo, which starts
             * out without a current point.
             * @since 4.14
             * @returns the current point
             */
            get_current_point(): Graphene.Point
            /**
             * Implements arc-to according to the HTML Canvas spec.
             *
             * A convenience function that implements the
             * [HTML arc_to](https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-arcto-dev)
             * functionality.
             *
             * After this, the current point will be the point where
             * the circle with the given radius touches the line from
             * @x1, @y1 to @x2, @y2.
             * @since 4.14
             * @param x1 x coordinate of first control point
             * @param y1 y coordinate of first control point
             * @param x2 x coordinate of second control point
             * @param y2 y coordinate of second control point
             * @param radius radius of the circle
             */
            html_arc_to(x1: number, y1: number, x2: number, y2: number, radius: number): void
            /**
             * >
             * @since 4.14
             * @param x x coordinate
             * @param y y coordinate
             */
            line_to(x: number, y: number): void
            /**
             * Starts a new contour by placing the pen at @x, @y.
             *
             * If this function is called twice in succession, the first
             * call will result in a contour made up of a single point.
             * The second call will start a new contour.
             * @since 4.14
             * @param x x coordinate
             * @param y y coordinate
             */
            move_to(x: number, y: number): void
            /**
             * >
             * @since 4.14
             * @param x1 x coordinate of control point
             * @param y1 y coordinate of control point
             * @param x2 x coordinate of the end of the curve
             * @param y2 y coordinate of the end of the curve
             */
            quad_to(x1: number, y1: number, x2: number, y2: number): void
            /**
             * Acquires a reference on the given builder.
             *
             * This function is intended primarily for language bindings.
             * `GskPathBuilder` objects should not be kept around.
             * @since 4.14
             * @returns the given path builder with   its reference count increased
             */
            ref(): PathBuilder
            /**
             * Adds an elliptical arc from the current point to @x2, @y2
             * with @x1, @y1 determining the tangent directions.
             *
             * All coordinates are given relative to the current point.
             *
             * This is the relative version of [method@Gsk.PathBuilder.arc_to].
             * @since 4.14
             * @param x1 x coordinate of first control point
             * @param y1 y coordinate of first control point
             * @param x2 x coordinate of second control point
             * @param y2 y coordinate of second control point
             */
            rel_arc_to(x1: number, y1: number, x2: number, y2: number): void
            /**
             * Adds a [conic curve](https://en.wikipedia.org/wiki/Non-uniform_rational_B-spline)
             * from the current point to @x2, @y2 with the given @weight and @x1, @y1 as the
             * control point.
             *
             * All coordinates are given relative to the current point.
             *
             * This is the relative version of [method@Gsk.PathBuilder.conic_to].
             * @since 4.14
             * @param x1 x offset of control point
             * @param y1 y offset of control point
             * @param x2 x offset of the end of the curve
             * @param y2 y offset of the end of the curve
             * @param weight weight of the curve, must be greater than zero
             */
            rel_conic_to(x1: number, y1: number, x2: number, y2: number, weight: number): void
            /**
             * Adds a [cubic Bzier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)
             * from the current point to @x3, @y3 with @x1, @y1 and @x2, @y2 as the control
             * points.
             *
             * All coordinates are given relative to the current point.
             *
             * This is the relative version of [method@Gsk.PathBuilder.cubic_to].
             * @since 4.14
             * @param x1 x offset of first control point
             * @param y1 y offset of first control point
             * @param x2 x offset of second control point
             * @param y2 y offset of second control point
             * @param x3 x offset of the end of the curve
             * @param y3 y offset of the end of the curve
             */
            rel_cubic_to(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void
            /**
             * Implements arc-to according to the HTML Canvas spec.
             *
             * All coordinates are given relative to the current point.
             *
             * This is the relative version of [method@Gsk.PathBuilder.html_arc_to].
             * @since 4.14
             * @param x1 x coordinate of first control point
             * @param y1 y coordinate of first control point
             * @param x2 x coordinate of second control point
             * @param y2 y coordinate of second control point
             * @param radius radius of the circle
             */
            rel_html_arc_to(x1: number, y1: number, x2: number, y2: number, radius: number): void
            /**
             * Draws a line from the current point to a point offset from it
             * by @x, @y and makes it the new current point.
             *
             * This is the relative version of [method@Gsk.PathBuilder.line_to].
             * @since 4.14
             * @param x x offset
             * @param y y offset
             */
            rel_line_to(x: number, y: number): void
            /**
             * Starts a new contour by placing the pen at @x, @y
             * relative to the current point.
             *
             * This is the relative version of [method@Gsk.PathBuilder.move_to].
             * @since 4.14
             * @param x x offset
             * @param y y offset
             */
            rel_move_to(x: number, y: number): void
            /**
             * Adds a [quadratic Bzier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)
             * from the current point to @x2, @y2 with @x1, @y1 the control point.
             *
             * All coordinates are given relative to the current point.
             *
             * This is the relative version of [method@Gsk.PathBuilder.quad_to].
             * @since 4.14
             * @param x1 x offset of control point
             * @param y1 y offset of control point
             * @param x2 x offset of the end of the curve
             * @param y2 y offset of the end of the curve
             */
            rel_quad_to(x1: number, y1: number, x2: number, y2: number): void
            /**
             * Implements arc-to according to the SVG spec.
             *
             * All coordinates are given relative to the current point.
             *
             * This is the relative version of [method@Gsk.PathBuilder.svg_arc_to].
             * @since 4.14
             * @param rx x radius
             * @param ry y radius
             * @param x_axis_rotation the rotation of the ellipsis
             * @param large_arc whether to add the large arc
             * @param positive_sweep whether to sweep in the positive direction
             * @param x x coordinate of the endpoint
             * @param y y coordinate of the endpoint
             */
            rel_svg_arc_to(rx: number, ry: number, x_axis_rotation: number, large_arc: boolean, positive_sweep: boolean, x: number, y: number): void
            /**
             * Implements arc-to according to the SVG spec.
             *
             * A convenience function that implements the
             * [SVG arc_to](https://www.w3.org/TR/SVG11/paths.html#PathDataEllipticalArcCommands)
             * functionality.
             *
             * After this, @x, @y will be the new current point.
             * @since 4.14
             * @param rx x radius
             * @param ry y radius
             * @param x_axis_rotation the rotation of the ellipsis
             * @param large_arc whether to add the large arc
             * @param positive_sweep whether to sweep in the positive direction
             * @param x x coordinate of the endpoint
             * @param y y coordinate of the endpoint
             */
            svg_arc_to(rx: number, ry: number, x_axis_rotation: number, large_arc: boolean, positive_sweep: boolean, x: number, y: number): void
            /**
             * Creates a new path from the given builder.
             *
             * The given `GskPathBuilder` is reset to the initial state once this
             * function returns. Calling this function again on the same builder
             * instance will therefore produce an empty path, not a copy of the same
             * path.
             *
             * This function is intended primarily for language bindings.
             * C code should use [method@Gsk.PathBuilder.free_to_path].
             * @since 4.14
             * @returns the newly created path   with all the contours added to the builder
             */
            to_path(): Path
            /**
             * Releases a reference on the given builder.
             * @since 4.14
             */
            unref(): void
        }
        /**
         * Performs measurements on paths such as determining the length of the path.
         *
         * Many measuring operations require sampling the path length
         * at intermediate points. Therefore, a `GskPathMeasure` has
         * a tolerance that determines what precision is required
         * for such approximations.
         *
         * A `GskPathMeasure` struct is a reference counted struct
         * and should be treated as opaque.
         * @since 4.14
         */
        abstract class PathMeasure {
            static readonly $gtype: GObject.GType<PathMeasure>

            
            /**
             * Creates a measure object for the given @path with the
             * default tolerance.
             * @since 4.14
             * @param path the path to measure
             * @returns a new `GskPathMeasure` representing `path`
             */
            static "new"(path: Path): PathMeasure
            /**
             * Creates a measure object for the given @path and @tolerance.
             * @since 4.14
             * @param path the path to measure
             * @param tolerance the tolerance for measuring operations
             * @returns a new `GskPathMeasure` representing `path`
             */
            static new_with_tolerance(path: Path, tolerance: number): PathMeasure
            /**
             * Gets the length of the path being measured.
             *
             * The length is cached, so this function does not do any work.
             * @since 4.14
             * @returns the length of the path measured by `self`
             */
            get_length(): number
            /**
             * Returns the path that the measure was created for.
             * @since 4.14
             * @returns the path of `self`
             */
            get_path(): Path
            /**
             * Gets the point at the given distance into the path.
             *
             * An empty path has no points, so false is returned in that case.
             * @since 4.14
             * @param distance the distance
             * @returns true if `result` was set, return location for the point
             */
            get_point(distance: number): [boolean, PathPoint]
            /**
             * Returns the tolerance that the measure was created with.
             * @since 4.14
             * @returns the tolerance of `self`
             */
            get_tolerance(): number
            /**
             * Increases the reference count of a `GskPathMeasure` by one.
             * @since 4.14
             * @returns the passed in `GskPathMeasure`.
             */
            ref(): PathMeasure
            /**
             * Decreases the reference count of a `GskPathMeasure` by one.
             *
             * If the resulting reference count is zero, frees the object.
             * @since 4.14
             */
            unref(): void
        }
        /**
         * Represents a point on a path.
         *
         * It can be queried for properties of the path at that point,
         * such as its tangent or its curvature.
         *
         * To obtain a `GskPathPoint`, use [method@Gsk.Path.get_closest_point],
         * [method@Gsk.Path.get_start_point], [method@Gsk.Path.get_end_point]
         * or [method@Gsk.PathMeasure.get_point].
         *
         * Note that `GskPathPoint` structs are meant to be stack-allocated,
         * and don't hold a reference to the path object they are obtained from.
         * It is the callers responsibility to keep a reference to the path
         * as long as the `GskPathPoint` is used.
         * @since 4.14
         */
        abstract class PathPoint {
            static readonly $gtype: GObject.GType<PathPoint>

            
            /**
             * Returns whether @point1 is before or after @point2.
             * @since 4.14
             * @param point2 another path point
             * @returns -1 if `point1` is before `point2`,   1 if `point1` is after `point2`,   0 if they are equal
             */
            compare(point2: PathPoint): number
            /**
             * Copies a path point.
             * @since 4.14
             * @returns the copied point
             */
            copy(): PathPoint
            /**
             * Returns whether the two path points refer to the same
             * location on all paths.
             *
             * Note that the start- and endpoint of a closed contour
             * will compare nonequal according to this definition.
             * Use [method@Gsk.Path.is_closed] to find out if the
             * start- and endpoint of a concrete path refer to the
             * same location.
             * @since 4.14
             * @param point2 another path point
             * @returns true if `point1` and `point2` are equal
             */
            equal(point2: PathPoint): boolean
            /**
             * Frees a path point copied by [method@Gsk.PathPoint.copy].
             * @since 4.14
             */
            free(): void
            /**
             * >
             * @since 4.14
             * @param path the path that @point is on
             * @param direction the direction for which to return the curvature
             * @returns the curvature of the path at the given point, return location for   the center of the osculating circle
             */
            get_curvature(path: Path, direction: PathDirection): [number, Graphene.Point | null]
            /**
             * Returns the distance from the beginning of the path
             * to the point.
             * @since 4.14
             * @param measure a path measure for the path
             * @returns the distance of `point`
             */
            get_distance(measure: PathMeasure): number
            /**
             * Gets the position of the point.
             * @since 4.14
             * @param path the path that @point is on
             * @returns , Return location for   the coordinates of the point
             */
            get_position(path: Path): Graphene.Point
            /**
             * Gets the direction of the tangent at a given point.
             *
             * This is a convenience variant of [method@Gsk.PathPoint.get_tangent]
             * that returns the angle between the tangent and the X axis. The angle
             * can e.g. be used in
             * [gtk_snapshot_rotate()](../gtk4/method.Snapshot.rotate.html).
             * @since 4.14
             * @param path the path that @point is on
             * @param direction the direction for which to return the rotation
             * @returns the angle between the tangent and the X axis, in degrees
             */
            get_rotation(path: Path, direction: PathDirection): number
            /**
             * Gets the tangent of the path at the point.
             *
             * Note that certain points on a path may not have a single
             * tangent, such as sharp turns. At such points, there are
             * two tangents  the direction of the path going into the
             * point, and the direction coming out of it. The @direction
             * argument lets you choose which one to get.
             *
             * If the path is just a single point (e.g. a circle with
             * radius zero), then the tangent is set to `0, 0`.
             *
             * If you want to orient something in the direction of the
             * path, [method@Gsk.PathPoint.get_rotation] may be more
             * convenient to use.
             * @since 4.14
             * @param path the path that @point is on
             * @param direction the direction for which to return the tangent
             * @returns , Return location for   the tangent at the point
             */
            get_tangent(path: Path, direction: PathDirection): Graphene.Vec2
        }
        /**
         * bounds);
         *     }
         *   else
         *     {
         *       result = gsk_render_replay_default (replay, node);
         *     }
         *
         *   return result;
         * }
         *
         * int
         * main (int argc, char *argv[])
         * {
         *   GFile *file;
         *   GBytes *bytes;
         *   GskRenderNode *result, *node;
         *   GskRenderReplay *replay;
         *
         *   gtk_init ();
         *
         *   if (argc != 3)
         *     {
         *       g_print ("usage: %s INFILE OUTFILE\n", argv[0]);
         *       return 0;
         *     }
         *
         *   file = g_file_new_for_commandline_arg (argv[1]);
         *   bytes = g_file_load_bytes (file, NULL, NULL, NULL);
         *   g_object_unref (file);
         *   if (bytes == NULL)
         *     return 1;
         *
         *   node = gsk_render_node_deserialize (bytes, NULL, NULL);
         *   g_bytes_unref (bytes);
         *   if (node == NULL)
         *     return 1;
         *
         *   replay = gsk_render_replay_new ();
         *   gsk_render_replay_set_node_filter (replay, redact_nodes, NULL, NULL);
         *   result = gsk_render_replay_filter_node (replay, node);
         *   gsk_render_replay_free (replay);
         *
         *   if (!gsk_render_node_write_to_file (result, argv[2], NULL))
         *     return 1;
         *
         *   gsk_render_node_unref (result);
         *   gsk_render_node_unref (node);
         *
         *   return 0;
         * }
         * ```
         * @since 4.22
         */
        abstract class RenderReplay {
            static readonly $gtype: GObject.GType<RenderReplay>

            
            /**
             * Creates a new replay object to replay nodes.
             * @since 4.22
             * @returns A new replay object to replay nodes
             */
            static "new"(): RenderReplay
            /**
             * Replays the node using the default method.
             *
             * The default method calls [method@Gsk.RenderReplay.filter_node]
             * on all its child nodes and the filter functions for all its
             * properties. If none of them are changed, it returns the passed
             * in node. Otherwise it constructs a new node with the changed
             * children and properties.
             *
             * It may not be possible to construct a new node when any of the
             * callbacks return NULL. In that case, this function will return
             * NULL, too.
             * @since 4.22
             * @param node the node to replay
             * @returns The replayed node
             */
            default(node: RenderNode): RenderNode | null
            /**
             * Filters a font using the current filter function.
             * @since 4.22
             * @param font The font to filter
             * @returns the filtered font
             */
            filter_font(font: Pango.Font): Pango.Font
            /**
             * Replays a node using the replay's filter function.
             *
             * After the replay the node may be unchanged, or it may be
             * removed, which will result in %NULL being returned.
             *
             * If no filter node is set, [method@Gsk.RenderReplay.default] is
             * called instead.
             * @since 4.22
             * @param node the node to replay
             * @returns The replayed node
             */
            filter_node(node: RenderNode): RenderNode | null
            /**
             * Filters a texture using the current filter function.
             * @since 4.22
             * @param texture The texture to filter
             * @returns the filtered texture
             */
            filter_texture(texture: Gdk.Texture): Gdk.Texture
            /**
             * Frees a `GskRenderReplay`.
             * @since 4.22
             */
            free(): void
            /**
             * Sets a filter function to be called by [method@Gsk.RenderReplay.default]
             * for nodes that contain fonts.
             *
             * You can call [method@GskRenderReplay.filter_font] to filter
             * a font yourself.
             * @since 4.22
             * @param filter 
              the font filter function
             */
            set_font_filter(filter: RenderReplayFontFilter | null): void
            /**
             * Sets the function to use as a node filter.
             *
             * This is the most complex function to use for replaying nodes.
             * It can either:
             *
             * * keep the node and just return it unchanged
             *
             * * create a replacement node and return that
             *
             * * discard the node by returning `NULL`
             *
             * * call [method@Gsk.RenderReplay.default] to have the default handler
             *   run for this node, which calls your function on its children
             * @since 4.22
             * @param filter 
              the function to call to replay nodes
             */
            set_node_filter(filter: RenderReplayNodeFilter | null): void
            /**
             * Sets a filter function to be called by [method@Gsk.RenderReplay.default]
             * for nodes that contain textures.
             *
             * You can call [method@GskRenderReplay.filter_texture] to filter
             * a texture yourself.
             * @since 4.22
             * @param filter 
              the texture filter function
             */
            set_texture_filter(filter: RenderReplayTextureFilter | null): void
        }
        none
        /**
         * A rectangular region with rounded corners.
         *
         * Application code should normalize rectangles using
         * [method@Gsk.RoundedRect.normalize]; this function will ensure that
         * the bounds of the rectangle are normalized and ensure that the corner
         * values are positive and the corners do not overlap.
         *
         * All functions taking a `GskRoundedRect` as an argument will internally
         * operate on a normalized copy; all functions returning a `GskRoundedRect`
         * will always return a normalized one.
         *
         * The algorithm used for normalizing corner sizes is described in
         * [the CSS specification](https://drafts.csswg.org/css-backgrounds-3/#border-radius).
         */
        abstract class RoundedRect {
            static readonly $gtype: GObject.GType<RoundedRect>

            
            /**
             * the bounds of the rectangle
             */
            bounds: Graphene.Rect
            /**
             * the size of the 4 rounded corners
             */
            corner: Graphene.Size[]
            /**
             * Checks if the given point is inside the rounded rectangle.
             * @param point the point to check
             * @returns true if the point is inside the rounded rectangle
             */
            contains_point(point: Graphene.Point): boolean
            /**
             * Checks if the given rectangle is contained inside the rounded rectangle.
             * @param rect the rectangle to check
             * @returns true if the `rect` is fully contained inside the rounded rectangle
             */
            contains_rect(rect: Graphene.Rect): boolean
            /**
             * Initializes a rounded rectangle with the given values.
             *
             * This function will implicitly normalize the rounded rectangle
             * before returning.
             * @param bounds a `graphene_rect_t` describing the bounds
             * @param top_left the rounding radius of the top left corner
             * @param top_right the rounding radius of the top right corner
             * @param bottom_right the rounding radius of the bottom right corner
             * @param bottom_left the rounding radius of the bottom left corner
             * @returns the initialized rounded rectangle
             */
            init(bounds: Graphene.Rect, top_left: Graphene.Size, top_right: Graphene.Size, bottom_right: Graphene.Size, bottom_left: Graphene.Size): RoundedRect
            /**
             * Initializes a rounded rectangle with a copy.
             *
             * This function will not normalize the rounded rectangle,
             * so make sure the source is normalized.
             * @param src another rounded rectangle
             * @returns the initialized rounded rectangle
             */
            init_copy(src: RoundedRect): RoundedRect
            /**
             * Initializes a rounded rectangle to the given bounds
             * and sets the radius of all four corners equally.
             * @param bounds a `graphene_rect_t`
             * @param radius the border radius
             * @returns the initialized rounded rectangle
             */
            init_from_rect(bounds: Graphene.Rect, radius: number): RoundedRect
            /**
             * Checks if part a rectangle is contained
             * inside the rounded rectangle.
             * @param rect the rectangle to check
             * @returns true if the `rect` intersects with the rounded rectangle
             */
            intersects_rect(rect: Graphene.Rect): boolean
            /**
             * Checks if all corners of a rounded rectangle are right angles
             * and the rectangle covers all of its bounds.
             *
             * This information can be used to decide if [ctor@Gsk.ClipNode.new]
             * or [ctor@Gsk.RoundedClipNode.new] should be called.
             * @returns true if the rounded rectangle is rectilinear
             */
            is_rectilinear(): boolean
            /**
             * Normalizes a rounded rectangle.
             *
             * This function will ensure that the bounds of the rounded rectangle
             * are normalized and ensure that the corner values are positive
             * and the corners do not overlap.
             * @returns the normalized rounded rectangle
             */
            normalize(): RoundedRect
            /**
             * Offsets the rounded rectangle's origin by @dx and @dy.
             *
             * The size and corners of the rounded rectangle are unchanged.
             * @param dx the horizontal offset
             * @param dy the vertical offset
             * @returns the offset rounded rectangle
             */
            offset(dx: number, dy: number): RoundedRect
            /**
             * Shrinks (or grows) a rounded rectangle by moving the 4 sides
             * according to the offsets given.
             *
             * The corner radii will be changed in a way that tries to keep
             * the center of the corner circle intact. This emulates CSS behavior.
             *
             * This function also works for growing rounded rectangles
             * if you pass negative values for the @top, @right, @bottom or @left.
             * @param top how far to move the top side downwards
             * @param right how far to move the right side to the left
             * @param bottom how far to move the bottom side upwards
             * @param left how far to move the left side to the right
             * @returns the resized rounded rectangle
             */
            shrink(top: number, right: number, bottom: number, left: number): RoundedRect
        }
        /**
         * Builds the uniforms data for a `GskGLShader`.
         * @deprecated since 4.16
         */
        abstract class ShaderArgsBuilder {
            static readonly $gtype: GObject.GType<ShaderArgsBuilder>

            
            /**
             * Allocates a builder that can be used to construct a new uniform data
             * chunk.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param shader a `GskGLShader`
             * @param initial_values optional `GBytes` with initial values
             * @returns The newly allocated builder, free with     [method@Gsk.ShaderArgsBuilder.unref]
             */
            static "new"(shader: GLShader, initial_values: GLib.Bytes | null): ShaderArgsBuilder
            /**
             * Increases the reference count of a `GskShaderArgsBuilder` by one.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @returns the passed in `GskShaderArgsBuilder`
             */
            ref(): ShaderArgsBuilder
            /**
             * Sets the value of the uniform @idx.
             *
             * The uniform must be of bool type.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param idx index of the uniform
             * @param value value to set the uniform to
             */
            set_bool(idx: number, value: boolean): void
            /**
             * Sets the value of the uniform @idx.
             *
             * The uniform must be of float type.
             * @param idx index of the uniform
             * @param value value to set the uniform to
             */
            set_float(idx: number, value: number): void
            /**
             * Sets the value of the uniform @idx.
             *
             * The uniform must be of int type.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param idx index of the uniform
             * @param value value to set the uniform to
             */
            set_int(idx: number, value: number): void
            /**
             * Sets the value of the uniform @idx.
             *
             * The uniform must be of uint type.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param idx index of the uniform
             * @param value value to set the uniform to
             */
            set_uint(idx: number, value: number): void
            /**
             * Sets the value of the uniform @idx.
             *
             * The uniform must be of vec2 type.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param idx index of the uniform
             * @param value value to set the uniform too
             */
            set_vec2(idx: number, value: Graphene.Vec2): void
            /**
             * Sets the value of the uniform @idx.
             *
             * The uniform must be of vec3 type.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param idx index of the uniform
             * @param value value to set the uniform too
             */
            set_vec3(idx: number, value: Graphene.Vec3): void
            /**
             * Sets the value of the uniform @idx.
             *
             * The uniform must be of vec4 type.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @param idx index of the uniform
             * @param value value to set the uniform too
             */
            set_vec4(idx: number, value: Graphene.Vec4): void
            /**
             * Creates a new `GBytes` args from the current state of the
             * given @builder.
             *
             * Any uniforms of the shader that have not been explicitly set on
             * the @builder are zero-initialized.
             *
             * The given `GskShaderArgsBuilder` is reset once this function returns;
             * you cannot call this function multiple times on the same @builder instance.
             *
             * This function is intended primarily for bindings. C code should use
             * [method@Gsk.ShaderArgsBuilder.free_to_args].
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             * @returns the newly allocated buffer with   all the args added to `builder`
             */
            to_args(): GLib.Bytes
            /**
             * Decreases the reference count of a `GskShaderArgBuilder` by one.
             *
             * If the resulting reference count is zero, frees the builder.
             * @deprecated since 4.16 GTK's new Vulkan-focused rendering   does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)   for OpenGL rendering.
             */
            unref(): void
        }
        /**
         * The shadow parameters in a shadow node.
         */
        abstract class Shadow {
            static readonly $gtype: GObject.GType<Shadow>

            
            /**
             * the color of the shadow
             */
            color: Gdk.RGBA
            /**
             * the horizontal offset of the shadow
             */
            dx: number
            /**
             * the vertical offset of the shadow
             */
            dy: number
            /**
             * the radius of the shadow
             */
            radius: number
        }
        /**
         * Collects the parameters that are needed when stroking a path.
         * @since 4.14
         */
        abstract class Stroke {
            static readonly $gtype: GObject.GType<Stroke>

            
            /**
             * Creates a new `GskStroke` with the given @line_width.
             * @since 4.14
             * @param line_width  0
             * @returns a new `GskStroke`
             */
            static "new"(line_width: number): Stroke
            /**
             * Checks if two strokes are identical.
             * @since 4.14
             * @param stroke1 the first stroke
             * @param stroke2 the second stroke
             * @returns true if the two strokes are equal, false otherwise
             */
            static equal(stroke1: never | null, stroke2: never | null): boolean
            /**
             * Creates a copy of a `GskStroke`.
             * @since 4.14
             * @returns a new `GskStroke`. Use [method@Gsk.Stroke.free] to free it
             */
            copy(): Stroke
            /**
             * Frees a `GskStroke`.
             * @since 4.14
             */
            free(): void
            /**
             * Gets the dash array in use.
             * @since 4.14
             * @returns    the dash array or `NULL` if the dash array is empty
             */
            get_dash(): number[] | null
            /**
             * Gets the dash offset.
             * @since 4.14
             * @returns the dash offset
             */
            get_dash_offset(): number
            /**
             * Gets the line cap used.
             *
             * See [enum@Gsk.LineCap] for details.
             * @since 4.14
             * @returns the line cap
             */
            get_line_cap(): LineCap
            /**
             * Gets the line join used.
             *
             * See [enum@Gsk.LineJoin] for details.
             * @since 4.14
             * @returns the line join
             */
            get_line_join(): LineJoin
            /**
             * Gets the line width used.
             * @since 4.14
             * @returns the line width
             */
            get_line_width(): number
            /**
             * Gets the miter limit.
             * @since 4.14
             * @returns the miter limit
             */
            get_miter_limit(): number
            /**
             * Sets the dash pattern to use.
             *
             * A dash pattern is specified by an array of alternating non-negative
             * values. Each value provides the length of alternate "on" and "off"
             * portions of the stroke.
             *
             * Each "on" segment will have caps applied as if the segment were a
             * separate contour. In particular, it is valid to use an "on" length
             * of 0 with [enum@Gsk.LineCap.round] or [enum@Gsk.LineCap.square]
             * to draw dots or squares along a path.
             *
             * If @n_dash is 0, if all elements in @dash are 0, or if there are
             * negative values in @dash, then dashing is disabled.
             *
             * If @n_dash is 1, an alternating "on" and "off" pattern with the
             * single dash length provided is assumed.
             *
             * If @n_dash is uneven, the dash array will be used with the first
             * element in @dash defining an "on" or "off" in alternating passes
             * through the array.
             *
             * You can specify a starting offset into the dash with
             * [method@Gsk.Stroke.set_dash_offset].
             * @since 4.14
             * @param dash 
              the array of dashes
             */
            set_dash(dash: number[] | null): void
            /**
             * Sets the offset into the dash pattern where dashing should begin.
             *
             * This is an offset into the length of the path, not an index into
             * the array values of the dash array.
             *
             * See [method@Gsk.Stroke.set_dash] for more details on dashing.
             * @since 4.14
             * @param offset offset into the dash pattern
             */
            set_dash_offset(offset: number): void
            /**
             * Sets the line cap to be used when stroking.
             *
             * See [enum@Gsk.LineCap] for details.
             * @since 4.14
             * @param line_cap the line cap
             */
            set_line_cap(line_cap: LineCap): void
            /**
             * Sets the line join to be used when stroking.
             *
             * See [enum@Gsk.LineJoin] for details.
             * @since 4.14
             * @param line_join the line join to use
             */
            set_line_join(line_join: LineJoin): void
            /**
             * = 0.
             * @since 4.14
             * @param line_width width of the line in pixels
             */
            set_line_width(line_width: number): void
            /**
             * Sets the miter limit to be used when stroking.
             *
             * The miter limit is the distance from the corner where sharp
             * turns of joins get cut off.
             *
             * The limit is specfied in units of line width and must be non-negative.
             *
             * For joins of type [enum@Gsk.LineJoin.miter] that exceed the miter limit,
             * the join gets rendered as if it was of type [enum@Gsk.LineJoin.bevel].
             * @since 4.14
             * @param limit the miter limit
             */
            set_miter_limit(limit: number): void
            /**
             * A helper function that sets the stroke parameters
             * of a cairo context from a `GskStroke`.
             * @since 4.14
             * @param cr the cairo context to configure
             */
            to_cairo(cr: cairo.Context): void
        }
        /**
         * Describes a 3D transform.
         *
         * Unlike `graphene_matrix_t`, `GskTransform` retains the steps in how
         * a transform was constructed, and allows inspecting them. It is modeled
         * after the way CSS describes transforms.
         *
         * `GskTransform` objects are immutable and cannot be changed after creation.
         * This means code can safely expose them as properties of objects without
         * having to worry about others changing them.
         */
        abstract class Transform {
            static readonly $gtype: GObject.GType<Transform>

            
            /**
             * Creates a new identity transform.
             *
             * This function is meant to be used by language
             * bindings. For C code, this is equivalent to using `NULL`.
             * @returns A new identity transform
             */
            static "new"(): Transform
            /**
             * Parses a given into a transform.
             *
             * Strings printed via [method@Gsk.Transform.to_string]
             * can be read in again successfully using this function.
             *
             * If @string does not describe a valid transform, false
             * is returned and `NULL` is put in @out_transform.
             * @param string the string to parse
             * @returns true if `string` described a valid transform, return location for the transform
             */
            static parse(string: string): [boolean, Transform]
            /**
             * Checks two transforms for equality.
             * @param second the second transform
             * @returns true if the two transforms perform the same operation
             */
            equal(second: Transform | null): boolean
            /**
             * Returns the category this transform belongs to.
             * @returns The category of the transform
             */
            get_category(): TransformCategory
            /**
             * Inverts the given transform.
             *
             * If @self is not invertible, `NULL` is returned.
             * Note that inverting `NULL` also returns `NULL`, which is
             * the correct inverse of `NULL`. If you need to differentiate
             * between those cases, you should check @self is not `NULL`
             * before calling this function.
             *
             * This function consumes @self. Use [method@Gsk.Transform.ref] first
             * if you want to keep it around.
             * @returns The inverted transform
             */
            invert(): Transform | null
            /**
             * Multiplies @next with the given @matrix.
             *
             * This function consumes @next. Use [method@Gsk.Transform.ref] first
             * if you want to keep it around.
             * @param matrix the matrix to multiply @next with
             * @returns The new transform
             */
            matrix(matrix: Graphene.Matrix): Transform
            /**
             * Multiplies @next with the matrix [ xx yx x0; xy yy y0; 0 0 1 ].
             *
             * The result of calling [method@Gsk.Transform.to_2d] on the returned
             * [struct@Gsk.Transform] should match the input passed to this
             * function.
             *
             * This function consumes @next. Use [method@Gsk.Transform.ref] first
             * if you want to keep it around.
             * @since 4.20
             * @param xx the xx member
             * @param yx the yx member
             * @param xy the xy member
             * @param yy the yy member
             * @param dx the x0 member
             * @param dy the y0 member
             * @returns The new transform
             */
            matrix_2d(xx: number, yx: number, xy: number, yy: number, dx: number, dy: number): Transform | null
            /**
             * Applies a perspective projection transform.
             *
             * This transform scales points in X and Y based on their Z value,
             * scaling points with positive Z values away from the origin, and
             * those with negative Z values towards the origin. Points
             * on the z=0 plane are unchanged.
             *
             * This function consumes @next. Use [method@Gsk.Transform.ref] first
             * if you want to keep it around.
             * @param depth distance of the z=0 plane. Lower values give a more
              flattened pyramid and therefore a more pronounced
              perspective effect.
             * @returns The new transform
             */
            perspective(depth: number): Transform
            /**
             * Converts the transform into a human-readable representation.
             *
             * The result of this function can later be parsed with
             * [func@Gsk.Transform.parse].
             * @param string The string to print into
             */
            print(string: GLib.String): void
            /**
             * Acquires a reference on the given transform.
             * @returns the transform with an additional reference
             */
            ref(): Transform | null
            /**
             * Rotates @next by an angle around the Z axis.
             *
             * The rotation happens around the origin point of (0, 0).
             *
             * This function consumes @next. Use [method@Gsk.Transform.ref] first
             * if you want to keep it around.
             * @param angle the rotation angle, in degrees (clockwise)
             * @returns The new transform
             */
            rotate(angle: number): Transform | null
            /**
             * Rotates @next @angle degrees around @axis.
             *
             * For a rotation in 2D space, use [method@Gsk.Transform.rotate]
             *
             * This function consumes @next. Use [method@Gsk.Transform.ref] first
             * if you want to keep it around.
             * @param angle the rotation angle, in degrees (clockwise)
             * @param axis The rotation axis
             * @returns The new transform
             */
            rotate_3d(angle: number, axis: Graphene.Vec3): Transform | null
            /**
             * Scales @next in 2-dimensional space by the given factors.
             *
             * Use [method@Gsk.Transform.scale_3d] to scale in all 3 dimensions.
             *
             * This function consumes @next. Use [method@Gsk.Transform.ref] first
             * if you want to keep it around.
             * @param factor_x scaling factor on the X axis
             * @param factor_y scaling factor on the Y axis
             * @returns The new transform
             */
            scale(factor_x: number, factor_y: number): Transform | null
            /**
             * Scales @next by the given factors.
             *
             * This function consumes @next. Use [method@Gsk.Transform.ref] first
             * if you want to keep it around.
             * @param factor_x scaling factor on the X axis
             * @param factor_y scaling factor on the Y axis
             * @param factor_z scaling factor on the Z axis
             * @returns The new transform
             */
            scale_3d(factor_x: number, factor_y: number, factor_z: number): Transform | null
            /**
             * Applies a skew transform.
             *
             * This function consumes @next. Use [method@Gsk.Transform.ref] first
             * if you want to keep it around.
             * @since 4.6
             * @param skew_x skew factor, in degrees, on the X axis
             * @param skew_y skew factor, in degrees, on the Y axis
             * @returns The new transform
             */
            skew(skew_x: number, skew_y: number): Transform | null
            /**
             * = GSK_TRANSFORM_CATEGORY_2D
             *
             * to check.
             *
             * The returned values are a subset of the full 4x4 matrix that
             * is computed by [method@Gsk.Transform.to_matrix] and have the
             * following layout:
             *
             * ```
             *   | xx yx |   |  a  b  0 |
             *   | xy yy | = |  c  d  0 |
             *   | dx dy |   | tx ty  1 |
             * ```
             *
             * This function can be used to convert between a `GskTransform`
             * and a matrix type from other 2D drawing libraries, in particular
             * Cairo.
             * @returns , return location for the xx member, return location for the yx member, return location for the xy member, return location for the yy member, return location for the x0 member, return location for the y0 member
             */
            to_2d(): [number, number, number, number, number, number]
            /**
             * = GSK_TRANSFORM_CATEGORY_2D
             *
             * to check.
             * @since 4.6
             * @returns , return location for the skew factor   in the  x direction, return location for the skew factor   in the  y direction, return location for the scale   factor in the x direction, return location for the scale   factor in the y direction, return location for the rotation angle, return location for the translation   in the x direction, return location for the translation   in the y direction
             */
            to_2d_components(): [number, number, number, number, number, number, number]
            /**
             * = GSK_TRANSFORM_CATEGORY_2D_AFFINE
             *
             * to check.
             * @returns , return location for the scale   factor in the x direction, return location for the scale   factor in the y direction, return location for the translation   in the x direction, return location for the translation   in the y direction
             */
            to_affine(): [number, number, number, number]
            /**
             * Computes the 4x4 matrix for the transform.
             *
             * The previous value of @out_matrix will be ignored.
             * @returns , return location for the matrix
             */
            to_matrix(): Graphene.Matrix
            /**
             * Converts the transform into a human-readable string.
             *
             * The resulting string can be parsed with [func@Gsk.Transform.parse].
             *
             * This is a wrapper around [method@Gsk.Transform.print].
             * @returns A new string for `self`
             */
            to_string(): string
            /**
             * = GSK_TRANSFORM_CATEGORY_2D_TRANSLATE
             *
             * to check.
             * @returns , return location for the translation   in the x direction, return location for the translation   in the y direction
             */
            to_translate(): [number, number]
            /**
             * Applies all the operations from @other to @next.
             *
             * This function consumes @next. Use [method@Gsk.Transform.ref] first
             * if you want to keep it around.
             * @param other transform to apply
             * @returns The new transform
             */
            transform(other: Transform | null): Transform | null
            /**
             * Transforms a rectangle using the given transform.
             *
             * The result is the bounding box containing the coplanar quad.
             *
             * The input and output rect may point to the same rectangle.
             * @param rect the rectangle to transform
             * @returns , return location for the bounds   of the transformed rectangle
             */
            transform_bounds(rect: Graphene.Rect): Graphene.Rect
            /**
             * Transforms a point using the given transform.
             * @param point the point to transform
             * @returns , return location for   the transformed point
             */
            transform_point(point: Graphene.Point): Graphene.Point
            /**
             * Translates @next in 2-dimensional space by @point.
             *
             * This function consumes @next. Use [method@Gsk.Transform.ref] first
             * if you want to keep it around.
             * @param point the point to translate the transform by
             * @returns The new transform
             */
            translate(point: Graphene.Point): Transform | null
            /**
             * Translates @next by @point.
             *
             * This function consumes @next. Use [method@Gsk.Transform.ref] first
             * if you want to keep it around.
             * @param point the point to translate the transform by
             * @returns The new transform
             */
            translate_3d(point: Graphene.Point3D): Transform | null
            /**
             * Releases a reference on the given transform.
             *
             * If the reference was the last, the resources associated to the @self are
             * freed.
             */
            unref(): void
        }
        none
        /**
         * Compares two component transfers for equality.
         * @since 4.20
         * @param self a component transfer
         * @param other another component transfer
         * @returns true if `self` and `other` are equal
         */
        function component_transfer_equal(self: never, other: never): boolean
        /**
         * Constructs a path from a serialized form.
         *
         * The string is expected to be in (a superset of)
         * [SVG path syntax](https://www.w3.org/TR/SVG11/paths.html#PathData),
         * as e.g. produced by [method@Gsk.Path.to_string].
         *
         * A high-level summary of the syntax:
         *
         * - `M x y` Move to `(x, y)`
         * - `L x y` Add a line from the current point to `(x, y)`
         * - `Q x1 y1 x2 y2` Add a quadratic Bzier from the current point to `(x2, y2)`, with control point `(x1, y1)`
         * - `C x1 y1 x2 y2 x3 y3` Add a cubic Bzier from the current point to `(x3, y3)`, with control points `(x1, y1)` and `(x2, y2)`
         * - `Z` Close the contour by drawing a line back to the start point
         * - `H x` Add a horizontal line from the current point to the given x value
         * - `V y` Add a vertical line from the current point to the given y value
         * - `T x2 y2` Add a quadratic Bzier, using the reflection of the previous segments' control point as control point
         * - `S x2 y2 x3 y3` Add a cubic Bzier, using the reflection of the previous segments' second control point as first control point
         * - `A rx ry r l s x y` Add an elliptical arc from the current point to `(x, y)` with radii rx and ry. See the SVG documentation for how the other parameters influence the arc.
         * - `O x1 y1 x2 y2 w` Add a rational quadratic Bzier from the current point to `(x2, y2)` with control point `(x1, y1)` and weight `w`.
         *
         * All the commands have lowercase variants that interpret coordinates
         * relative to the current point.
         *
         * The `O` command is an extension that is not supported in SVG.
         * @since 4.14
         * @param string a string
         * @returns a new `GskPath`, or `NULL` if `string` could not be parsed
         */
        function path_parse(string: string): Path | null
        /**
         * Registers an error quark for [class@Gsk.RenderNode] errors.
         * @returns the error quark
         */
        function serialization_error_quark(): GLib.Quark
        /**
         * Checks if two strokes are identical.
         * @since 4.14
         * @param stroke1 the first stroke
         * @param stroke2 the second stroke
         * @returns true if the two strokes are equal, false otherwise
         */
        function stroke_equal(stroke1: never | null, stroke2: never | null): boolean
        /**
         * Parses a given into a transform.
         *
         * Strings printed via [method@Gsk.Transform.to_string]
         * can be read in again successfully using this function.
         *
         * If @string does not describe a valid transform, false
         * is returned and `NULL` is put in @out_transform.
         * @param string the string to parse
         * @returns true if `string` described a valid transform, return location for the transform
         */
        function transform_parse(string: string): [boolean, Transform]
        /**
         * Retrieves the render node stored inside a `GValue`,
         * and acquires a reference to it.
         * @since 4.6
         * @param value a [struct@GObject.Value] initialized with type `GSK_TYPE_RENDER_NODE`
         * @returns the render node
         */
        function value_dup_render_node(value: (GObject.Value | unknown)): RenderNode | null
        /**
         * Retrieves the render node stored inside a `GValue`.
         * @since 4.6
         * @param value a `GValue` initialized with type `GSK_TYPE_RENDER_NODE`
         * @returns the render node
         */
        function value_get_render_node(value: (GObject.Value | unknown)): RenderNode | null
        /**
         * Stores the given render node inside a `GValue`.
         *
         * The [struct@GObject.Value] will acquire a reference
         * to the render node.
         * @since 4.6
         * @param value a [struct@GObject.Value] initialized with type `GSK_TYPE_RENDER_NODE`
         * @param node a render node
         */
        function value_set_render_node(value: (GObject.Value | unknown), node: RenderNode): void
        /**
         * Stores the given render node inside a `GValue`.
         *
         * This function transfers the ownership of the
         * render node to the `GValue`.
         * @since 4.6
         * @param value a [struct@GObject.Value] initialized with type `GSK_TYPE_RENDER_NODE`
         * @param node a render node
         */
        function value_take_render_node(value: (GObject.Value | unknown), node: RenderNode | null): void
        
        namespace BlendMode {
            const $gtype: GObject.GType<BlendMode>
        }

        /**
         *  for more information
         * on blending and blend modes.
         */
        enum BlendMode {
            /**
             * The default blend mode, which specifies no blending
             */
            "DEFAULT" = 0,
            /**
             * The source color is multiplied by the destination
             *   and replaces the destination
             */
            "MULTIPLY" = 1,
            /**
             * Multiplies the complements of the destination and source
             *   color values, then complements the result.
             */
            "SCREEN" = 2,
            /**
             * Multiplies or screens the colors, depending on the
             *   destination color value. This is the inverse of hard-list
             */
            "OVERLAY" = 3,
            /**
             * Selects the darker of the destination and source colors
             */
            "DARKEN" = 4,
            /**
             * Selects the lighter of the destination and source colors
             */
            "LIGHTEN" = 5,
            /**
             * Brightens the destination color to reflect the source color
             */
            "COLOR_DODGE" = 6,
            /**
             * Darkens the destination color to reflect the source color
             */
            "COLOR_BURN" = 7,
            /**
             * Multiplies or screens the colors, depending on the source color value
             */
            "HARD_LIGHT" = 8,
            /**
             * Darkens or lightens the colors, depending on the source color value
             */
            "SOFT_LIGHT" = 9,
            /**
             * Subtracts the darker of the two constituent colors from the lighter color
             */
            "DIFFERENCE" = 10,
            /**
             * Produces an effect similar to that of the difference mode but lower in contrast
             */
            "EXCLUSION" = 11,
            /**
             * Creates a color with the hue and saturation of the source color and the luminosity of the destination color
             */
            "COLOR" = 12,
            /**
             * Creates a color with the hue of the source color and the saturation and luminosity of the destination color
             */
            "HUE" = 13,
            /**
             * Creates a color with the saturation of the source color and the hue and luminosity of the destination color
             */
            "SATURATION" = 14,
            /**
             * Creates a color with the luminosity of the source color and the hue and saturation of the destination color
             */
            "LUMINOSITY" = 15,
        }
        
        namespace Corner {
            const $gtype: GObject.GType<Corner>
        }

        /**
         * The corner indices used by `GskRoundedRect`.
         */
        enum Corner {
            /**
             * The top left corner
             */
            "TOP_LEFT" = 0,
            /**
             * The top right corner
             */
            "TOP_RIGHT" = 1,
            /**
             * The bottom right corner
             */
            "BOTTOM_RIGHT" = 2,
            /**
             * The bottom left corner
             */
            "BOTTOM_LEFT" = 3,
        }
        
        namespace FillRule {
            const $gtype: GObject.GType<FillRule>
        }

        /**
         * Specifies how paths are filled.
         *
         * Whether or not a point is included in the fill is determined by taking
         * a ray from that point to infinity and looking at intersections with the
         * path. The ray can be in any direction, as long as it doesn't pass through
         * the end point of a segment or have a tricky intersection such as
         * intersecting tangent to the path.
         *
         * (Note that filling is not actually implemented in this way. This
         * is just a description of the rule that is applied.)
         *
         * New entries may be added in future versions.
         * @since 4.14
         */
        enum FillRule {
            /**
             * If the path crosses the ray from
             *   left-to-right, counts +1. If the path crosses the ray
             *   from right to left, counts -1. (Left and right are determined
             *   from the perspective of looking along the ray from the starting
             *   point.) If the total count is non-zero, the point will be filled.
             */
            "WINDING" = 0,
            /**
             * Counts the total number of
             *   intersections, without regard to the orientation of the contour. If
             *   the total number of intersections is odd, the point will be
             *   filled.
             */
            "EVEN_ODD" = 1,
        }
        
        namespace GLUniformType {
            const $gtype: GObject.GType<GLUniformType>
        }

        /**
         * Defines the types of the uniforms that `GskGLShaders` declare.
         *
         * It defines both what the type is called in the GLSL shader
         * code, and what the corresponding C type is on the Gtk side.
         * @deprecated since 4.16
         */
        enum GLUniformType {
            /**
             * No type, used for uninitialized or unspecified values.
             */
            "NONE" = 0,
            /**
             * A float uniform
             */
            "FLOAT" = 1,
            /**
             * A GLSL int / gint32 uniform
             */
            "INT" = 2,
            /**
             * A GLSL uint / guint32 uniform
             */
            "UINT" = 3,
            /**
             * A GLSL bool / gboolean uniform
             */
            "BOOL" = 4,
            /**
             * A GLSL vec2 / graphene_vec2_t uniform
             */
            "VEC2" = 5,
            /**
             * A GLSL vec3 / graphene_vec3_t uniform
             */
            "VEC3" = 6,
            /**
             * A GLSL vec4 / graphene_vec4_t uniform
             */
            "VEC4" = 7,
        }
        
        namespace LineCap {
            const $gtype: GObject.GType<LineCap>
        }

        /**
         * >
         * @since 4.14
         */
        enum LineCap {
            /**
             * Start and stop the line exactly at the start
             *   and end point
             */
            "BUTT" = 0,
            /**
             * Use a round ending, the center of the circle
             *   is the start or end point
             */
            "ROUND" = 1,
            /**
             * use squared ending, the center of the square
             *   is the start or end point
             */
            "SQUARE" = 2,
        }
        
        namespace LineJoin {
            const $gtype: GObject.GType<LineJoin>
        }

        /**
         * >
         * @since 4.14
         */
        enum LineJoin {
            /**
             * Use a sharp angled corner
             */
            "MITER" = 0,
            /**
             * Use a round join, the center of the circle is
             *   the join point
             */
            "ROUND" = 1,
            /**
             * use a cut-off join, the join is cut off at half
             *   the line width from the joint point
             */
            "BEVEL" = 2,
        }
        
        namespace MaskMode {
            const $gtype: GObject.GType<MaskMode>
        }

        /**
         * The mask modes available for mask nodes.
         * @since 4.10
         */
        enum MaskMode {
            /**
             * Use the alpha channel of the mask
             */
            "ALPHA" = 0,
            /**
             * Use the inverted alpha channel of the mask
             */
            "INVERTED_ALPHA" = 1,
            /**
             * Use the luminance of the mask,
             *     multiplied by mask alpha
             */
            "LUMINANCE" = 2,
            /**
             * Use the inverted luminance of the mask,
             *     multiplied by mask alpha
             */
            "INVERTED_LUMINANCE" = 3,
        }
        
        namespace PathDirection {
            const $gtype: GObject.GType<PathDirection>
        }

        /**
         * >
         * @since 4.14
         */
        enum PathDirection {
            /**
             * The tangent in path direction of the incoming side
             *   of the path
             */
            "FROM_START" = 0,
            /**
             * The tangent against path direction of the incoming side
             *   of the path
             */
            "TO_START" = 1,
            /**
             * The tangent in path direction of the outgoing side
             *   of the path
             */
            "TO_END" = 2,
            /**
             * The tangent against path direction of the outgoing
             *   side of the path
             */
            "FROM_END" = 3,
        }
        
        namespace PathIntersection {
            const $gtype: GObject.GType<PathIntersection>
        }

        /**
         * The values of this enumeration classify intersections
         * between paths.
         * @since 4.20
         */
        enum PathIntersection {
            /**
             * No intersection
             */
            "NONE" = 0,
            /**
             * A normal intersection, where the two paths
             *   cross each other
             */
            "NORMAL" = 1,
            /**
             * The start of a segment where the two paths coincide
             */
            "START" = 2,
            /**
             * The end of a segment where the two paths coincide
             */
            "END" = 3,
        }
        
        namespace PathOperation {
            const $gtype: GObject.GType<PathOperation>
        }

        /**
         * Describes the segments of a `GskPath`.
         *
         * More values may be added in the future.
         * @since 4.14
         */
        enum PathOperation {
            /**
             * A move-to operation, with 1 point describing the target point.
             */
            "MOVE" = 0,
            /**
             * A close operation ending the current contour with a line back
             *   to the starting point. Two points describe the start and end of the line.
             */
            "CLOSE" = 1,
            /**
             * A line-to operation, with 2 points describing the start and
             *   end point of a straight line.
             */
            "LINE" = 2,
            /**
             * A curve-to operation describing a quadratic Bzier curve
             *   with 3 points describing the start point, the control point and the end
             *   point of the curve.
             */
            "QUAD" = 3,
            /**
             * A curve-to operation describing a cubic Bzier curve with 4
             *   points describing the start point, the two control points and the end point
             *   of the curve.
             */
            "CUBIC" = 4,
            /**
             * A rational quadratic Bzier curve with 3 points describing
             *   the start point, control point and end point of the curve. A weight for the
             *   curve will be passed, too.
             */
            "CONIC" = 5,
        }
        
        namespace PorterDuff {
            const $gtype: GObject.GType<PorterDuff>
        }

        /**
         * GSK_PORTER_DUFF_SOURCE:
         * GSK_PORTER_DUFF_DEST:
         * GSK_PORTER_DUFF_SOURCE_OVER_DEST:
         * GSK_PORTER_DUFF_DEST_OVER_SOURCE:
         * GSK_PORTER_DUFF_SOURCE_IN_DEST:
         * GSK_PORTER_DUFF_DEST_IN_SOURCE:
         * GSK_PORTER_DUFF_SOURCE_OUT_DEST:
         * GSK_PORTER_DUFF_DEST_OUT_SOURCE:
         * GSK_PORTER_DUFF_SOURCE_ATOP_DEST:
         * GSK_PORTER_DUFF_DEST_ATOP_SOURCE:
         * GSK_PORTER_DUFF_XOR:
         * GSK_PORTER_DUFF_CLEAR:
         * The 12 compositing modes defined by the seminal paper
         * by Thomas Porter and Tom Duff.
         *
         * They are used in SVG, PDF and in Cairo with `cairo_operator_t`.
         * @since 4.22
         */
        enum PorterDuff {
            /**
             */
            "SOURCE" = 0,
            /**
             */
            "DEST" = 1,
            /**
             */
            "SOURCE_OVER_DEST" = 2,
            /**
             */
            "DEST_OVER_SOURCE" = 3,
            /**
             */
            "SOURCE_IN_DEST" = 4,
            /**
             */
            "DEST_IN_SOURCE" = 5,
            /**
             */
            "SOURCE_OUT_DEST" = 6,
            /**
             */
            "DEST_OUT_SOURCE" = 7,
            /**
             */
            "SOURCE_ATOP_DEST" = 8,
            /**
             */
            "DEST_ATOP_SOURCE" = 9,
            /**
             */
            "XOR" = 10,
            /**
             */
            "CLEAR" = 11,
        }
        
        namespace RenderNodeType {
            const $gtype: GObject.GType<RenderNodeType>
        }

        /**
         * The type of a node determines what the node is rendering.
         */
        enum RenderNodeType {
            /**
             * Error type. No node will ever have this type.
             */
            "NOT_A_RENDER_NODE" = 0,
            /**
             * A node containing a stack of children
             */
            "CONTAINER_NODE" = 1,
            /**
             * A node drawing a `cairo_surface_t`
             */
            "CAIRO_NODE" = 2,
            /**
             * A node drawing a single color rectangle
             */
            "COLOR_NODE" = 3,
            /**
             * A node drawing a linear gradient
             */
            "LINEAR_GRADIENT_NODE" = 4,
            /**
             * A node drawing a repeating linear gradient
             */
            "REPEATING_LINEAR_GRADIENT_NODE" = 5,
            /**
             * A node drawing a radial gradient
             */
            "RADIAL_GRADIENT_NODE" = 6,
            /**
             * A node drawing a repeating radial gradient
             */
            "REPEATING_RADIAL_GRADIENT_NODE" = 7,
            /**
             * A node drawing a conic gradient
             */
            "CONIC_GRADIENT_NODE" = 8,
            /**
             * A node stroking a border around an area
             */
            "BORDER_NODE" = 9,
            /**
             * A node drawing a `GdkTexture`
             */
            "TEXTURE_NODE" = 10,
            /**
             * A node drawing an inset shadow
             */
            "INSET_SHADOW_NODE" = 11,
            /**
             * A node drawing an outset shadow
             */
            "OUTSET_SHADOW_NODE" = 12,
            /**
             * A node that renders its child after applying a matrix transform
             */
            "TRANSFORM_NODE" = 13,
            /**
             * A node that changes the opacity of its child
             */
            "OPACITY_NODE" = 14,
            /**
             * A node that applies a color matrix to every pixel
             */
            "COLOR_MATRIX_NODE" = 15,
            /**
             * A node that repeats the child's contents
             */
            "REPEAT_NODE" = 16,
            /**
             * A node that clips its child to a rectangular area
             */
            "CLIP_NODE" = 17,
            /**
             * A node that clips its child to a rounded rectangle
             */
            "ROUNDED_CLIP_NODE" = 18,
            /**
             * A node that draws a shadow below its child
             */
            "SHADOW_NODE" = 19,
            /**
             * A node that blends two children together
             */
            "BLEND_NODE" = 20,
            /**
             * A node that cross-fades between two children
             */
            "CROSS_FADE_NODE" = 21,
            /**
             * A node containing a glyph string
             */
            "TEXT_NODE" = 22,
            /**
             * A node that applies a blur
             */
            "BLUR_NODE" = 23,
            /**
             * Debug information that does not affect the rendering
             */
            "DEBUG_NODE" = 24,
            /**
             * A node that uses OpenGL fragment shaders to render
             */
            "GL_SHADER_NODE" = 25,
            /**
             * A node drawing a `GdkTexture` scaled and filtered.
             * @since 4.10
             */
            "TEXTURE_SCALE_NODE" = 26,
            /**
             * A node that masks one child with another.
             * @since 4.10
             */
            "MASK_NODE" = 27,
            /**
             * A node that fills a path.
             * @since 4.14
             */
            "FILL_NODE" = 28,
            /**
             * A node that strokes a path.
             * @since 4.14
             */
            "STROKE_NODE" = 29,
            /**
             * A node that possibly redirects part of the scene graph to a subsurface.
             * @since 4.14
             */
            "SUBSURFACE_NODE" = 30,
            /**
             * A node that applies some function to each color component.
             * @since 4.20
             */
            "COMPONENT_TRANSFER_NODE" = 31,
            /**
             * A node that copies the rendering canvas to be pasted later.
             * @since 4.22
             */
            "COPY_NODE" = 32,
            /**
             * A node that pastes a previously copied canvas.
             * @since 4.22
             */
            "PASTE_NODE" = 33,
            /**
             * A node that combines a child with the background using Porter/Duff
             * operations.
             * @since 4.22
             */
            "COMPOSITE_NODE" = 34,
            /**
             * A node that isolated content of its child from previous content.
             * @since 4.22
             */
            "ISOLATION_NODE" = 35,
            /**
             * A node that displaces content according to some mask.
             * @since 4.22
             */
            "DISPLACEMENT_NODE" = 36,
            /**
             * A node that combines two child nodes in an arithmetic way.
             * @since 4.22
             */
            "ARITHMETIC_NODE" = 37,
        }
        
        namespace ScalingFilter {
            const $gtype: GObject.GType<ScalingFilter>
        }

        /**
         * The filters used when scaling texture data.
         *
         * The actual implementation of each filter is deferred to the
         * rendering pipeline.
         */
        enum ScalingFilter {
            /**
             * linear interpolation filter
             */
            "LINEAR" = 0,
            /**
             * nearest neighbor interpolation filter
             */
            "NEAREST" = 1,
            /**
             * linear interpolation along each axis,
             *   plus mipmap generation, with linear interpolation along the mipmap
             *   levels
             */
            "TRILINEAR" = 2,
        }
        
        abstract class SerializationError extends GLib.Error {
            static readonly $gtype: GObject.GType<SerializationError>
            /**
             * The format can not be identified
             */
            static readonly "UNSUPPORTED_FORMAT": 0
            /**
             * The version of the data is not
             *   understood
             */
            static readonly "UNSUPPORTED_VERSION": 1
            /**
             * The given data may not exist in
             *   a proper serialization
             */
            static readonly "INVALID_DATA": 2
        }
        /**
         * Registers an error quark for [class@Gsk.RenderNode] errors.
         * @returns the error quark
         */
        function quark(): GLib.Quark
        
        namespace TransformCategory {
            const $gtype: GObject.GType<TransformCategory>
        }

        /**
         * = GSK_TRANSFORM_CATEGORY_2D` is the way to do this.
         *
         * Also keep in mind that rounding errors may cause matrices to not
         * conform to their categories. Otherwise, matrix operations done via
         * multiplication will not worsen categories. So for the matrix
         * multiplication `C = A * B`, `category(C) = MIN (category(A), category(B))`.
         */
        enum TransformCategory {
            /**
             * The category of the matrix has not been
             *   determined.
             */
            "UNKNOWN" = 0,
            /**
             * Analyzing the matrix concluded that it does
             *   not fit in any other category.
             */
            "ANY" = 1,
            /**
             * The matrix is a 3D matrix. This means that
             *   the w column (the last column) has the values (0, 0, 0, 1).
             */
            "3D" = 2,
            /**
             * The matrix is a 2D matrix. This is equivalent
             *   to graphene_matrix_is_2d() returning %TRUE. In particular, this
             *   means that Cairo can deal with the matrix.
             */
            "2D" = 3,
            /**
             * The matrix is a combination of 2D scale
             *   and 2D translation operations. In particular, this means that any
             *   rectangle can be transformed exactly using this matrix.
             */
            "2D_AFFINE" = 4,
            /**
             * The matrix is a 2D translation.
             */
            "2D_TRANSLATE" = 5,
            /**
             * The matrix is the identity matrix.
             */
            "IDENTITY" = 6,
        }
        
        namespace Isolation {
            const $gtype: GObject.GType<Isolation>
        }

        /**
         * These flags describe the types of isolations possible with a
         * [class@Gsk.IsolationNode].
         *
         * More isolation options may be added in the future.
         * @since 4.22
         */
        enum Isolation {
            /**
             * No isolation is defined.
             */
            "NONE" = 0,
            /**
             * If the background should be made available.
             *   If the background is not available, future operations will be rendered
             *   to a transparent background and added to the existing background later.
             */
            "BACKGROUND" = 1,
            /**
             * If copies should be available to paste nodes.
             *   If copies are not available, paste nodes can only paste from copies that
             *   are made inside the isolated contents.
             */
            "COPY_PASTE" = 2,
            /**
             * Isolate everything. This will include features that
             *   are added in the future.
             */
            "ALL" = -1,
        }
        
        namespace PathForeachFlags {
            const $gtype: GObject.GType<PathForeachFlags>
        }

        /**
         * Flags that can be passed to gsk_path_foreach() to influence what
         * kinds of operations the path is decomposed into.
         *
         * By default, [method@Gsk.Path.foreach] will only emit a path with all
         * operations flattened to straight lines to allow for maximum compatibility.
         * The only operations emitted will be `GSK_PATH_MOVE`, `GSK_PATH_LINE` and
         * `GSK_PATH_CLOSE`.
         * @since 4.14
         */
        enum PathForeachFlags {
            /**
             * The default behavior, only allow lines.
             */
            "ONLY_LINES" = 0,
            /**
             * Allow emission of `GSK_PATH_QUAD` operations
             */
            "QUAD" = 1,
            /**
             * Allow emission of `GSK_PATH_CUBIC` operations.
             */
            "CUBIC" = 2,
            /**
             * Allow emission of `GSK_PATH_CONIC` operations.
             */
            "CONIC" = 4,
        }
        /**
         * Type of callback that is called when an error occurs
         * during node deserialization.
         * @param start start of the error location
         * @param end end of the error location
         * @param error the error
         */
        type ParseErrorFunc = (start: ParseLocation, end: ParseLocation, error: GLib.Error) => void
        /**
         * Type of the callback to iterate through the operations of a path.
         *
         * For each operation, the callback is given the @op itself, the points
         * that the operation is applied to in @pts, and a @weight for conic
         * curves. The @n_pts argument is somewhat redundant, since the number
         * of points can be inferred from the operation.
         *
         * Each contour of the path starts with a @GSK_PATH_MOVE operation.
         * Closed contours end with a @GSK_PATH_CLOSE operation.
         * @param op The operation
         * @param pts The points of the operation
         * @param weight The weight for conic curves, or unused if not a conic curve
         * @returns %TRUE to continue iterating the path, %FALSE to   immediately abort and not call the function again.
         */
        type PathForeachFunc = (op: PathOperation, pts: Graphene.Point[], weight: number) => boolean
        /**
         * Prototype of the callback to iterate through the
         * intersections of two paths.
         * @since 4.20
         * @param path1 the first path
         * @param point1 the intersection as point on @path1
         * @param path2 the second path
         * @param point2 the intersection as point on @path2
         * @param kind the nature of the intersection
         * @returns true to continue iterating, false to   stop the iteration and not call the function again
         */
        type PathIntersectionFunc = (path1: Path, point1: PathPoint, path2: Path, point2: PathPoint, kind: PathIntersection) => boolean
        /**
         * A function that filters fonts.
         *
         * The function will be called by the default replay function for
         * all nodes with fonts. They will then generate a node using the
         * returned font.
         *
         * It is valid for the function to return the passed in font if
         * the font shuld not be modified.
         * @since 4.22
         * @param replay The replay object used to replay the node
         * @param font The font to filter
         * @returns The filtered font
         */
        type RenderReplayFontFilter = (replay: RenderReplay, font: Pango.Font) => Pango.Font
        /**
         * A function to replay a node.
         *
         * The node may be returned unmodified.
         *
         * The node may be discarded by returning %NULL.
         *
         * If you do not want to do any handling yourself, call
         * [method@Gsk.RenderReplay.default] to use the default handler
         * that calls your function on the children of the node.
         * @since 4.22
         * @param replay The replay object used to replay the node
         * @param node The node to replay
         * @returns The replayed node
         */
        type RenderReplayNodeFilter = (replay: RenderReplay, node: RenderNode) => RenderNode | null
        /**
         * A function that filters textures.
         *
         * The function will be called by the default replay function for
         * all nodes with textures. They will then generate a node using the
         * returned texture.
         *
         * It is valid for the function to return the passed in texture if
         * the texture shuld not be modified.
         * @since 4.22
         * @param replay The replay object used to replay the node
         * @param texture The texture to filter
         * @returns The filtered texture
         */
        type RenderReplayTextureFilter = (replay: RenderReplay, texture: Gdk.Texture) => Gdk.Texture
    }

    export default Gsk
}