
/// <reference path="./GLib-2.0.d.ts" />
/// <reference path="./GModule-2.0.d.ts" />
/// <reference path="./GObject-2.0.d.ts" />
/// <reference path="./Gio-2.0.d.ts" />

/**
 * Type Definitions for GJS (https://gjs.guide/), generated by [GirGen](https://github.com/aylur/girgen)
 * If you found a bug, create a bug report on [GirGen's Repository](https://github.com/aylur/girgen/issues/new)
 */
declare module "gi://Nice?version=0.1" {
    import type GLib from "gi://GLib?version=2.0"
    import type GModule from "gi://GModule?version=2.0"
    import type GObject from "gi://GObject?version=2.0"
    import type Gio from "gi://Gio?version=2.0"

    


    namespace Nice {
        const __name__: "Nice"
        const __version: "0.1"
        

        namespace Agent {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
                /**
                 * This signal is fired whenever a stream has finished gathering its
                 * candidates after a call to nice_agent_gather_candidates()
                 * @param stream_id The ID of the stream
                 */
                "candidate-gathering-done"(stream_id: number): void
                /**
                 * This signal is fired whenever a component’s state changes. There are many
                 * valid state transitions.
                 *
                 * ![State transition diagram](states.png)
                 * @param stream_id The ID of the stream
                 * @param component_id The ID of the component
                 * @param state The new #NiceComponentState of the component
                 */
                "component-state-changed"(stream_id: number, component_id: number, state: number): void
                /**
                 * This signal is fired when we received our first binding request from
                 * the peer.
                 * @param stream_id The ID of the stream
                 */
                "initial-binding-request-received"(stream_id: number): void
                /**
                 * This signal is fired when the agent discovers a new local candidate.
                 * When this signal is emitted, a matching #NiceAgent::new-candidate-full is
                 * also emitted with the candidate.
                 *
                 * See also: #NiceAgent::candidate-gathering-done,
                 * #NiceAgent::new-candidate-full
                 * @deprecated since 0.1.8 Use #NiceAgent::new-candidate-full
                 * @param stream_id The ID of the stream
                 * @param component_id The ID of the component
                 * @param foundation The foundation of the new candidate
                 */
                "new-candidate"(stream_id: number, component_id: number, foundation: string): void
                /**
                 * This signal is fired when the agent discovers a new local candidate.
                 * When this signal is emitted, a matching #NiceAgent::new-candidate is
                 * also emitted with the candidate's foundation.
                 *
                 * See also: #NiceAgent::candidate-gathering-done,
                 * #NiceAgent::new-candidate
                 * @since 0.1.8
                 * @param candidate The new #NiceCandidate
                 */
                "new-candidate-full"(candidate: Candidate): void
                /**
                 * This signal is fired when the agent discovers a new remote
                 * candidate.  This can happen with peer reflexive candidates.  When
                 * this signal is emitted, a matching
                 * #NiceAgent::new-remote-candidate-full is also emitted with the
                 * candidate.
                 *
                 * See also: #NiceAgent::new-remote-candidate-full
                 * @deprecated since 0.1.8 Use #NiceAgent::new-remote-candidate-full
                 * @param stream_id The ID of the stream
                 * @param component_id The ID of the component
                 * @param foundation The foundation of the new candidate
                 */
                "new-remote-candidate"(stream_id: number, component_id: number, foundation: string): void
                /**
                 * This signal is fired when the agent discovers a new remote candidate.
                 * This can happen with peer reflexive candidates.
                 * When this signal is emitted, a matching #NiceAgent::new-remote-candidate is
                 * also emitted with the candidate's foundation.
                 *
                 * See also: #NiceAgent::new-remote-candidate
                 * @since 0.1.8
                 * @param candidate The new #NiceCandidate
                 */
                "new-remote-candidate-full"(candidate: Candidate): void
                /**
                 * This signal is fired once a candidate pair is selected for data
                 * transfer for a stream's component This is emitted along with
                 * #NiceAgent::new-selected-pair-full which has the whole candidate,
                 * the Foundation of a Candidate is not a unique identifier.
                 *
                 * See also: #NiceAgent::new-selected-pair-full
                 * @deprecated since 0.1.8 Use #NiceAgent::new-selected-pair-full
                 * @param stream_id The ID of the stream
                 * @param component_id The ID of the component
                 * @param lfoundation The local foundation of the selected candidate pair
                 * @param rfoundation The remote foundation of the selected candidate pair
                 */
                "new-selected-pair"(stream_id: number, component_id: number, lfoundation: string, rfoundation: string): void
                /**
                 * This signal is fired once a candidate pair is selected for data
                 * transfer for a stream's component. This is emitted along with
                 * #NiceAgent::new-selected-pair.
                 *
                 * See also: #NiceAgent::new-selected-pair
                 * @since 0.1.8
                 * @param stream_id The ID of the stream
                 * @param component_id The ID of the component
                 * @param lcandidate The local #NiceCandidate of the selected candidate pair
                 * @param rcandidate The remote #NiceCandidate of the selected candidate pair
                 */
                "new-selected-pair-full"(stream_id: number, component_id: number, lcandidate: Candidate, rcandidate: Candidate): void
                /**
                 * This signal is fired on #NiceAgent when the underlying transport becomes writable.
                 * This signal is only emitted when the nice_agent_send() function returns less
                 * bytes than requested to send (or -1) and once when the connection
                 * is established.
                 *
                 * Note: Since 0.1.23 this signal also fires for non-reliable transports.
                 * See https://gitlab.freedesktop.org/libnice/libnice/-/issues/202.
                 * @since 0.0.11
                 * @param stream_id The ID of the stream
                 * @param component_id The ID of the component
                 */
                "reliable-transport-writable"(stream_id: number, component_id: number): void
                /**
                 * This signal is fired whenever one or more streams are removed from the
                 * @agent.
                 * @since 0.1.5
                 * @param stream_ids An array of
                unsigned integer stream IDs, ending with a 0 ID
                 */
                "streams-removed"(stream_ids: number[]): void
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "bytestream-tcp": boolean
                "close-forced": boolean
                "compatibility": number
                "consent-freshness": boolean
                "controlling-mode": boolean
                "force-relay": boolean
                "full-mode": boolean
                "ice-tcp": boolean
                "ice-trickle": boolean
                "ice-udp": boolean
                "idle-timeout": number
                "keepalive-conncheck": boolean
                "main-context": never
                "max-connectivity-checks": number
                "proxy-extra-headers": Record<string, string>
                "proxy-ip": string
                "proxy-password": string
                "proxy-port": number
                "proxy-type": number
                "proxy-username": string
                "reliable": boolean
                "stun-initial-timeout": number
                "stun-max-retransmissions": number
                "stun-pacing-timer": number
                "stun-reliable-timeout": number
                "stun-server": string
                "stun-server-port": number
                "support-renomination": boolean
                "upnp": boolean
                "upnp-timeout": number
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "bytestream-tcp": boolean
                "close-forced": boolean
                "compatibility": number
                "consent-freshness": boolean
                "controlling-mode": boolean
                "force-relay": boolean
                "full-mode": boolean
                "ice-tcp": boolean
                "ice-trickle": boolean
                "ice-udp": boolean
                "idle-timeout": number
                "keepalive-conncheck": boolean
                "main-context": never
                "max-connectivity-checks": number
                "proxy-extra-headers": Record<string, string>
                "proxy-ip": string
                "proxy-password": string
                "proxy-port": number
                "proxy-type": number
                "proxy-username": string
                "reliable": boolean
                "stun-initial-timeout": number
                "stun-max-retransmissions": number
                "stun-pacing-timer": number
                "stun-reliable-timeout": number
                "stun-server": string
                "stun-server-port": number
                "support-renomination": boolean
                "upnp": boolean
                "upnp-timeout": number
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * The #NiceAgent is the main GObject of the libnice library and represents
         * the ICE agent.
         */
        interface Agent extends GObject.Object {
            readonly $signals: Agent.SignalSignatures
            readonly $readableProperties: Agent.ReadableProperties
            readonly $writableProperties: Agent.WritableProperties
            readonly $constructOnlyProperties: Agent.ConstructOnlyProperties
            /**
             *
             * If the property is %TRUE, the stream is considered in bytestream mode
             * and data can be read with any receive size. If the property is %FALSE, then
             * the stream is considered packetized and each receive will return one packet
             * of the same size as what was sent from the peer. If in packetized mode,
             * then doing a receive with a size smaller than the packet, will cause the
             * remaining bytes in the packet to be dropped, breaking the reliability
             * of the stream.
             * @since 0.1.8
             * @default FALSE
             */
            get bytestreamTcp(): boolean
            set bytestreamTcp(value: boolean)
            /**
             * Whether to omit performing retransmissions and wait for a response for the 0-lifetime
             * refresh request that is sent by nice_agent_close_async(). This favors a quick shutdown of
             * the agent at the risk of lingering TURN server port allocations.
             * @since 0.1.23
             * @default FALSE
             */
            get closeForced(): boolean
            set closeForced(value: boolean)
            /**
             * >
             * @default 0
             */
            get compatibility(): number
            set compatibility(value: number)
            /**
             * Whether to perform periodic consent freshness checks as specified in
             * RFC 7675.  When %TRUE, the agent will periodically send binding requests
             * to the peer to maintain the consent to send with the peer.  On receipt
             * of any authenticated error response, a component will immediately move
             * to the failed state.
             *
             * Setting this property to %TRUE implies that 'keepalive-conncheck' should
             * be %TRUE as well.
             * @since 0.1.19
             * @default FALSE
             */
            get consentFreshness(): boolean
            set consentFreshness(value: boolean)
            /**
             * Whether the agent has the controlling role. This property should
             * be modified before gathering candidates, any modification occuring
             * later will be hold until ICE is restarted.
             * @default FALSE
             */
            get controllingMode(): boolean
            set controllingMode(value: boolean)
            /**
             * Force all traffic to go through a relay for added privacy, this
             * allows hiding the local IP address. When this is enabled, so
             * local candidates are available before relay servers have been set
             * with nice_agent_set_relay_info().
             * @since 0.1.14
             * @default FALSE
             */
            get forceRelay(): boolean
            set forceRelay(value: boolean)
            /**
             * @default TRUE
             */
            get fullMode(): boolean
            set fullMode(value: boolean)
            /**
             * >
             * @since 0.1.8
             * @default TRUE
             */
            get iceTcp(): boolean
            set iceTcp(value: boolean)
            /**
             * Whether to perform Trickle ICE as per draft-ietf-ice-trickle-ice-21.
             * When %TRUE, the agent will postpone changing a component state to
             * %NICE_COMPONENT_STATE_FAILED until nice_agent_peer_candidate_gathering_done()
             * has been called with the ID of the component's stream.
             * @since 0.1.16
             * @default FALSE
             */
            get iceTrickle(): boolean
            set iceTrickle(value: boolean)
            /**
             *
             * The #NiceAgent:ice-udp property can be set at the same time as the
             * #NiceAgent:ice-tcp property, but both cannot be unset at the same time.
             * If #NiceAgent:ice-tcp is set to %FALSE, then this property cannot be set
             * to %FALSE as well.
             * @since 0.1.8
             * @default TRUE
             */
            get iceUdp(): boolean
            set iceUdp(value: boolean)
            /**
             *  ready.  Such transitions are not buggy per-se, but may
             * break the test-suite, that counts precisely the number of time each
             * state has been set, and doesnt expect these transcient failed
             * states.
             *
             * This timer is also useful when the agent is in controlled mode and
             * the other controlling peer takes some time to elect its nominated
             * pair (this may be the case for SfB peers).
             *
             * This timer is *NOT* part if the RFC5245, as this situation is not
             * covered in sect 8.1.2 "Updating States", but deals with a real
             * use-case, where a controlled agent can not wait forever for the
             * other peer to make a nomination decision.
             *
             * Also note that the value of this timeout will not delay the
             * emission of 'connected' and 'ready' agent signals, and will not
             * slow down the behaviour of the agent when the peer agent works
             * in a timely manner.
             * @since 0.1.17
             * @default 5000
             */
            get idleTimeout(): number
            set idleTimeout(value: number)
            /**
             * Use binding requests as keepalives instead of binding
             * indications. This means that the keepalives may time out which
             * will change the component state to %NICE_COMPONENT_STATE_FAILED.
             *
             * Enabing this is a slight violation of RFC 5245 section 10 which
             * recommends using Binding Indications for keepalives.
             *
             * This is always enabled if the compatibility mode is
             * %NICE_COMPATIBILITY_GOOGLE.
             *
             * This is always enabled if the 'consent-freshness' property is %TRUE
             * @since 0.1.8
             * @default FALSE
             */
            get keepaliveConncheck(): boolean
            set keepaliveConncheck(value: boolean)
            /**
             * A GLib main context is needed for all timeouts used by libnice.
             * This is a property being set by the nice_agent_new() call.
             */
            get mainContext(): never
            set mainContext(value: never)
            /**
             * @default 0
             */
            get maxConnectivityChecks(): number
            set maxConnectivityChecks(value: number)
            /**
             * Optional extra headers to append to the HTTP proxy CONNECT request.
             * Provided as key/value-pairs in hash table corresponding to
             * header-name/header-value.
             * @since 0.1.20
             */
            get proxyExtraHeaders(): Record<string, string>
            set proxyExtraHeaders(value: Record<string, string>)
            /**
             * The proxy server IP used to bypass a proxy firewall
             * @since 0.0.4
             * @default NULL
             */
            get proxyIp(): string
            set proxyIp(value: string)
            /**
             * The password used to authenticate with the proxy
             * @since 0.0.4
             * @default NULL
             */
            get proxyPassword(): string
            set proxyPassword(value: string)
            /**
             * The proxy server port used to bypass a proxy firewall
             * @since 0.0.4
             * @default 1
             */
            get proxyPort(): number
            set proxyPort(value: number)
            /**
             * The type of proxy set in the proxy-ip property
             * @since 0.0.4
             * @default 0
             */
            get proxyType(): number
            set proxyType(value: number)
            /**
             * The username used to authenticate with the proxy
             * @since 0.0.4
             * @default NULL
             */
            get proxyUsername(): string
            set proxyUsername(value: string)
            /**
             * Whether the agent is providing a reliable transport of messages (through
             * ICE-TCP or PseudoTCP over ICE-UDP)
             * @since 0.0.11
             * @default FALSE
             */
            get reliable(): boolean
            set reliable(value: boolean)
            /**
             * The initial timeout (msecs) of the STUN binding requests
             * used in the gathering stage, to find our local candidates.
             * This property is described as 'RTO' in the RFC 5389 and RFC 5245.
             * This timeout is doubled for each retransmission, until
             * #NiceAgent:stun-max-retransmissions have been done,
             * with an exception for the last restransmission, where the timeout is
             * divided by two instead (RFC 5389 indicates that a customisable
             * multiplier 'Rm' to 'RTO' should be used).
             * @since 0.1.15
             * @default 500
             */
            get stunInitialTimeout(): number
            set stunInitialTimeout(value: number)
            /**
             * The maximum number of retransmissions of the STUN binding requests
             * used in the gathering stage, to find our local candidates, and used
             * in the connection check stage, to test the validity of each
             * constructed pair. This property is described as 'Rc' in the RFC
             * 5389, with a default value of 7. The timeout of each STUN request
             * is doubled for each retransmission, so the choice of this value has
             * a direct impact on the time needed to move from the CONNECTED state
             * to the READY state, and on the time needed to complete the GATHERING
             * state.
             * @since 0.1.15
             * @default 3
             */
            get stunMaxRetransmissions(): number
            set stunMaxRetransmissions(value: number)
            /**
             * @default 20
             */
            get stunPacingTimer(): number
            set stunPacingTimer(value: number)
            /**
             * The initial timeout of the STUN binding requests used
             * for a reliable timer.
             * @since 0.1.15
             * @default 2000
             */
            get stunReliableTimeout(): number
            set stunReliableTimeout(value: number)
            /**
             * @default NULL
             */
            get stunServer(): string
            set stunServer(value: string)
            /**
             * @default 1
             */
            get stunServerPort(): number
            set stunServerPort(value: number)
            /**
             * Support RENOMINATION STUN attribute proposed here:
             * https://tools.ietf.org/html/draft-thatcher-ice-renomination-00 As
             * soon as RENOMINATION attribute is received from remote
             * candidate's address, corresponding candidates pair gets
             * selected. This is specific to Google Chrome/libWebRTC.
             * @default FALSE
             */
            get supportRenomination(): boolean
            set supportRenomination(value: boolean)
            /**
             * Whether the agent should use UPnP to open a port in the router and
             * get the external IP
             * @since 0.0.7
             * @default TRUE
             */
            get upnp(): boolean
            set upnp(value: boolean)
            /**
             * The maximum amount of time (in milliseconds) to wait for UPnP discovery to
             * finish before signaling the #NiceAgent::candidate-gathering-done signal
             * @since 0.0.7
             * @default 200
             */
            get upnpTimeout(): number
            set upnpTimeout(value: number)
            /**
             *
             *
             * See also: nice_agent_gather_candidates()
             * @param addr The address to listen to
            If the port is 0, then a random port will be chosen by the system
             * @returns %TRUE on success, %FALSE on fatal (memory allocation) errors
             */
            add_local_address(addr: Address): boolean
            /**
             * Adds a data stream to @agent containing @n_components components. The
             * returned stream ID is guaranteed to be positive on success.
             * @param n_components The number of components to add to the stream
             * @returns The ID of the new stream, 0 on failure
             */
            add_stream(n_components: number): number
            /**
             * Asynchronously closes resources the agent has allocated on remote servers.
             *
             * The agent will call the callback in the current #GMainContext in
             * which this function is called. The #GAsyncResult in the callback
             * can be ignored as this operation never fails.
             *
             * Calling this function before freeing the agent makes sure the allocated relay
             * ports aren't left behind on TURN server but properly removed.
             * @since 0.1.16
             * @param callback A callback that will be called when the closing is
             complete
             */
            close_async(callback: Gio.AsyncReadyCallback | null): void
            /**
             * Notifies the agent that consent to receive has been revoked.  This will
             * cause the component to fail with 403 'Forbidden' all incoming STUN binding
             * requests as specified in RFC 7675.
             *
             * A stream with a component in the consent-lost state can be reused by
             * performing an ice restart with nice_agent_restart() or
             * nice_agent_restart_stream().
             *
             * Calling the function only has an effect when @agent has been created with
             * @NICE_AGENT_OPTION_CONSENT_FRESHNESS.
             * @since 0.1.19
             * @param stream_id The ID of the stream
             * @param component_id The ID of the component
             * @returns %FALSE if the stream or component could not be found or consent     freshness is not enabled, %TRUE otherwise
             */
            consent_lost(stream_id: number, component_id: number): boolean
            /**
             * Forget all the relay servers previously added using
             * nice_agent_set_relay_info(). Currently connected streams will keep
             * using the relay as long as they have not been restarted and haven't
             * succesfully negotiated a different path.
             * @since 0.1.6
             * @param stream_id The ID of the stream
             * @param component_id The ID of the component
             * @returns %FALSE if the component could not be found, %TRUE otherwise
             */
            forget_relays(stream_id: number, component_id: number): boolean
            /**
             * >
             * @param stream_id The ID of the stream to start
             * @returns >
             */
            gather_candidates(stream_id: number): boolean
            /**
             * >
             * @since 0.1.4
             * @param candidate The candidate to generate
             * @returns A string representing the SDP for the candidate. Must be freed with g_free() once done.
             */
            generate_local_candidate_sdp(candidate: Candidate): string
            /**
             * >
             * @since 0.1.4
             * @returns A string representing the local SDP. Must be freed with g_free() once done.
             */
            generate_local_sdp(): string
            /**
             * >
             * @since 0.1.4
             * @param stream_id The ID of the stream
             * @param include_non_ice Whether or not to include non ICE specific lines
            (m=, c= and a=rtcp: lines)
             * @returns A string representing the local SDP for the stream. Must be freed with g_free() once done.
             */
            generate_local_stream_sdp(stream_id: number, include_non_ice: boolean): string
            /**
             * Retrieves the current state of a component.
             * @since 0.1.8
             * @param stream_id The ID of the stream
             * @param component_id The ID of the component
             * @returns the #NiceComponentState of the component and %NICE_COMPONENT_STATE_FAILED if the component was invalid.
             */
            get_component_state(stream_id: number, component_id: number): ComponentState
            /**
             * >
             * @param stream_id The ID of the stream
             * @param component_id The ID of the component
             * @returns The candidate to be used as the default candidate, or %NULL in case of error. Must be freed with nice_candidate_free() once done.
             */
            get_default_local_candidate(stream_id: number, component_id: number): Candidate
            /**
             * Gets a #GIOStream wrapper around the given stream and component in
             * @agent. The I/O stream will be valid for as long as @stream_id is valid.
             * The #GInputStream and #GOutputStream implement #GPollableInputStream and
             * #GPollableOutputStream.
             *
             * This function may only be called on reliable #NiceAgents. It is a
             * programming error to try and create an I/O stream wrapper for an
             * unreliable stream.
             * @since 0.1.5
             * @param stream_id The ID of the stream to wrap
             * @param component_id The ID of the component to wrap
             * @returns A #GIOStream.
             */
            get_io_stream(stream_id: number, component_id: number): Gio.IOStream
            /**
             * >
             * @param stream_id The ID of the stream
             * @param component_id The ID of the component
             * @returns a #GSList of #NiceCandidate objects representing the local candidates of `agent`
             */
            get_local_candidates(stream_id: number, component_id: number): Candidate[]
            /**
             * Gets the local credentials for stream @stream_id. This may be called any time
             * after creating a stream using nice_agent_add_stream().
             *
             * An error will be returned if this is called for a non-existent stream, or if
             * either of @ufrag or @pwd are %NULL.
             * @param stream_id The ID of the stream
             * @returns %TRUE on success, %FALSE on error., return location for a nul-terminated string containing an ICE username fragment; must be freed with g_free(), return location for a nul-terminated string containing an ICE password; must be freed with g_free()
             */
            get_local_credentials(stream_id: number): [boolean, string, string]
            /**
             * >
             * @param stream_id The ID of the stream
             * @param component_id The ID of the component
             * @returns a #GSList of #NiceCandidates objects representing the remote candidates set on the `agent`
             */
            get_remote_candidates(stream_id: number, component_id: number): Candidate[]
            /**
             * Retreive the selected candidate pair for media transmission
             * for a given stream's component.
             * @param stream_id The ID of the stream
             * @param component_id The ID of the component
             * @param local The local selected candidate
             * @param remote The remote selected candidate
             * @returns %TRUE on success, %FALSE if there is no selected candidate pair
             */
            get_selected_pair(stream_id: number, component_id: number, local: Candidate, remote: Candidate): boolean
            /**
             * Retreive the local socket associated with the selected candidate pair
             * for media transmission for a given stream's component.
             *
             * This is useful for adding ICE support to legacy applications that already
             * have a protocol that maintains a connection. If the socket is duplicated
             * before unrefing the agent, the application can take over and continue to use
             * it. New applications are encouraged to use the built in libnice stream
             * handling instead and let libnice handle the connection maintenance.
             *
             * Users of this method are encouraged to not use a TURN relay or any kind
             * of proxy, as in this case, the socket will not be available to the
             * application because the packets are encapsulated.
             * @since 0.1.5
             * @param stream_id The ID of the stream
             * @param component_id The ID of the component
             * @returns pointer to the #GSocket, or %NULL if there is no selected candidate or if the selected candidate is a relayed candidate.
             */
            get_selected_socket(stream_id: number, component_id: number): Gio.Socket | null
            /**
             *  TCP sockets depending on the compatibility mode
             * and options that have been set.
             * @since 0.1.17
             * @param stream_id The ID of the stream
             * @param component_id The ID of the component
             * @returns An array containing all of the sockets for this component. Free with g_ptr_array_unref() when done.
             */
            get_sockets(stream_id: number, component_id: number): Gio.Socket[]
            /**
             * >
             * @since 0.1.4
             * @param stream_id The ID of the stream to change
             * @returns The name of the stream. The name is only valid while the stream exists or until it changes through a call to nice_agent_set_stream_name().
             */
            get_stream_name(stream_id: number): string
            /**
             * >
             * @since 0.1.4
             * @param stream_id The ID of the stream the candidate belongs to
             * @param sdp The remote SDP to parse
             * @returns The parsed candidate or %NULL if there was an error.
             */
            parse_remote_candidate_sdp(stream_id: number, sdp: string): Candidate
            /**
             * >
             * @since 0.1.4
             * @param sdp The remote SDP to parse
             * @returns The number of candidates added, negative on errors
             */
            parse_remote_sdp(sdp: string): number
            /**
             * >
             * @since 0.1.4
             * @param stream_id The ID of the stream to parse
             * @param sdp The remote SDP to parse
             * @param ufrag Pointer to store the ice ufrag if non %NULL. Must be freed with
            g_free() after use
             * @param pwd Pointer to store the ice password if non %NULL. Must be freed with
            g_free() after use
             * @returns A #GSList of candidates parsed from the SDP, or %NULL in case of errors
             */
            parse_remote_stream_sdp(stream_id: number, sdp: string, ufrag: string, pwd: string): Candidate[]
            /**
             * Notifies the agent that the remote peer has concluded candidate gathering and
             * thus no more remote candidates are expected to arrive for @stream_id.
             *
             * This will allow the stream components without a successful connectivity check
             * to stop waiting for more candidates to come and finally transit into
             * %NICE_COMPONENT_STATE_FAILED.
             *
             * Calling the function has an effect only when #NiceAgent:trickle-ice is %TRUE.
             * @since 0.1.16
             * @param stream_id The ID of the stream
             * @returns %FALSE if the stream could not be found, %TRUE otherwise
             */
            peer_candidate_gathering_done(stream_id: number): boolean
            /**
             * A single-message version of nice_agent_recv_messages().
             * @throws {GLib.Error}
             * @since 0.1.5
             * @param stream_id the ID of the stream to receive on
             * @param component_id the ID of the component to receive on
             * @param cancellable a #GCancellable to allow the operation to be
            cancelled from another thread, or %NULL
             * @returns the number of bytes written to `buf` on success (guaranteed to be greater than 0 unless `buf_len` is 0), 0 if in reliable mode and the remote peer closed the stream, or -1 on error, caller-allocated buffer to write the received data into, of length at least `buf_len`
             */
            recv(stream_id: number, component_id: number, cancellable: Gio.Cancellable | null): [number, Uint8Array]
            /**
             * Block on receiving data from the given stream/component combination on
             * @agent, returning only once exactly @n_messages messages have been received
             * and written into @messages, the stream is closed by the other end or by
             * calling nice_agent_remove_stream(), or @cancellable is cancelled.
             *
             * Any STUN packets received will not be added to @messages; instead,
             * they'll be passed for processing to #NiceAgent itself. Since #NiceAgent
             * does not poll for messages on its own, it's therefore essential to keep
             * calling this function for ICE connection establishment to work.
             *
             * In the non-error case, in reliable mode, this will block until all buffers in
             * all @n_messages have been filled with received data (i.e. @messages is
             * treated as a large, flat array of buffers). In non-reliable mode, it will
             * block until @n_messages messages have been received, each of which does not
             * have to fill all the buffers in its #NiceInputMessage. In the non-reliable
             * case, each #NiceInputMessage must have enough buffers to contain an entire
             * message (65536 bytes), or any excess data may be silently dropped.
             *
             * For each received message, #NiceInputMessage::length will be set to the
             * number of valid bytes stored in the message’s buffers. The bytes are stored
             * sequentially in the buffers; there are no gaps apart from at the end of the
             * buffer array (in non-reliable mode). If non-%NULL on input,
             * #NiceInputMessage::from will have the address of the sending peer stored in
             * it. The base addresses, sizes, and number of buffers in each message will not
             * be modified in any case.
             *
             * This must not be used in combination with nice_agent_attach_recv() on the
             * same stream/component pair.
             *
             * If the stream/component pair doesn’t exist, or if a suitable candidate socket
             * hasn’t yet been selected for it, a %G_IO_ERROR_BROKEN_PIPE error will be
             * returned. A %G_IO_ERROR_CANCELLED error will be returned if the operation was
             * cancelled. %G_IO_ERROR_FAILED will be returned for other errors.
             * @throws {GLib.Error}
             * @since 0.1.5
             * @param stream_id the ID of the stream to receive on
             * @param component_id the ID of the component to receive on
             * @param cancellable a #GCancellable to allow the operation to be
            cancelled from another thread, or %NULL
             * @returns the number of valid messages written to `messages` on success (guaranteed to be greater than 0 unless `n_messages` is 0), 0 if the remote peer closed the stream, or -1 on error, caller-allocated array of #NiceInputMessages to write the received messages into, of length at least `n_messages`
             */
            recv_messages(stream_id: number, component_id: number, cancellable: Gio.Cancellable | null): [number, InputMessage[]]
            /**
             * Try to receive data from the given stream/component combination on @agent,
             * without blocking. If receiving data would block, -1 is returned and
             * %G_IO_ERROR_WOULD_BLOCK is set in @error. If any other error occurs, -1 is
             * returned and @error is set accordingly. Otherwise, 0 is returned if (and only
             * if) @n_messages is 0. In all other cases, the number of valid messages stored
             * in @messages is returned, and will be greater than 0.
             *
             * This function behaves similarly to nice_agent_recv_messages(), except that it
             * will not block on filling (in reliable mode) or receiving (in non-reliable
             * mode) exactly @n_messages messages. In reliable mode, it will receive bytes
             * into @messages until it would block; in non-reliable mode, it will receive
             * messages until it would block.
             *
             * Any STUN packets received will not be added to @messages; instead,
             * they'll be passed for processing to #NiceAgent itself. Since #NiceAgent
             * does not poll for messages on its own, it's therefore essential to keep
             * calling this function for ICE connection establishment to work.
             *
             * As this function is non-blocking, @cancellable is included only for parity
             * with nice_agent_recv_messages(). If @cancellable is cancelled before this
             * function is called, a %G_IO_ERROR_CANCELLED error will be returned
             * immediately.
             *
             * This must not be used in combination with nice_agent_attach_recv() on the
             * same stream/component pair.
             * @throws {GLib.Error}
             * @since 0.1.5
             * @param stream_id the ID of the stream to receive on
             * @param component_id the ID of the component to receive on
             * @param cancellable a #GCancellable to allow the operation to be
            cancelled from another thread, or %NULL
             * @returns the number of valid messages written to `messages` on success (guaranteed to be greater than 0 unless `n_messages` is 0), 0 if in reliable mode and the remote peer closed the stream, or -1 on error, caller-allocated array of #NiceInputMessages to write the received messages into, of length at least `n_messages`
             */
            recv_messages_nonblocking(stream_id: number, component_id: number, cancellable: Gio.Cancellable | null): [number, InputMessage[]]
            /**
             * A single-message version of nice_agent_recv_messages_nonblocking().
             * @throws {GLib.Error}
             * @since 0.1.5
             * @param stream_id the ID of the stream to receive on
             * @param component_id the ID of the component to receive on
             * @param cancellable a #GCancellable to allow the operation to be
            cancelled from another thread, or %NULL
             * @returns the number of bytes received into `buf` on success (guaranteed to be greater than 0 unless `buf_len` is 0), 0 if in reliable mode and the remote peer closed the stream, or -1 on error, caller-allocated buffer to write the received data into, of length at least `buf_len`
             */
            recv_nonblocking(stream_id: number, component_id: number, cancellable: Gio.Cancellable | null): [number, Uint8Array]
            /**
             * Remove and free a previously created data stream from @agent. If any I/O
             * streams have been created using nice_agent_get_io_stream(), they should be
             * closed completely using g_io_stream_close() before this is called, or they
             * will get broken pipe errors.
             * @param stream_id The ID of the stream to remove
             */
            remove_stream(stream_id: number): void
            /**
             * Restarts the session as defined in ICE draft 19. This function
             * needs to be called both when initiating (ICE spec section 9.1.1.1.
             * "ICE Restarts"), as well as when reacting (spec section 9.2.1.1.
             * "Detecting ICE Restart") to a restart.
             *
             * If consent-freshness has been enabled on @agent, as specified in RFC7675
             * then restarting streams will restore the local consent.
             * @returns %TRUE on success %FALSE on error
             */
            restart(): boolean
            /**
             * Restarts a single stream as defined in RFC 5245. This function
             * needs to be called both when initiating (ICE spec section 9.1.1.1.
             * "ICE Restarts"), as well as when reacting (spec section 9.2.1.1.
             * "Detecting ICE Restart") to a restart.
             *
             * Unlike nice_agent_restart(), this applies to a single stream. It also
             * does not generate a new tie breaker.
             *
             * If consent-freshness has been enabled on @agent, as specified in RFC7675
             * then restart @stream_id will restore the local consent for that stream.
             * @since 0.1.6
             * @param stream_id The ID of the stream
             * @returns %TRUE on success %FALSE on error
             */
            restart_stream(stream_id: number): boolean
            /**
             * >
             * @param stream_id The ID of the stream to send to
             * @param component_id The ID of the component to send to
             * @param len The length of the buffer to send
             * @param buf The buffer of data to send
             * @returns The number of bytes sent, or negative error code
             */
            send(stream_id: number, component_id: number, len: number, buf: string): number
            /**
             * Sends multiple messages on the socket identified by the given
             * stream/component pair. Transmission is non-blocking, so a
             * %G_IO_ERROR_WOULD_BLOCK error may be returned if the send buffer is full.
             *
             * As with nice_agent_send(), the given component must be in
             * %NICE_COMPONENT_STATE_READY or, as a special case, in any state if it was
             * previously ready and was then restarted.
             *
             * On success, the number of messages written to the socket will be returned,
             * which may be less than @n_messages if transmission would have blocked
             * part-way through. Zero will be returned if @n_messages is zero, or if
             * transmission would have blocked on the first message.
             *
             * In reliable mode, it is instead recommended to use
             * nice_agent_send().  The return value can be less than @n_messages
             * or 0 even if it is still possible to send a partial message. In
             * this case, "nice-agent-writable" will never be triggered, so the
             * application would have to use nice_agent_sent() to fill the buffer or have
             * to retry sending at a later point.
             *
             * On failure, -1 will be returned and @error will be set. If the #NiceAgent is
             * reliable and the socket is not yet connected, %G_IO_ERROR_BROKEN_PIPE will be
             * returned; if the write buffer is full, %G_IO_ERROR_WOULD_BLOCK will be
             * returned. In both cases, wait for the #NiceAgent::reliable-transport-writable
             * signal before trying again. If the given @stream_id or @component_id are
             * invalid or not yet connected, %G_IO_ERROR_BROKEN_PIPE will be returned.
             * %G_IO_ERROR_FAILED will be returned for other errors.
             * @throws {GLib.Error}
             * @since 0.1.5
             * @param stream_id the ID of the stream to send to
             * @param component_id the ID of the component to send to
             * @param messages array of messages to send, of at least
            @n_messages entries in length
             * @param cancellable a #GCancellable to cancel the operation from
            another thread, or %NULL
             * @returns the number of messages sent (may be zero), or -1 on error
             */
            send_messages_nonblocking(stream_id: number, component_id: number, messages: OutputMessage[], cancellable: Gio.Cancellable | null): number
            /**
             *
             *
             * Since 0.1.11
             * @param stream_id The ID of the stream
             * @param ufrag nul-terminated string containing an ICE username fragment
               (length must be between 22 and 256 chars)
             * @param pwd nul-terminated string containing an ICE password
               (length must be between 4 and 256 chars)
             * @returns %TRUE on success, %FALSE on error.
             */
            set_local_credentials(stream_id: number, ufrag: string, pwd: string): boolean
            /**
             * >
             * @param stream_id The ID of the stream
             * @param component_id The ID of the component
             * @param min_port The minimum port to use
             * @param max_port The maximum port to use
             */
            set_port_range(stream_id: number, component_id: number, min_port: number, max_port: number): void
            /**
             * Sets the settings for using a relay server during the candidate discovery.
             * This may be called multiple times to add multiple relay servers to the
             * discovery process; one TCP and one UDP, for example.
             * @param stream_id The ID of the stream
             * @param component_id The ID of the component
             * @param server_ip The address of the TURN server
             * @param server_port The port of the TURN server
             * @param username The TURN username to use for the allocate
             * @param password The TURN password to use for the allocate
             * @param type The type of relay to use
             * @returns %TRUE if the TURN settings were accepted. %FALSE if the address was invalid.
             */
            set_relay_info(stream_id: number, component_id: number, server_ip: string, server_port: number, username: string, password: string, type: RelayType): boolean
            /**
             * >
             * @param stream_id The ID of the stream the candidates are for
             * @param component_id The ID of the component the candidates are for
             * @param candidates a #GSList of
            #NiceCandidate items describing each candidate to add
             * @returns The number of candidates added, negative on errors (memory allocation error or invalid component)
             */
            set_remote_candidates(stream_id: number, component_id: number, candidates: Candidate[]): number
            /**
             * >
             * @param stream_id The ID of the stream
             * @param ufrag nul-terminated string containing an ICE username fragment
               (length must be between 22 and 256 chars)
             * @param pwd nul-terminated string containing an ICE password
               (length must be between 4 and 256 chars)
             * @returns %TRUE on success, %FALSE on error.
             */
            set_remote_credentials(stream_id: number, ufrag: string, pwd: string): boolean
            /**
             * Sets the selected candidate pair for media transmission
             * for a given stream's component. Calling this function will
             * disable all further ICE processing (connection check,
             * state machine updates, etc). Note that keepalives will
             * continue to be sent.
             * @param stream_id The ID of the stream
             * @param component_id The ID of the component
             * @param lfoundation The local foundation of the candidate to use
             * @param rfoundation The remote foundation of the candidate to use
             * @returns %TRUE on success, %FALSE if the candidate pair cannot be found
             */
            set_selected_pair(stream_id: number, component_id: number, lfoundation: string, rfoundation: string): boolean
            /**
             * Sets the selected remote candidate for media transmission
             * for a given stream's component. This is used to force the selection of
             * a specific remote candidate even when connectivity checks are failing
             * (e.g. non-ICE compatible candidates).
             * Calling this function will disable all further ICE processing
             * (connection check, state machine updates, etc). Note that keepalives will
             * continue to be sent.
             * @param stream_id The ID of the stream
             * @param component_id The ID of the component
             * @param candidate The #NiceCandidate to select
             * @returns %TRUE on success, %FALSE on failure
             */
            set_selected_remote_candidate(stream_id: number, component_id: number, candidate: Candidate): boolean
            /**
             * >
             * @since 0.0.10
             * @param software The value of the SOFTWARE attribute to add.
             */
            set_software(software: string): void
            /**
             * >
             * @since 0.1.4
             * @param stream_id The ID of the stream to change
             * @param name The new name of the stream or %NULL
             * @returns %TRUE if the name has been set. %FALSE in case of error (invalid stream or duplicate name).
             */
            set_stream_name(stream_id: number, name: string): boolean
            /**
             * Sets the IP_TOS and/or IPV6_TCLASS field on the stream's sockets' options
             * @since 0.0.9
             * @param stream_id The ID of the stream
             * @param tos The ToS to set
             */
            set_stream_tos(stream_id: number, tos: number): void
        }

        interface AgentClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Agent>
            readonly prototype: Agent
            new (props?: Partial<GObject.ConstructorProps<Agent>>): Agent
            /**
             * Create a new #NiceAgent.
             * The returned object must be freed with g_object_unref()
             * @param ctx The Glib Mainloop Context to use for timers
             * @param compat The compatibility mode of the agent
             * @returns The new agent GObject
             */
            "new"(ctx: GLib.MainContext, compat: Compatibility): Agent
            /**
             * >
             * @since 0.1.15
             * @param ctx The Glib Mainloop Context to use for timers
             * @param compat The compatibility mode of the agent
             * @param flags Flags to set the properties
             * @returns The new agent GObject
             */
            new_full(ctx: GLib.MainContext, compat: Compatibility, flags: AgentOption): Agent
            /**
             * >
             * @since 0.0.11
             * @param ctx The Glib Mainloop Context to use for timers
             * @param compat The compatibility mode of the agent
             * @returns The new agent GObject
             */
            new_reliable(ctx: GLib.MainContext, compat: Compatibility): Agent
        }

        const Agent: AgentClass
        

        namespace PseudoTcpSocket {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "ack-delay": number
                "callbacks": never
                "conversation": number
                "no-delay": boolean
                "rcv-buf": number
                "snd-buf": number
                "state": number
                "support-fin-ack": boolean
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "ack-delay": number
                "callbacks": never
                "conversation": number
                "no-delay": boolean
                "rcv-buf": number
                "snd-buf": number
                "state": number
                "support-fin-ack": boolean
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * The #PseudoTcpSocket is the GObject implementing the Pseudo TCP Socket
         * @since 0.0.11
         */
        interface PseudoTcpSocket extends GObject.Object {
            readonly $signals: PseudoTcpSocket.SignalSignatures
            readonly $readableProperties: PseudoTcpSocket.ReadableProperties
            readonly $writableProperties: PseudoTcpSocket.WritableProperties
            readonly $constructOnlyProperties: PseudoTcpSocket.ConstructOnlyProperties
            /**
             * @default 100
             */
            get ackDelay(): number
            set ackDelay(value: number)
            /**
             */
            get callbacks(): never
            set callbacks(value: never)
            /**
             * @default 0
             */
            get conversation(): number
            set conversation(value: number)
            /**
             * @default TRUE
             */
            get noDelay(): boolean
            set noDelay(value: boolean)
            /**
             * @default 61440
             */
            get rcvBuf(): number
            set rcvBuf(value: number)
            /**
             * @default 92160
             */
            get sndBuf(): number
            set sndBuf(value: number)
            /**
             * @default 0
             */
            get state(): number
            set state(value: number)
            /**
             * Whether to support the FIN–ACK extension to the pseudo-TCP protocol for
             * this socket. The extension is only compatible with other libnice pseudo-TCP
             * stacks, and not with Jingle pseudo-TCP stacks. If enabled, support is
             * negotiatied on connection setup, so it is safe for a #PseudoTcpSocket with
             * support enabled to be used with one with it disabled, or with a Jingle
             * pseudo-TCP socket which doesn’t support it at all.
             *
             * Support is enabled by default.
             * @since 0.1.8
             * @default TRUE
             */
            get supportFinAck(): boolean
            set supportFinAck(value: boolean)
            /**
             * Returns if there is space in the send buffer to send any data.
             * @since 0.1.5
             * @returns %TRUE if data can be sent, %FALSE otherwise
             */
            can_send(): boolean
            /**
             * >
             * @since 0.0.11
             * @param force %TRUE to close the socket forcefully, %FALSE to close it gracefully
             */
            close(force: boolean): void
            /**
             * Connects the #PseudoTcpSocket to the peer with the same conversation id.
             * The connection will only be successful after the
             * %PseudoTcpCallbacks:PseudoTcpOpened callback is called
             * @since 0.0.11
             * @returns >
             */
            connect(): boolean
            /**
             * Gets the number of bytes of data in the buffer that can be read without
             * receiving more packets from the network.
             * @since 0.1.5
             * @returns The number of bytes or -1 if the connection is not established
             */
            get_available_bytes(): number
            /**
             * Gets the number of bytes of space available in the transmission buffer.
             * @since 0.1.5
             * @returns The number of bytes, or 0 if the connection is not established.
             */
            get_available_send_space(): number
            /**
             * >
             * @since 0.0.11
             * @returns >
             */
            get_error(): number
            /**
             * Call this to determine the timeout needed before the next time call
             * to pseudo_tcp_socket_notify_clock() should be made.
             * @since 0.0.11
             * @param timeout A pointer to be filled with the new timeout.
             * @returns >
             */
            get_next_clock(timeout: number): boolean
            /**
             * Gets whether the socket is closed, with the shutdown handshake completed,
             * and both peers no longer able to read or write data to the connection.
             * @since 0.1.8
             * @returns %TRUE if the socket is closed in both directions, %FALSE otherwise
             */
            is_closed(): boolean
            /**
             * Gets whether the socket has been closed on the remote peer’s side of the
             * connection (i.e. whether pseudo_tcp_socket_close() has been called there).
             * This is guaranteed to return %TRUE if pseudo_tcp_socket_is_closed() returns
             * %TRUE. It will not return %TRUE after pseudo_tcp_socket_close() is called
             * until a FIN segment is received from the remote peer.
             * @since 0.1.8
             * @returns %TRUE if the remote peer has closed its side of the connection, %FALSE otherwise
             */
            is_closed_remotely(): boolean
            /**
             * >
             * @since 0.0.11
             */
            notify_clock(): void
            /**
             * Notify the #PseudoTcpSocket that a new message has arrived, and enqueue the
             * data in its buffers to the #PseudoTcpSocket’s receive buffer.
             * @since 0.1.5
             * @param message A #NiceInputMessage containing the received data.
             * @returns %TRUE if the packet was processed successfully, %FALSE otherwise
             */
            notify_message(message: InputMessage): boolean
            /**
             * Set the MTU of the socket
             * @since 0.0.11
             * @param mtu The new MTU of the socket
             */
            notify_mtu(mtu: number): void
            /**
             * Notify the #PseudoTcpSocket when a new packet arrives
             * @since 0.0.11
             * @param buffer The buffer containing the received data
             * @param len The length of @buffer
             * @returns %TRUE if the packet was processed successfully, %FALSE otherwise
             */
            notify_packet(buffer: string, len: number): boolean
            /**
             * >
             * @since 0.0.11
             * @param buffer The buffer to fill with received data
             * @param len The length of @buffer
             * @returns >
             */
            recv(buffer: string, len: number): number
            /**
             * >
             * @since 0.0.11
             * @param buffer The buffer with data to send
             * @param len The length of @buffer
             * @returns >
             */
            send(buffer: string, len: number): number
            /**
             * Sets the current monotonic time to be used by the TCP socket when calculating
             * timeouts and expiry times. If this function is not called, or is called with
             * @current_time as zero, g_get_monotonic_time() will be used. Otherwise, the
             * specified @current_time will be used until it is updated by calling this
             * function again.
             *
             * This function is intended for testing only, and should not be used in
             * production code.
             * @since 0.1.8
             * @param current_time Current monotonic time, in milliseconds; or zero to use the
            system monotonic clock.
             */
            set_time(current_time: number): void
            /**
             * Shut down sending, receiving, or both on the socket, depending on the value
             * of @how. The behaviour of pseudo_tcp_socket_send() and
             * pseudo_tcp_socket_recv() will immediately change after this function returns
             * (depending on the value of @how), though the socket may continue to process
             * network traffic in the background even if sending or receiving data is
             * forbidden.
             *
             * This is equivalent to the POSIX shutdown() function. Setting @how to
             * %PSEUDO_TCP_SHUTDOWN_RDWR is equivalent to calling pseudo_tcp_socket_close().
             * @since 0.1.8
             * @param how The directions of the connection to shut down.
             */
            shutdown(how: PseudoTcpShutdown): void
        }

        interface PseudoTcpSocketClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<PseudoTcpSocket>
            readonly prototype: PseudoTcpSocket
            new (props?: Partial<GObject.ConstructorProps<PseudoTcpSocket>>): PseudoTcpSocket
            /**
             * >
             * @since 0.0.11
             * @param conversation The conversation id for the socket.
             * @param callbacks A pointer to the #PseudoTcpCallbacks structure for getting
            notified of the #PseudoTcpSocket events.
             * @returns The new #PseudoTcpSocket object, %NULL on error
             */
            "new"(conversation: number, callbacks: PseudoTcpCallbacks): PseudoTcpSocket
        }

        const PseudoTcpSocket: PseudoTcpSocketClass
        /**
         * The #NiceAddress structure that represents an IPv4 or IPv6 address.
         */
        abstract class Address {
            static readonly $gtype: GObject.GType<Address>

            
            /**
             * Create a new #NiceAddress with undefined address
             * You must free it with nice_address_free()
             * @returns The new #NiceAddress
             */
            static "new"(): Address
            /**
             * Fills the sockaddr structure @sin with the address contained in @addr
             * @param sin The sockaddr to fill
             */
            copy_to_sockaddr(sin: never | null): void
            /**
             * Creates a new #NiceAddress with the same address as @addr
             * @returns The new #NiceAddress
             */
            dup(): Address
            /**
             * Transforms the address @addr into a newly allocated human readable string
             * @since 0.1.20
             * @returns the address string
             */
            dup_string(): string
            /**
             * Compares two #NiceAddress structures to see if they contain the same address
             * and the same port.
             * @param b Second #NiceAddress to compare
             * @returns %TRUE if `a` and `b` are the same address, %FALSE if they are different
             */
            equal(b: Address): boolean
            /**
             * Compares two #NiceAddress structures to see if they contain the same address,
             * ignoring the port.
             * @since 0.1.8
             * @param b Second #NiceAddress to compare
             * @returns %TRUE if `a` and `b` are the same address, %FALSE if they are different
             */
            equal_no_port(b: Address): boolean
            /**
             * Frees a #NiceAddress created with nice_address_new() or nice_address_dup()
             */
            free(): void
            /**
             * Retreive the port of @addr
             * @returns The port of `addr`
             */
            get_port(): number
            /**
             * Initialize a #NiceAddress into an undefined address
             */
            init(): void
            /**
             * Returns the IP version of the address
             * @returns 4 for IPv4, 6 for IPv6 and 0 for undefined address
             */
            ip_version(): number
            /**
             * Verifies if the address in @addr is a link-local address or not
             * @since 0.1.19
             * @returns %TRUE if `addr` is a link-local address, %FALSE otherwise
             */
            is_linklocal(): boolean
            /**
             * Verifies if the address in @addr is a private address or not
             * @returns %TRUE if `addr` is a private address, %FALSE otherwise
             */
            is_private(): boolean
            /**
             * Validate whether the #NiceAddress @addr is a valid IPv4 or IPv6 address
             * @returns %TRUE if `addr` is valid, %FALSE otherwise
             */
            is_valid(): boolean
            /**
             * Sets an IPv4 or IPv6 address from the sockaddr structure @sin
             * @param sin The sockaddr to set
             */
            set_from_sockaddr(sin: never | null): void
            /**
             * Sets an IPv4 or IPv6 address from the string @str
             * @param str The string to set
             * @returns %TRUE if success, %FALSE on error
             */
            set_from_string(str: string): boolean
            /**
             * >
             * @param addr_ipv4 The IPv4 address
             */
            set_ipv4(addr_ipv4: number): void
            /**
             * >
             * @param addr_ipv6 The IPv6 address
             */
            set_ipv6(addr_ipv6: number): void
            /**
             * Set the port of @addr to @port
             * @param port The port to set
             */
            set_port(port: number): void
        }
        none
        /**
         * >
         */
        abstract class Candidate {
            static readonly $gtype: GObject.GType<Candidate>

            
            /**
             * Creates a new candidate. Must be freed with nice_candidate_free()
             * @param type The #NiceCandidateType of the candidate to create
             * @returns A new #NiceCandidate
             */
            static "new"(type: CandidateType): Candidate
            /**
             * Useful for debugging functions, just returns a static string with the
             * candidate transport.
             * @since 0.1.19
             * @param transport a #NiceCandidateTransport
             * @returns a static string with the candidate transport
             */
            static transport_to_string(transport: CandidateTransport): string
            /**
             * Useful for debugging functions, just returns a static string with the
             * candidate type.
             * @since 0.1.19
             * @param type a #NiceCandidateType
             * @returns a static string with the candidate type
             */
            static type_to_string(type: CandidateType): string
            /**
             * The type of candidate
             */
            type: CandidateType
            /**
             * The transport being used for the candidate
             */
            transport: CandidateTransport
            /**
             * The #NiceAddress of the candidate
             */
            addr: Address
            /**
             * The #NiceAddress of the base address used by the candidate
             */
            base_addr: Address
            /**
             * >
             */
            priority: number
            /**
             * The ID of the stream to which belongs the candidate
             */
            stream_id: number
            /**
             * The ID of the component to which belongs the candidate
             */
            component_id: number
            /**
             * The foundation of the candidate
             */
            foundation: number[]
            /**
             * The candidate-specific username to use (overrides the one set
             * by nice_agent_set_local_credentials() or nice_agent_set_remote_credentials())
             */
            username: string
            /**
             * The candidate-specific password to use (overrides the one set
             * by nice_agent_set_local_credentials() or nice_agent_set_remote_credentials())
             */
            password: string
            /**
             * Makes a copy of a #NiceCandidate
             * @returns A new #NiceCandidate, a copy of `candidate`
             */
            copy(): Candidate
            /**
             * Verifies that the candidates point to the same place, meaning they have
             * the same transport and the same address. It ignores all other aspects.
             * @since 0.1.15
             * @param candidate2 A candidate
             * @returns %TRUE if the candidates point to the same place
             */
            equal_target(candidate2: Candidate): boolean
            /**
             * Frees a #NiceCandidate
             */
            free(): void
            /**
             * In case the given candidate is relayed through a TURN server, use this utility function to get
             * its address.
             * @since 0.1.19
             * @param addr The #NiceAddress to fill
             */
            relay_address(addr: Address): void
            /**
             * In case the given candidate server-reflexive, use this utility function to get its address. The
             * address will be filled only if the candidate was generated using an STUN server.
             * @since 0.1.20
             * @param addr The #NiceAddress to fill
             * @returns TRUE if it's a STUN created ICE candidate, or FALSE if the reflexed's server was not STUN.
             */
            stun_server_address(addr: Address): boolean
        }
        /**
         * Represents a single message received off the network. For reliable
         * connections, this is essentially just an array of buffers (specifically,
         * @from can be ignored). for non-reliable connections, it represents a single
         * packet as received from the OS.
         *
         * @n_buffers may be -1 to indicate that @buffers is terminated by a
         * #GInputVector with a %NULL buffer pointer.
         *
         * By providing arrays of #NiceInputMessages to functions like
         * nice_agent_recv_messages(), multiple messages may be received with a single
         * call, which is more efficient than making multiple calls in a loop. In this
         * manner, nice_agent_recv_messages() is analogous to recvmmsg(); and
         * #NiceInputMessage to struct mmsghdr.
         * @since 0.1.5
         */
        abstract class InputMessage {
            static readonly $gtype: GObject.GType<InputMessage>

            
            /**
             * unowned array of #GInputVector buffers to
             * store data in for this message
             */
            buffers: Gio.InputVector[]
            /**
             * number of #GInputVectors in @buffers, or -1 to indicate @buffers
             * is %NULL-terminated
             */
            n_buffers: number
            /**
             * return location to store the address of the peer who
             * transmitted the message, or %NULL
             */
            from: Address
            /**
             * total number of valid bytes contiguously stored in @buffers
             */
            length: number
        }
        /**
         * Represents a single message to transmit on the network. For
         * reliable connections, this is essentially just an array of
         * buffer. for non-reliable connections, it represents a single packet
         * to send to the OS.
         *
         * @n_buffers may be -1 to indicate that @buffers is terminated by a
         * #GOutputVector with a %NULL buffer pointer.
         *
         * By providing arrays of #NiceOutputMessages to functions like
         * nice_agent_send_messages_nonblocking(), multiple messages may be transmitted
         * with a single call, which is more efficient than making multiple calls in a
         * loop. In this manner, nice_agent_send_messages_nonblocking() is analogous to
         * sendmmsg(); and #NiceOutputMessage to struct mmsghdr.
         * @since 0.1.5
         */
        abstract class OutputMessage {
            static readonly $gtype: GObject.GType<OutputMessage>

            
            /**
             * unowned array of #GOutputVector buffers
             * which contain data to transmit for this message
             */
            buffers: Gio.OutputVector[]
            /**
             * number of #GOutputVectors in @buffers, or -1 to indicate @buffers
             * is %NULL-terminated
             */
            n_buffers: number
        }
        /**
         * >
         * @since 0.0.11
         */
        abstract class PseudoTcpCallbacks {
            static readonly $gtype: GObject.GType<PseudoTcpCallbacks>

            
            /**
             * A user defined pointer to be passed to the callbacks
             */
            user_data: never
        }
        none
        /**
         * Useful for debugging functions, just returns a static string with the
         * candidate transport.
         * @since 0.1.19
         * @param transport a #NiceCandidateTransport
         * @returns a static string with the candidate transport
         */
        function candidate_transport_to_string(transport: CandidateTransport): string
        /**
         * Useful for debugging functions, just returns a static string with the
         * candidate type.
         * @since 0.1.19
         * @param type a #NiceCandidateType
         * @returns a static string with the candidate type
         */
        function candidate_type_to_string(type: CandidateType): string
        /**
         * Returns a string representation of the state, generally to use in debug
         * messages.
         * @since 0.1.6
         * @param state a #NiceComponentState
         * @returns a string representation of `state`
         */
        function component_state_to_string(state: ComponentState): string
        /**
         * Disables libnice debug output to the terminal
         * @param with_stun Also disable stun debugging messages
         */
        function debug_disable(with_stun: boolean): void
        /**
         * Enables libnice debug output to the terminal. Note that the
         * `G_MESSAGES_DEBUG` and `NICE_DEBUG` environment variables must be set to the
         * set of logging domains to print, in order for any output to be printed. Set
         * them to `all` to print all debugging messages, or any of the following
         * domains:
         * - `libnice-stun`
         * - `libnice-tests`
         * - `libnice-socket`
         * - `libnice`
         * - `libnice-pseudotcp`
         * - `libnice-pseudotcp-verbose`
         * @param with_stun Also enable STUN debugging messages
         */
        function debug_enable(with_stun: boolean): void
        /**
         * Returns the interface index match the local address passed. This can
         * by used for APIs that need a specific address.
         * @since 0.1.20
         * @param addr A #NiceAddress for a local interface
         * @returns The interface index or 0 on error
         */
        function interfaces_get_if_index_by_addr(addr: Address): number
        /**
         * Retrieves the IP address of an interface by its name. If this fails, %NULL
         * is returned.
         * @param interface_name name of local interface
         * @returns a newly-allocated string with the IP address
         */
        function interfaces_get_ip_for_interface(interface_name: string): string | null
        /**
         * Get the list of local interfaces
         * @returns a newly-allocated #GList of strings. The caller must free it.
         */
        function interfaces_get_local_interfaces(): string[]
        /**
         * Get a list of local ipv4 interface addresses
         * @param include_loopback Include any loopback devices
         * @returns a newly-allocated #GList of strings. The caller must free it.
         */
        function interfaces_get_local_ips(include_loopback: boolean): string[]
        /**
         * Sets the debug level to enable/disable normal/verbose debug messages.
         * @since 0.0.11
         * @param level The level of debug to set
         */
        function pseudo_tcp_set_debug_level(level: PseudoTcpDebugLevel): void
        const AGENT_MAX_REMOTE_CANDIDATES: 25
        const CANDIDATE_MAX_FOUNDATION: 33
        const CANDIDATE_MAX_LOCAL_ADDRESSES: 64
        const CANDIDATE_MAX_TURN_SERVERS: 8
        
        namespace CandidateTransport {
            const $gtype: GObject.GType<CandidateTransport>
        }

        /**
         * An enum representing the type of transport to use
         */
        enum CandidateTransport {
            /**
             * UDP transport
             */
            "UDP" = 0,
            /**
             * TCP Active transport
             */
            "TCP_ACTIVE" = 1,
            /**
             * TCP Passive transport
             */
            "TCP_PASSIVE" = 2,
            /**
             * TCP Simultaneous-Open transport
             */
            "TCP_SO" = 3,
        }
        
        namespace CandidateType {
            const $gtype: GObject.GType<CandidateType>
        }

        /**
         * An enum representing the type of a candidate
         */
        enum CandidateType {
            /**
             * A host candidate
             */
            "HOST" = 0,
            /**
             * A server reflexive candidate (or a NAT-assisted candidate)
             */
            "SERVER_REFLEXIVE" = 1,
            /**
             * A peer reflexive candidate
             */
            "PEER_REFLEXIVE" = 2,
            /**
             * A relay candidate
             */
            "RELAYED" = 3,
        }
        
        namespace Compatibility {
            const $gtype: GObject.GType<Compatibility>
        }

        /**
         * >
         */
        enum Compatibility {
            /**
             * Use compatibility with the RFC5245 ICE-UDP specs
             * and RFC6544 ICE-TCP specs
             */
            "RFC5245" = 0,
            /**
             * Use compatibility for ICE Draft 19 specs
             */
            "DRAFT19" = 0,
            /**
             * Use compatibility for Google Talk specs
             */
            "GOOGLE" = 1,
            /**
             * Use compatibility for MSN Messenger specs
             */
            "MSN" = 2,
            /**
             * Use compatibility with Windows Live Messenger
             * 2009
             */
            "WLM2009" = 3,
            /**
             * Use compatibility with Microsoft Office Communicator 2007
             */
            "OC2007" = 4,
            /**
             * Use compatibility with Microsoft Office Communicator 2007 R2
             */
            "OC2007R2" = 5,
            /**
             * Dummy last compatibility mode
             */
            "LAST" = 5,
        }
        
        namespace ComponentState {
            const $gtype: GObject.GType<ComponentState>
        }

        /**
         * >
         */
        enum ComponentState {
            /**
             * No activity scheduled
             */
            "DISCONNECTED" = 0,
            /**
             * Gathering local candidates
             */
            "GATHERING" = 1,
            /**
             * Establishing connectivity
             */
            "CONNECTING" = 2,
            /**
             * At least one working candidate pair
             */
            "CONNECTED" = 3,
            /**
             * ICE concluded, candidate pair selection
             * is now final
             */
            "READY" = 4,
            /**
             * Connectivity checks have been completed,
             * but connectivity was not established
             */
            "FAILED" = 5,
            /**
             * Dummy state
             */
            "LAST" = 6,
        }
        
        namespace ComponentType {
            const $gtype: GObject.GType<ComponentType>
        }

        /**
         * >
         */
        enum ComponentType {
            /**
             * RTP Component type
             */
            "RTP" = 1,
            /**
             * RTCP Component type
             */
            "RTCP" = 2,
        }
        
        namespace NominationMode {
            const $gtype: GObject.GType<NominationMode>
        }

        /**
         * An enum to specity the kind of nomination mode to use by
         * the agent, as described in RFC 5245. Two modes exists,
         * regular and aggressive. They differ by the way the controlling
         * agent chooses to put the USE-CANDIDATE attribute in its STUN
         * messages. The aggressive mode is supposed to nominate a pair
         * faster, than the regular mode, potentially causing the nominated
         * pair to change until the connection check completes.
         * @since 0.1.15
         */
        enum NominationMode {
            /**
             * Regular nomination mode
             */
            "REGULAR" = 0,
            /**
             * Aggressive nomination mode
             */
            "AGGRESSIVE" = 1,
        }
        
        namespace ProxyType {
            const $gtype: GObject.GType<ProxyType>
        }

        /**
         * >
         * @since 0.0.4
         */
        enum ProxyType {
            /**
             * Do not use a proxy
             */
            "NONE" = 0,
            /**
             * Use a SOCKS5 proxy
             */
            "SOCKS5" = 1,
            /**
             * Use an HTTP proxy
             */
            "HTTP" = 2,
            /**
             * Dummy last proxy type
             */
            "LAST" = 2,
        }
        
        namespace PseudoTcpDebugLevel {
            const $gtype: GObject.GType<PseudoTcpDebugLevel>
        }

        /**
         * Valid values of debug levels to be set.
         * @since 0.0.11
         */
        enum PseudoTcpDebugLevel {
            /**
             * Disable debug messages
             */
            "NONE" = 0,
            /**
             * Enable basic debug messages
             */
            "NORMAL" = 1,
            /**
             * Enable verbose debug messages
             */
            "VERBOSE" = 2,
        }
        
        namespace PseudoTcpShutdown {
            const $gtype: GObject.GType<PseudoTcpShutdown>
        }

        /**
         * Options for which parts of a connection to shut down when calling
         * pseudo_tcp_socket_shutdown(). These correspond to the values passed to POSIX
         * shutdown().
         * @since 0.1.8
         */
        enum PseudoTcpShutdown {
            /**
             * Shut down the local reader only
             */
            "RD" = 0,
            /**
             * Shut down the local writer only
             */
            "WR" = 1,
            /**
             * Shut down both reading and writing
             */
            "RDWR" = 2,
        }
        
        namespace PseudoTcpState {
            const $gtype: GObject.GType<PseudoTcpState>
        }

        /**
         * >
         * @since 0.0.11
         */
        enum PseudoTcpState {
            /**
             * The socket's initial state. The socket isn't connected and is
             * listening for an incoming connection
             */
            "LISTEN" = 0,
            /**
             * The socket has sent a connection request (SYN) packet and is
             * waiting for an answer
             */
            "SYN_SENT" = 1,
            /**
             * The socket has received a connection request (SYN) packet.
             */
            "SYN_RECEIVED" = 2,
            /**
             * The socket is connected
             */
            "ESTABLISHED" = 3,
            /**
             * The socket has been closed
             */
            "CLOSED" = 4,
            /**
             * The socket has been closed locally but not remotely
             * (Since: 0.1.8)
             */
            "FIN_WAIT_1" = 5,
            /**
             * The socket has been closed locally but not remotely
             * (Since: 0.1.8)
             */
            "FIN_WAIT_2" = 6,
            /**
             * The socket has been closed locally and remotely
             * (Since: 0.1.8)
             */
            "CLOSING" = 7,
            /**
             * The socket has been closed locally and remotely
             * (Since: 0.1.8)
             */
            "TIME_WAIT" = 8,
            /**
             * The socket has been closed remotely but not locally
             * (Since: 0.1.8)
             */
            "CLOSE_WAIT" = 9,
            /**
             * The socket has been closed locally and remotely
             * (Since: 0.1.8)
             */
            "LAST_ACK" = 10,
        }
        
        namespace PseudoTcpWriteResult {
            const $gtype: GObject.GType<PseudoTcpWriteResult>
        }

        /**
         * >
         * @since 0.0.11
         */
        enum PseudoTcpWriteResult {
            /**
             * The write operation was successful
             */
            "SUCCESS" = 0,
            /**
             * The socket type requires that message be sent atomically
             * and the size of the message to be sent made this impossible.
             */
            "TOO_LARGE" = 1,
            /**
             * There was an error sending the message
             */
            "FAIL" = 2,
        }
        
        namespace RelayType {
            const $gtype: GObject.GType<RelayType>
        }

        /**
         * An enum representing the type of relay to use
         */
        enum RelayType {
            /**
             * A TURN relay using UDP
             */
            "UDP" = 0,
            /**
             * A TURN relay using TCP
             */
            "TCP" = 1,
            /**
             * A TURN relay using TLS over TCP
             */
            "TLS" = 2,
        }
        
        namespace AgentOption {
            const $gtype: GObject.GType<AgentOption>
        }

        /**
         * These are options that can be passed to nice_agent_new_full(). They set
         * various properties on the agent. Not including them sets the property to
         * the other value.
         * @since 0.1.15
         */
        enum AgentOption {
            /**
             * No enabled options (Since: 0.1.19)
             */
            "NONE" = 0,
            /**
             * Enables regular nomination, default
             *  is aggrssive mode (see #NiceNominationMode).
             */
            "REGULAR_NOMINATION" = 1,
            /**
             * Enables reliable mode, possibly using PseudoTCP, *  see nice_agent_new_reliable().
             */
            "RELIABLE" = 2,
            /**
             * Enable lite mode
             */
            "LITE_MODE" = 4,
            /**
             * Enable ICE trickle mode
             */
            "ICE_TRICKLE" = 8,
            /**
             * Enable renomination triggered by NOMINATION STUN attribute
             * proposed here: https://tools.ietf.org/html/draft-thatcher-ice-renomination-00
             */
            "SUPPORT_RENOMINATION" = 16,
            /**
             * Enable RFC 7675 consent freshness support. (Since: 0.1.19)
             */
            "CONSENT_FRESHNESS" = 32,
            /**
             * Use bytestream mode for reliable TCP connections. (Since: 0.1.20)
             */
            "BYTESTREAM_TCP" = 64,
            /**
             * When removing TURN port allocations on TURN server,
             * don't do retransmissions and don't wait for a response. (Since: 0.1.23)
             */
            "CLOSE_FORCED" = 128,
        }
        /**
         * Callback function when data is received on a component
         * @param agent The #NiceAgent Object
         * @param stream_id The id of the stream
         * @param component_id The id of the component of the stream
               which received the data
         * @param len The length of the data
         * @param buf The buffer containing the data received
         */
        type AgentRecvFunc = (agent: Agent, stream_id: number, component_id: number, len: number, buf: string) => void
    }

    export default Nice
}