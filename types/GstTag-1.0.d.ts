
/// <reference path="./GLib-2.0.d.ts" />
/// <reference path="./GModule-2.0.d.ts" />
/// <reference path="./GObject-2.0.d.ts" />
/// <reference path="./Gst-1.0.d.ts" />
/// <reference path="./GstBase-1.0.d.ts" />

/**
 * Type Definitions for GJS (https://gjs.guide/), generated by [GirGen](https://github.com/aylur/girgen)
 * If you found a bug, create a bug report on [GirGen's Repository](https://github.com/aylur/girgen/issues/new)
 */
declare module "gi://GstTag?version=1.0" {
    import type GLib from "gi://GLib?version=2.0"
    import type GModule from "gi://GModule?version=2.0"
    import type GObject from "gi://GObject?version=2.0"
    import type Gst from "gi://Gst?version=1.0"
    import type GstBase from "gi://GstBase?version=1.0"

    


    namespace GstTag {
        const __name__: "GstTag"
        const __version: "1.0"
        

        namespace TagXmpWriter {
            interface SignalSignatures extends Gst.Element.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Element.ReadableProperties {
            }

            interface WritableProperties extends Gst.Element.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.Element.ConstructOnlyProperties {
            }

            interface Interface extends Gst.Element {
            }
        }

        /**
         * This interface is implemented by elements that are able to do XMP serialization. Examples for
         * such elements are #jifmux and #qtmux.
         *
         * Applications can use this interface to configure which XMP schemas should be used when serializing
         * tags into XMP. Schemas are represented by their names, a full list of the supported schemas can be
         * obtained from gst_tag_xmp_list_schemas(). By default, all schemas are used.
         */
        interface TagXmpWriter extends Gst.Element, TagXmpWriter.Interface {
            readonly $signals: TagXmpWriter.SignalSignatures
            readonly $readableProperties: TagXmpWriter.ReadableProperties
            readonly $writableProperties: TagXmpWriter.WritableProperties
            readonly $constructOnlyProperties: TagXmpWriter.ConstructOnlyProperties
            /**
             * Adds all available XMP schemas to the configuration. Meaning that
             * all will be used.
             */
            add_all_schemas(): void
            /**
             * Adds @schema to the list schemas
             * @param schema the schema to be added
             */
            add_schema(schema: string): void
            /**
             * Checks if @schema is going to be used
             * @param schema the schema to test
             * @returns %TRUE if it is going to be used
             */
            has_schema(schema: string): boolean
            /**
             * Removes all schemas from the list of schemas to use. Meaning that no
             * XMP will be generated.
             */
            remove_all_schemas(): void
            /**
             * Removes a schema from the list of schemas to use. Nothing is done if
             * the schema wasn't in the list
             * @param schema the schema to remove
             */
            remove_schema(schema: string): void
            /**
             * @param taglist
             * @param read_only
             */
            tag_list_to_xmp_buffer(taglist: Gst.TagList, read_only: boolean): Gst.Buffer
        }


        interface TagXmpWriterInterface {
            readonly $gtype: GObject.GType<TagXmpWriter>
            readonly prototype: TagXmpWriter

            [Symbol.hasInstance](instance: unknown): instance is TagXmpWriter
        }

        const TagXmpWriter: TagXmpWriterInterface
        

        namespace TagDemux {
            interface SignalSignatures extends Gst.Element.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Element.ReadableProperties {
            }

            interface WritableProperties extends Gst.Element.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.Element.ConstructOnlyProperties {
            }
        }

        /**
         * min_end_size to the minimum size required
         *  for the identify function to decide whether the stream has a supported tag
         *  or not. A class parsing ID3v1 tags, for example, would set min_end_size to
         *  128 bytes.
         */
        interface TagDemux extends Gst.Element {
            readonly $signals: TagDemux.SignalSignatures
            readonly $readableProperties: TagDemux.ReadableProperties
            readonly $writableProperties: TagDemux.WritableProperties
            readonly $constructOnlyProperties: TagDemux.ConstructOnlyProperties
            /**
             * identify tag and determine the size required to parse the
             * tag. Buffer may be larger than the specified minimum size.
             * Subclassed MUST override this vfunc in their class_init function.
             * @param buffer
             * @param start_tag
             * @param tag_size
             */
            vfunc_identify_tag(buffer: Gst.Buffer, start_tag: boolean, tag_size: number): boolean
            /**
             * merge start and end tags. Subclasses may want to override this
             * vfunc to allow prioritising of start or end tag according to user
             * preference.  Note that both start_tags and end_tags may be NULL. By default
             * start tags are preferred over end tags.
             * @param start_tags
             * @param end_tags
             */
            vfunc_merge_tags(start_tags: Gst.TagList, end_tags: Gst.TagList): Gst.TagList
            /**
             * parse the tag. Buffer will be exactly of the size determined by
             * the identify_tag vfunc before. The parse_tag vfunc may change the size
             * stored in *tag_size and return GST_TAG_DEMUX_RESULT_AGAIN to request a
             * larger or smaller buffer. It is also permitted to adjust the tag_size to a
             * smaller value and then return GST_TAG_DEMUX_RESULT_OK in one go.
             * Subclassed MUST override the parse_tag vfunc in their class_init function.
             * @param buffer
             * @param start_tag
             * @param tag_size
             * @param tags
             */
            vfunc_parse_tag(buffer: Gst.Buffer, start_tag: boolean, tag_size: number, tags: Gst.TagList): TagDemuxResult
        }

        interface TagDemuxClass extends Omit<Gst.ElementClass, "new"> {
            readonly $gtype: GObject.GType<TagDemux>
            readonly prototype: TagDemux
            new (props?: Partial<GObject.ConstructorProps<TagDemux>>): TagDemux
        }

        const TagDemux: TagDemuxClass
        

        namespace TagMux {
            interface SignalSignatures extends Gst.Element.SignalSignatures, Gst.TagSetter.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Element.ReadableProperties, Gst.TagSetter.ReadableProperties {
            }

            interface WritableProperties extends Gst.Element.WritableProperties, Gst.TagSetter.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.Element.ConstructOnlyProperties, Gst.TagSetter.ConstructOnlyProperties {
            }
        }

        /**
         * render_end_tag vfuncs and set up a render
         *    function.
         */
        interface TagMux extends Gst.Element, Gst.TagSetter {
            readonly $signals: TagMux.SignalSignatures
            readonly $readableProperties: TagMux.ReadableProperties
            readonly $writableProperties: TagMux.WritableProperties
            readonly $constructOnlyProperties: TagMux.ConstructOnlyProperties
            /**
             * create a tag buffer to add to the end of the
             *     input stream given a tag list, or NULL
             * @param tag_list
             */
            vfunc_render_end_tag(tag_list: Gst.TagList): Gst.Buffer
            /**
             * create a tag buffer to add to the beginning of the
             *     input stream given a tag list, or NULL
             * @param tag_list
             */
            vfunc_render_start_tag(tag_list: Gst.TagList): Gst.Buffer
        }

        interface TagMuxClass extends Omit<Gst.ElementClass, "new"> {
            readonly $gtype: GObject.GType<TagMux>
            readonly prototype: TagMux
            new (props?: Partial<GObject.ConstructorProps<TagMux>>): TagMux
        }

        const TagMux: TagMuxClass
        none
        /**
         */
        abstract class TagDemuxPrivate {
            static readonly $gtype: GObject.GType<TagDemuxPrivate>

            
        }
        none
        /**
         */
        abstract class TagMuxPrivate {
            static readonly $gtype: GObject.GType<TagMuxPrivate>

            
        }
        none
        /**
         * Check if a given string contains a known ISO 639 language code.
         *
         * This is useful in situations where it's not clear whether a given
         * string is a language code (which should be put into a #GST_TAG_LANGUAGE_CODE
         * tag) or a free-form language name descriptor (which should be put into a
         * #GST_TAG_LANGUAGE_NAME tag instead).
         * @param lang_code ISO-639 language code (e.g. "deu" or "ger" or "de")
         * @returns TRUE if the two- or three-letter language code in `lang_code`     is a valid ISO-639 language code.
         */
        function tag_check_language_code(lang_code: string): boolean
        /**
         * Convenience function to read a string with unknown character encoding. If
         * the string is already in UTF-8 encoding, it will be returned right away.
         * If not it tries to detect byte-order-mark for UTF-16/32 cases and use that.
         * Otherwise, the environment will be searched for a number of environment
         * variables (whose names are specified in the NULL-terminated string array
         * @env_vars) containing a list of character encodings to try/use. If none
         * are specified, the current locale will be tried. If that also doesn't work,
         * WINDOWS-1252/ISO-8859-1 is assumed (which will almost always succeed).
         * @param data string data
         * @param env_vars 
           a NULL-terminated string array of environment variable names, or NULL
         * @returns a newly-allocated string in UTF-8 encoding, or NULL
         */
        function tag_freeform_string_to_utf8(data: number[], env_vars: string[]): string | null
        /**
         * Looks up the GStreamer tag for a ID3v2 tag.
         * @param id3_tag ID3v2 tag to convert to GStreamer tag
         * @returns The corresponding GStreamer tag or NULL if none exists.
         */
        function tag_from_id3_tag(id3_tag: string): string | null
        /**
         * Looks up the GStreamer tag for an ID3v2 user tag (e.g. description in
         * TXXX frame or owner in UFID frame).
         * @param type the type of ID3v2 user tag (e.g. "TXXX" or "UDIF")
         * @param id3_user_tag ID3v2 user tag to convert to GStreamer tag
         * @returns The corresponding GStreamer tag or NULL if none exists.
         */
        function tag_from_id3_user_tag(type: string, id3_user_tag: string): string | null
        /**
         * Looks up the GStreamer tag for a vorbiscomment tag.
         * @param vorbis_tag vorbiscomment tag to convert to GStreamer tag
         * @returns The corresponding GStreamer tag or NULL if none exists.
         */
        function tag_from_vorbis_tag(vorbis_tag: string): string | null
        /**
         * Determines size of an ID3v2 tag on buffer containing at least ID3v2 header,
         * i.e. at least #GST_TAG_ID3V2_HEADER_SIZE (10) bytes;
         * @param buffer buffer holding ID3v2 tag (or at least the start of one)
         * @returns Size of tag, or 0 if header is invalid or too small.
         */
        function tag_get_id3v2_tag_size(buffer: Gst.Buffer): number
        /**
         * Returns two-letter ISO-639-1 language code given a three-letter ISO-639-2
         * language code or two-letter ISO-639-1 language code (both are accepted for
         * convenience).
         *
         * Language codes are case-sensitive and expected to be lower case.
         * @param lang_code ISO-639 language code (e.g. "deu" or "ger" or "de")
         * @returns two-letter ISO-639-1 language code string that maps to `lang_code`,     or NULL if no mapping is known. The returned string must not be     modified or freed.
         */
        function tag_get_language_code_iso_639_1(lang_code: string): string | null
        /**
         * Returns three-letter ISO-639-2 "bibliographic" language code given a
         * two-letter ISO-639-1 language code or a three-letter ISO-639-2 language
         * code (both are accepted for convenience).
         *
         * The "bibliographic" code is derived from the English name of the language
         * (e.g. "ger" for German instead of "de" or "deu"). In most scenarios, the
         * "terminological" codes are preferred.
         *
         * Language codes are case-sensitive and expected to be lower case.
         * @param lang_code ISO-639 language code (e.g. "deu" or "ger" or "de")
         * @returns three-letter ISO-639-2 language code string that maps to `lang_code`,     or NULL if no mapping is known. The returned string must not be     modified or freed.
         */
        function tag_get_language_code_iso_639_2B(lang_code: string): string | null
        /**
         * Returns three-letter ISO-639-2 "terminological" language code given a
         * two-letter ISO-639-1 language code or a three-letter ISO-639-2 language
         * code (both are accepted for convenience).
         *
         * The "terminological" code is derived from the local name of the language
         * (e.g. "deu" for German instead of "ger"). In most scenarios, the
         * "terminological" codes are preferred over the "bibliographic" ones.
         *
         * Language codes are case-sensitive and expected to be lower case.
         * @param lang_code ISO-639 language code (e.g. "deu" or "ger" or "de")
         * @returns three-letter ISO-639-2 language code string that maps to `lang_code`,     or NULL if no mapping is known. The returned string must not be     modified or freed.
         */
        function tag_get_language_code_iso_639_2T(lang_code: string): string | null
        /**
         * Returns a list of known language codes (in form of two-letter ISO-639-1
         * codes). This is useful for UIs to build a list of available languages for
         * tagging purposes (e.g. to tag an audio track appropriately in a video or
         * audio editor).
         * @returns NULL-terminated string array with two-letter     language codes. Free with g_strfreev() when no longer needed.
         */
        function tag_get_language_codes(): string[]
        /**
         * Returns the name of the language given an ISO-639 language code as
         * found in a GST_TAG_LANGUAGE_CODE tag. The name will be translated
         * according to the current locale (if the library was built against the
         * iso-codes package, otherwise the English name will be returned).
         *
         * Language codes are case-sensitive and expected to be lower case.
         * @param language_code two or three-letter ISO-639 language code
         * @returns language name in UTF-8 format, or NULL if `language_code` could     not be mapped to a language name. The returned string must not be     modified and does not need to freed; it will stay valid until the     application is terminated.
         */
        function tag_get_language_name(language_code: string): string | null
        /**
         * Get the description of a license, which is a translated description
         * of the license's main features.
         * @param license_ref a license reference string in form of a URI,
            e.g. "http://creativecommons.org/licenses/by-nc-nd/2.0/"
         * @returns the description of the license, or NULL if the license is unknown    or a description is not available.
         */
        function tag_get_license_description(license_ref: string): string | null
        /**
         * Get the flags of a license, which describe most of the features of
         * a license in their most general form.
         * @param license_ref a license reference string in form of a URI,
            e.g. "http://creativecommons.org/licenses/by-nc-nd/2.0/"
         * @returns the flags of the license, or 0 if the license is unknown
         */
        function tag_get_license_flags(license_ref: string): TagLicenseFlags
        /**
         * Get the jurisdiction code of a license. This is usually a two-letter
         * ISO 3166-1 alpha-2 code, but there is also the special case of Scotland,
         * for which no code exists and which is thus represented as "scotland".
         *
         * Known jurisdictions: ar, at, au, be, bg, br, ca, ch, cl, cn, co, de,
         * dk, es, fi, fr, hr, hu, il, in, it, jp, kr, mk, mt, mx, my, nl, pe, pl,
         * pt, scotland, se, si, tw, uk, us, za.
         * @param license_ref a license reference string in form of a URI,
            e.g. "http://creativecommons.org/licenses/by-nc-nd/2.0/"
         * @returns the jurisdiction code of the license, or NULL if the license is    unknown or is not specific to a particular jurisdiction.
         */
        function tag_get_license_jurisdiction(license_ref: string): string | null
        /**
         * Get the nick name of a license, which is a short (untranslated) string
         * such as e.g. "CC BY-NC-ND 2.0 UK".
         * @param license_ref a license reference string in form of a URI,
            e.g. "http://creativecommons.org/licenses/by-nc-nd/2.0/"
         * @returns the nick name of the license, or NULL if the license is unknown
         */
        function tag_get_license_nick(license_ref: string): string | null
        /**
         * Get the title of a license, which is a short translated description
         * of the license's features (generally not very pretty though).
         * @param license_ref a license reference string in form of a URI,
            e.g. "http://creativecommons.org/licenses/by-nc-nd/2.0/"
         * @returns the title of the license, or NULL if the license is unknown or    no title is available.
         */
        function tag_get_license_title(license_ref: string): string | null
        /**
         * Get the version of a license.
         * @param license_ref a license reference string in form of a URI,
            e.g. "http://creativecommons.org/licenses/by-nc-nd/2.0/"
         * @returns the version of the license, or NULL if the license is not known or    has no version
         */
        function tag_get_license_version(license_ref: string): string | null
        /**
         * Returns a list of known license references (in form of URIs). This is
         * useful for UIs to build a list of available licenses for tagging purposes
         * (e.g. to tag an audio track appropriately in a video or audio editor, or
         * an image in a camera application).
         * @returns NULL-terminated array of license strings. Free     with g_strfreev() when no longer needed.
         */
        function tag_get_licenses(): string[]
        /**
         * Gets the number of ID3v1 genres that can be identified. Winamp genres are
         * included.
         * @returns the number of ID3v1 genres that can be identified
         */
        function tag_id3_genre_count(): number
        /**
         * Gets the ID3v1 genre name for a given ID.
         * @param id ID of genre to query
         * @returns the genre or NULL if no genre is associated with that ID.
         */
        function tag_id3_genre_get(id: number): string | null
        /**
         * s containing the raw image
         * data, with the sample caps describing the content type of the image
         * (e.g. image/jpeg, image/png, text/uri-list). The sample info may contain
         * an additional 'image-type' field of #GstTagImageType to describe
         * the type of image (front cover, back cover etc.). #GST_TAG_PREVIEW_IMAGE
         * tags should not carry an image type, their type is already indicated via
         * the special tag name.
         *
         * This function will do various checks and typefind the encoded image
         * data (we can't trust the declared mime type).
         * @param image_data the (encoded) image
         * @param image_type type of the image, or #GST_TAG_IMAGE_TYPE_UNDEFINED. Pass
            #GST_TAG_IMAGE_TYPE_NONE if no image type should be set at all (e.g.
            for preview images)
         * @returns a newly-allocated image sample for use in tag lists, or NULL
         */
        function tag_image_data_to_image_sample(image_data: Uint8Array, image_type: TagImageType): Gst.Sample | null
        /**
         * Adds an image from an ID3 APIC frame (or similar, such as used in FLAC)
         * to the given tag list. Also see gst_tag_image_data_to_image_sample() for
         * more information on image tags in GStreamer.
         * @param tag_list a tag list
         * @param image_data the (encoded) image
         * @param id3_picture_type picture type as per the ID3 (v2.4.0) specification for
           the APIC frame (0 = unknown/other)
         * @returns %TRUE if the image was processed, otherwise %FALSE
         */
        function tag_list_add_id3_image(tag_list: Gst.TagList, image_data: Uint8Array, id3_picture_type: number): boolean
        /**
         * Parses the IFD and IFD tags data contained in the buffer and puts it
         * on a taglist. The base_offset is used to subtract from the offset in
         * the tag entries and be able to get the offset relative to the buffer
         * start
         * @param buffer The exif buffer
         * @param byte_order byte order of the data
         * @param base_offset Offset from the tiff header to this buffer
         * @returns The parsed taglist
         */
        function tag_list_from_exif_buffer(buffer: Gst.Buffer, byte_order: number, base_offset: number): Gst.TagList
        /**
         * Parses the exif tags starting with a tiff header structure.
         * @param buffer The exif buffer
         * @returns The taglist
         */
        function tag_list_from_exif_buffer_with_tiff_header(buffer: Gst.Buffer): Gst.TagList
        /**
         * Creates a new tag list that contains the information parsed out of a
         * ID3 tag.
         * @param buffer buffer to convert
         * @returns A new #GstTagList with all tags that could be extracted from the          given vorbiscomment buffer or NULL on error.
         */
        function tag_list_from_id3v2_tag(buffer: Gst.Buffer): Gst.TagList | null
        /**
         * Creates a new tag list that contains the information parsed out of a
         * vorbiscomment packet.
         * @param data data to convert
         * @param id_data identification data at start of stream
         * @returns A new #GstTagList with all tags that could be extracted from the          given vorbiscomment buffer or NULL on error., pointer to a string that should take the     vendor string of this vorbis comment or NULL if you don't need it.
         */
        function tag_list_from_vorbiscomment(data: Uint8Array, id_data: Uint8Array): Gst.TagList | null
        /**
         * Creates a new tag list that contains the information parsed out of a
         * vorbiscomment packet.
         * @param buffer buffer to convert
         * @param id_data identification data at start of stream
         * @returns A new #GstTagList with all tags that could be extracted from the          given vorbiscomment buffer or NULL on error., pointer to a string that should take the     vendor string of this vorbis comment or NULL if you don't need it.
         */
        function tag_list_from_vorbiscomment_buffer(buffer: Gst.Buffer, id_data: Uint8Array): Gst.TagList | null
        /**
         * Parse a xmp packet into a taglist.
         * @param buffer buffer
         * @returns new taglist or %NULL, free the list when done
         */
        function tag_list_from_xmp_buffer(buffer: Gst.Buffer): Gst.TagList | null
        /**
         * Parses the data containing an ID3v1 tag and returns a #GstTagList from the
         * parsed data.
         * @param data 128 bytes of data containing the ID3v1 tag
         * @returns A new tag list or NULL if the data was not an ID3v1 tag.
         */
        function tag_list_new_from_id3v1(data: Uint8Array): Gst.TagList | null
        /**
         * Formats the tags in taglist on exif format. The resulting buffer contains
         * the tags IFD and is followed by the data pointed by the tag entries.
         * @param taglist The taglist
         * @param byte_order byte order used in writing (G_LITTLE_ENDIAN or G_BIG_ENDIAN)
         * @param base_offset Offset from the tiff header first byte
         * @returns A GstBuffer containing the tag entries followed by the tag data
         */
        function tag_list_to_exif_buffer(taglist: Gst.TagList, byte_order: number, base_offset: number): Gst.Buffer
        /**
         * Formats the tags in taglist into exif structure, a tiff header
         * is put in the beginning of the buffer.
         * @param taglist The taglist
         * @returns A GstBuffer containing the data
         */
        function tag_list_to_exif_buffer_with_tiff_header(taglist: Gst.TagList): Gst.Buffer
        /**
         * Creates a new vorbiscomment buffer from a tag list.
         * @param list tag list to convert
         * @param id_data identification data at start of stream
         * @param vendor_string string that describes the vendor string or NULL
         * @returns A new #GstBuffer containing a vorbiscomment buffer with all tags          that could be converted from the given tag list.
         */
        function tag_list_to_vorbiscomment_buffer(list: Gst.TagList, id_data: Uint8Array, vendor_string: string | null): Gst.Buffer
        /**
         * Formats a taglist as a xmp packet using only the selected
         * schemas. An empty list (%NULL) means that all schemas should
         * be used
         * @param list tags
         * @param read_only does the container forbid inplace editing
         * @param schemas 
            %NULL terminated array of schemas to be used on serialization
         * @returns new buffer or %NULL, unref the buffer when done
         */
        function tag_list_to_xmp_buffer(list: Gst.TagList, read_only: boolean, schemas: string[]): Gst.Buffer | null
        /**
         * Convenience function to parse a GST_TAG_EXTENDED_COMMENT string and
         * separate it into its components.
         *
         * If successful, @key, @lang and/or @value will be set to newly allocated
         * strings that you need to free with g_free() when done. @key and @lang
         * may also be set to NULL by this function if there is no key or no language
         * code in the extended comment string.
         * @param ext_comment an extended comment string, see #GST_TAG_EXTENDED_COMMENT
         * @param fail_if_no_key whether to fail if strings are not in key=value form
         * @returns TRUE if the string could be parsed, otherwise FALSE,      return location for the comment description key, or NULL,      return location for the comment ISO-639 language code, or NULL, return location for the actual comment string, or NULL
         */
        function tag_parse_extended_comment(ext_comment: string, fail_if_no_key: boolean): [boolean, string | null, string | null, string]
        /**
         * Registers additional musicbrainz-specific tags with the GStreamer tag
         * system. Plugins and applications that use these tags should call this
         * function before using them. Can be called multiple times.
         */
        function tag_register_musicbrainz_tags(): void
        /**
         * Looks up the ID3v2 tag for a GStreamer tag.
         * @param gst_tag GStreamer tag to convert to vorbiscomment tag
         * @returns The corresponding ID3v2 tag or NULL if none exists.
         */
        function tag_to_id3_tag(gst_tag: string): string | null
        /**
         * Creates a new tag list that contains the information parsed out of a
         * vorbiscomment packet.
         * @param list a #GstTagList
         * @param tag a GStreamer tag identifier, such as #GST_TAG_ARTIST
         * @returns A #GList of newly-allocated     key=value strings. Free with g_list_foreach (list, (GFunc) g_free, NULL)     plus g_list_free (list)
         */
        function tag_to_vorbis_comments(list: Gst.TagList, tag: string): string[]
        /**
         * Looks up the vorbiscomment tag for a GStreamer tag.
         * @param gst_tag GStreamer tag to convert to vorbiscomment tag
         * @returns The corresponding vorbiscomment tag or NULL if none exists.
         */
        function tag_to_vorbis_tag(gst_tag: string): string | null
        /**
         * Gets the list of supported schemas in the xmp lib
         * @returns a %NULL terminated array of strings with the     schema names
         */
        function tag_xmp_list_schemas(): string[]
        /**
         * Convenience function using gst_tag_from_vorbis_tag(), parsing
         * a vorbis comment string into the right type and adding it to the
         * given taglist @list.
         *
         * Unknown vorbiscomment tags will be added to the tag list in form
         * of a #GST_TAG_EXTENDED_COMMENT.
         * @param list a #GstTagList
         * @param tag a vorbiscomment tag string (key in key=value), must be valid UTF-8
         * @param value a vorbiscomment value string (value in key=value), must be valid UTF-8
         */
        function vorbis_tag_add(list: Gst.TagList, tag: string, value: string): void
        const TAG_ACOUSTID_FINGERPRINT: "chromaprint-fingerprint"
        const TAG_ACOUSTID_ID: "acoustid-id"
        const TAG_CAPTURING_CONTRAST: "capturing-contrast"
        const TAG_CAPTURING_DIGITAL_ZOOM_RATIO: "capturing-digital-zoom-ratio"
        const TAG_CAPTURING_EXPOSURE_COMPENSATION: "capturing-exposure-compensation"
        const TAG_CAPTURING_EXPOSURE_MODE: "capturing-exposure-mode"
        const TAG_CAPTURING_EXPOSURE_PROGRAM: "capturing-exposure-program"
        const TAG_CAPTURING_FLASH_FIRED: "capturing-flash-fired"
        const TAG_CAPTURING_FLASH_MODE: "capturing-flash-mode"
        const TAG_CAPTURING_FOCAL_LENGTH: "capturing-focal-length"
        const TAG_CAPTURING_FOCAL_LENGTH_35_MM: "capturing-focal-length-35mm"
        const TAG_CAPTURING_FOCAL_RATIO: "capturing-focal-ratio"
        const TAG_CAPTURING_GAIN_ADJUSTMENT: "capturing-gain-adjustment"
        const TAG_CAPTURING_ISO_SPEED: "capturing-iso-speed"
        const TAG_CAPTURING_LIGHT_SOURCE: "capturing-light-source"
        const TAG_CAPTURING_METERING_MODE: "capturing-metering-mode"
        const TAG_CAPTURING_SATURATION: "capturing-saturation"
        const TAG_CAPTURING_SCENE_CAPTURE_TYPE: "capturing-scene-capture-type"
        const TAG_CAPTURING_SHARPNESS: "capturing-sharpness"
        const TAG_CAPTURING_SHUTTER_SPEED: "capturing-shutter-speed"
        const TAG_CAPTURING_SOURCE: "capturing-source"
        const TAG_CAPTURING_WHITE_BALANCE: "capturing-white-balance"
        const TAG_CDDA_CDDB_DISCID: "discid"
        const TAG_CDDA_CDDB_DISCID_FULL: "discid-full"
        const TAG_CDDA_MUSICBRAINZ_DISCID: "musicbrainz-discid"
        const TAG_CDDA_MUSICBRAINZ_DISCID_FULL: "musicbrainz-discid-full"
        const TAG_CMML_CLIP: "cmml-clip"
        const TAG_CMML_HEAD: "cmml-head"
        const TAG_CMML_STREAM: "cmml-stream"
        const TAG_ID3V2_HEADER_SIZE: 10
        const TAG_IMAGE_HORIZONTAL_PPI: "image-horizontal-ppi"
        const TAG_IMAGE_VERTICAL_PPI: "image-vertical-ppi"
        const TAG_MUSICAL_KEY: "musical-key"
        const TAG_MUSICBRAINZ_ALBUMARTISTID: "musicbrainz-albumartistid"
        const TAG_MUSICBRAINZ_ALBUMID: "musicbrainz-albumid"
        const TAG_MUSICBRAINZ_ARTISTID: "musicbrainz-artistid"
        const TAG_MUSICBRAINZ_RELEASEGROUPID: "musicbrainz-releasegroupid"
        const TAG_MUSICBRAINZ_RELEASETRACKID: "musicbrainz-releasetrackid"
        const TAG_MUSICBRAINZ_TRACKID: "musicbrainz-trackid"
        const TAG_MUSICBRAINZ_TRMID: "musicbrainz-trmid"
        
        namespace TagDemuxResult {
            const $gtype: GObject.GType<TagDemuxResult>
        }

        /**
         * Result values from the parse_tag virtual function.
         */
        enum TagDemuxResult {
            /**
             * cannot parse tag, just skip it
             */
            "BROKEN_TAG" = 0,
            /**
             * call again with less or more data
             */
            "AGAIN" = 1,
            /**
             * parsed tag successfully
             */
            "OK" = 2,
        }
        
        namespace TagImageType {
            const $gtype: GObject.GType<TagImageType>
        }

        /**
         * Type of image contained in an image tag (specified as "image-type" field in
         * the info structure in the image's #GstSample)
         */
        enum TagImageType {
            /**
             * No image type. Can be used to
             *      tell functions such as gst_tag_image_data_to_image_sample() that no
             *      image type should be set.
             */
            "NONE" = -1,
            /**
             * Undefined/other image type
             */
            "UNDEFINED" = 0,
            /**
             * Cover (front)
             */
            "FRONT_COVER" = 1,
            /**
             * Cover (back)
             */
            "BACK_COVER" = 2,
            /**
             * Leaflet page
             */
            "LEAFLET_PAGE" = 3,
            /**
             * Medium (e.g. label side of CD)
             */
            "MEDIUM" = 4,
            /**
             * Lead artist/lead performer/soloist
             */
            "LEAD_ARTIST" = 5,
            /**
             * Artist/performer
             */
            "ARTIST" = 6,
            /**
             * Conductor
             */
            "CONDUCTOR" = 7,
            /**
             * Band/orchestra
             */
            "BAND_ORCHESTRA" = 8,
            /**
             * Composer
             */
            "COMPOSER" = 9,
            /**
             * Lyricist/text writer
             */
            "LYRICIST" = 10,
            /**
             * Recording location
             */
            "RECORDING_LOCATION" = 11,
            /**
             * During recording
             */
            "DURING_RECORDING" = 12,
            /**
             * During performance
             */
            "DURING_PERFORMANCE" = 13,
            /**
             * Movie/video screen capture
             */
            "VIDEO_CAPTURE" = 14,
            /**
             * A fish as funny as the ID3v2 spec
             */
            "FISH" = 15,
            /**
             * Illustration
             */
            "ILLUSTRATION" = 16,
            /**
             * Band/artist logotype
             */
            "BAND_ARTIST_LOGO" = 17,
            /**
             * Publisher/studio logotype
             */
            "PUBLISHER_STUDIO_LOGO" = 18,
        }
        
        namespace TagLicenseFlags {
            const $gtype: GObject.GType<TagLicenseFlags>
        }

        /**
         * See http://creativecommons.org/ns for more information.
         */
        enum TagLicenseFlags {
            /**
             * making multiple copies
             *     is allowed
             */
            "PERMITS_REPRODUCTION" = 1,
            /**
             * distribution, public display
             *     and public performance are allowed
             */
            "PERMITS_DISTRIBUTION" = 2,
            /**
             * distribution of derivative
             *     works is allowed
             */
            "PERMITS_DERIVATIVE_WORKS" = 4,
            /**
             * commercial derivatives are allowed,
             *     but only non-commercial distribution is allowed
             */
            "PERMITS_SHARING" = 8,
            /**
             * copyright and license notices
             *     must be kept intact
             */
            "REQUIRES_NOTICE" = 256,
            /**
             * credit must be given to
             *     copyright holder and/or author
             */
            "REQUIRES_ATTRIBUTION" = 512,
            /**
             * derivative works must be
             *     licensed under the same terms or compatible terms as the original work
             */
            "REQUIRES_SHARE_ALIKE" = 1024,
            /**
             * source code (the preferred
             *     form for making modifications) must be provided when exercising some
             *     rights granted by the license
             */
            "REQUIRES_SOURCE_CODE" = 2048,
            /**
             * derivative and combined works
             *     must be licensed under specified terms, similar to those of the original
             *     work
             */
            "REQUIRES_COPYLEFT" = 4096,
            /**
             * derivative works must be
             *     licensed under specified terms, with at least the same conditions as
             *     the original work; combinations with the work may be licensed under
             *     different terms
             */
            "REQUIRES_LESSER_COPYLEFT" = 8192,
            /**
             * exercising rights for
             *     commercial purposes is prohibited
             */
            "PROHIBITS_COMMERCIAL_USE" = 65536,
            /**
             * use in a
             *     non-developing country is prohibited
             */
            "PROHIBITS_HIGH_INCOME_NATION_USE" = 131072,
            /**
             * this license was created
             *     by the Creative Commons project
             */
            "CREATIVE_COMMONS_LICENSE" = 16777216,
            /**
             * this license was
             *     created by the Free Software Foundation (FSF)
             */
            "FREE_SOFTWARE_FOUNDATION_LICENSE" = 33554432,
        }
    }

    export default GstTag
}