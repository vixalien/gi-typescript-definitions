
/// <reference path="./GLib-2.0.d.ts" />
/// <reference path="./GModule-2.0.d.ts" />
/// <reference path="./GObject-2.0.d.ts" />
/// <reference path="./Gst-1.0.d.ts" />

/**
 * Type Definitions for GJS (https://gjs.guide/), generated by [GirGen](https://github.com/aylur/girgen)
 * If you found a bug, create a bug report on [GirGen's Repository](https://github.com/aylur/girgen/issues/new)
 */
declare module "gi://GstAllocators?version=1.0" {
    import type GLib from "gi://GLib?version=2.0"
    import type GModule from "gi://GModule?version=2.0"
    import type GObject from "gi://GObject?version=2.0"
    import type Gst from "gi://Gst?version=1.0"

    


    namespace GstAllocators {
        const __name__: "GstAllocators"
        const __version: "1.0"
        

        namespace PhysMemoryAllocator {
            interface SignalSignatures extends Gst.Allocator.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Allocator.ReadableProperties {
            }

            interface WritableProperties extends Gst.Allocator.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.Allocator.ConstructOnlyProperties {
            }

            interface Interface extends Gst.Allocator {
                /**
                 * Implementations shall return the physicall memory address
                 *    that is backing the provided memory, or 0 if none.
                 * @param mem
                 */
                vfunc_get_phys_addr(mem: Gst.Memory): never
            }
        }

        /**
         * @since 1.14
         */
        interface PhysMemoryAllocator extends Gst.Allocator, PhysMemoryAllocator.Interface {
            readonly $signals: PhysMemoryAllocator.SignalSignatures
            readonly $readableProperties: PhysMemoryAllocator.ReadableProperties
            readonly $writableProperties: PhysMemoryAllocator.WritableProperties
            readonly $constructOnlyProperties: PhysMemoryAllocator.ConstructOnlyProperties
        }


        interface PhysMemoryAllocatorInterface {
            readonly $gtype: GObject.GType<PhysMemoryAllocator>
            readonly prototype: PhysMemoryAllocator

            [Symbol.hasInstance](instance: unknown): instance is PhysMemoryAllocator
        }

        const PhysMemoryAllocator: PhysMemoryAllocatorInterface
        

        namespace DRMDumbAllocator {
            interface SignalSignatures extends Gst.Allocator.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Allocator.ReadableProperties {
                "drm-device-path": string
                "drm-fd": number
            }

            interface WritableProperties extends Gst.Allocator.WritableProperties {
                "drm-device-path": string
                "drm-fd": number
            }

            interface ConstructOnlyProperties extends Gst.Allocator.ConstructOnlyProperties {
            }
        }

        /**
         * Private intance object for #GstDRMDumbAllocator.
         * @since 1.24
         */
        interface DRMDumbAllocator extends Gst.Allocator {
            readonly $signals: DRMDumbAllocator.SignalSignatures
            readonly $readableProperties: DRMDumbAllocator.ReadableProperties
            readonly $writableProperties: DRMDumbAllocator.WritableProperties
            readonly $constructOnlyProperties: DRMDumbAllocator.ConstructOnlyProperties
            /**
             * @since 1.24
             * @default NULL
             */
            get drmDevicePath(): string
            set drmDevicePath(value: string)
            /**
             * @since 1.24
             * @default -1
             */
            get drmFd(): number
            set drmFd(value: number)
            /**
             * Allocated a DRM buffer object for the specific @drm_fourcc, @width and
             * @height. Note that the DRM Dumb allocation interface is agnostic to the
             * pixel format. This @drm_fourcc is converted into a bpp (bit-per-pixel)
             * number and the height is scaled according to the sub-sampling.
             * @since 1.24
             * @param drm_fourcc the DRM format to allocate for
             * @param width padded width for this allocation
             * @param height padded height for this allocation
             * @returns a new DRM Dumb #GstMemory. Use gst_memory_unref()   to release the memory after usage., the pitch as returned by the driver
             */
            alloc(drm_fourcc: number, width: number, height: number): [Gst.Memory, number]
            /**
             * This function allow verifying if the driver support dma-buf exportation.
             * @since 1.24
             * @returns %TRUE if the allocator support exporting dma-buf.
             */
            has_prime_export(): boolean
        }

        interface DRMDumbAllocatorClass extends Omit<Gst.AllocatorClass, "new"> {
            readonly $gtype: GObject.GType<DRMDumbAllocator>
            readonly prototype: DRMDumbAllocator
            new (props?: Partial<GObject.ConstructorProps<DRMDumbAllocator>>): DRMDumbAllocator
            /**
             * Creates a new #GstDRMDumbAllocator for the specific device path. This
             * function can fail if the path does not exist, is not a DRM device or if
             * the DRM device doesnot support DUMB allocation.
             * @since 1.24
             * @param drm_device_path path to the DRM device to open
             * @returns a new DRM Dumb allocator. Use gst_object_unref()   to release the allocator after usage.
             */
            new_with_device_path(drm_device_path: string): DRMDumbAllocator | null
            /**
             * Creates a new #GstDRMDumbAllocator for the specific file desciptor. This
             * function can fail if the file descriptor is not a DRM device or if
             * the DRM device does not support DUMB allocation.
             * @since 1.24
             * @param drm_fd file descriptor of the DRM device
             * @returns a new DRM Dumb allocator. Use gst_object_unref()   to release the allocator after usage.
             */
            new_with_fd(drm_fd: number): DRMDumbAllocator | null
        }

        const DRMDumbAllocator: DRMDumbAllocatorClass
        

        namespace DmaBufAllocator {
            interface SignalSignatures extends FdAllocator.SignalSignatures {
            }

            interface ReadableProperties extends FdAllocator.ReadableProperties {
            }

            interface WritableProperties extends FdAllocator.WritableProperties {
            }

            interface ConstructOnlyProperties extends FdAllocator.ConstructOnlyProperties {
            }
        }

        /**
         * Base class for allocators with dmabuf-backed memory
         * @since 1.12
         */
        interface DmaBufAllocator extends FdAllocator {
            readonly $signals: DmaBufAllocator.SignalSignatures
            readonly $readableProperties: DmaBufAllocator.ReadableProperties
            readonly $writableProperties: DmaBufAllocator.WritableProperties
            readonly $constructOnlyProperties: DmaBufAllocator.ConstructOnlyProperties
        }

        interface DmaBufAllocatorClass extends Omit<FdAllocatorClass, "new"> {
            readonly $gtype: GObject.GType<DmaBufAllocator>
            readonly prototype: DmaBufAllocator
            new (props?: Partial<GObject.ConstructorProps<DmaBufAllocator>>): DmaBufAllocator
            /**
             * Return a new dmabuf allocator.
             * @since 1.2
             * @returns a new dmabuf allocator. Use gst_object_unref() to release the allocator after usage
             */
            "new"(): DmaBufAllocator
            /**
             * Return a %GstMemory that wraps a dmabuf file descriptor.
             * @since 1.2
             * @param allocator allocator to be used for this memory
             * @param fd dmabuf file descriptor
             * @param size memory size
             * @returns a GstMemory based on `allocator`. When the buffer will be released dmabuf allocator will close the `fd`. The memory is only mmapped on gst_buffer_map() request.
             */
            alloc(allocator: Gst.Allocator, fd: number, size: number): Gst.Memory | null
            /**
             * Return a %GstMemory that wraps a dmabuf file descriptor.
             * @since 1.16
             * @param allocator allocator to be used for this memory
             * @param fd dmabuf file descriptor
             * @param size memory size
             * @param flags extra #GstFdMemoryFlags
             * @returns a GstMemory based on `allocator`.  When the buffer will be released the allocator will close the `fd` unless the %GST_FD_MEMORY_FLAG_DONT_CLOSE flag is specified. The memory is only mmapped on gst_buffer_mmap() request.
             */
            alloc_with_flags(allocator: Gst.Allocator, fd: number, size: number, flags: FdMemoryFlags): Gst.Memory | null
        }

        const DmaBufAllocator: DmaBufAllocatorClass
        

        namespace FdAllocator {
            interface SignalSignatures extends Gst.Allocator.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Allocator.ReadableProperties {
            }

            interface WritableProperties extends Gst.Allocator.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.Allocator.ConstructOnlyProperties {
            }
        }

        /**
         * Base class for allocators with fd-backed memory
         * @since 1.6
         */
        interface FdAllocator extends Gst.Allocator {
            readonly $signals: FdAllocator.SignalSignatures
            readonly $readableProperties: FdAllocator.ReadableProperties
            readonly $writableProperties: FdAllocator.WritableProperties
            readonly $constructOnlyProperties: FdAllocator.ConstructOnlyProperties
        }

        interface FdAllocatorClass extends Omit<Gst.AllocatorClass, "new"> {
            readonly $gtype: GObject.GType<FdAllocator>
            readonly prototype: FdAllocator
            new (props?: Partial<GObject.ConstructorProps<FdAllocator>>): FdAllocator
            /**
             * Return a new fd allocator.
             * @since 1.6
             * @returns a new fd allocator. Use gst_object_unref() to release the allocator after usage
             */
            "new"(): FdAllocator
            /**
             * Return a %GstMemory that wraps a generic file descriptor.
             * @since 1.6
             * @param allocator allocator to be used for this memory
             * @param fd file descriptor
             * @param size memory size
             * @param flags extra #GstFdMemoryFlags
             * @returns a GstMemory based on `allocator`. When the buffer will be released the allocator will close the `fd` unless the %GST_FD_MEMORY_FLAG_DONT_CLOSE flag is specified. The memory is only mmapped on gst_buffer_map() request.
             */
            alloc(allocator: Gst.Allocator, fd: number, size: number, flags: FdMemoryFlags): Gst.Memory | null
        }

        const FdAllocator: FdAllocatorClass
        

        namespace ShmAllocator {
            interface SignalSignatures extends FdAllocator.SignalSignatures {
            }

            interface ReadableProperties extends FdAllocator.ReadableProperties {
            }

            interface WritableProperties extends FdAllocator.WritableProperties {
            }

            interface ConstructOnlyProperties extends FdAllocator.ConstructOnlyProperties {
            }
        }

        /**
         * This is a subclass of #GstFdAllocator that implements the
         * gst_allocator_alloc() method using `memfd_create()` when available, POSIX
         * `shm_open()` otherwise. Platforms not supporting any of those (Windows) will
         * always return %NULL.
         *
         * Note that allocating new shared memories has a significant performance cost,
         * it is thus recommended to keep a pool of pre-allocated #GstMemory, using
         * #GstBufferPool. For that reason, this allocator has the
         * %GST_ALLOCATOR_FLAG_NO_COPY flag set.
         * @since 1.24
         */
        interface ShmAllocator extends FdAllocator {
            readonly $signals: ShmAllocator.SignalSignatures
            readonly $readableProperties: ShmAllocator.ReadableProperties
            readonly $writableProperties: ShmAllocator.WritableProperties
            readonly $constructOnlyProperties: ShmAllocator.ConstructOnlyProperties
        }

        interface ShmAllocatorClass extends Omit<FdAllocatorClass, "new"> {
            readonly $gtype: GObject.GType<ShmAllocator>
            readonly prototype: ShmAllocator
            new (props?: Partial<GObject.ConstructorProps<ShmAllocator>>): ShmAllocator
            /**
             * Get the #GstShmAllocator singleton previously registered with
             * gst_shm_allocator_init_once().
             * @since 1.24
             * @returns a #GstAllocator or %NULL if gst_shm_allocator_init_once() has not been previously called.
             */
            get(): Gst.Allocator | null
            /**
             * Register a #GstShmAllocator using gst_allocator_register() with the name
             * %GST_ALLOCATOR_SHM. This is no-op after the first call.
             * @since 1.24
             */
            init_once(): void
        }

        const ShmAllocator: ShmAllocatorClass
        none
        none
        none
        none
        none
        /**
         * Return the file descriptor associated with @mem.
         * @since 1.2
         * @param mem the memory to get the file descriptor
         * @returns the file descriptor associated with the memory, or -1.  The file     descriptor is still owned by the GstMemory.  Use dup to take a copy     if you intend to use it beyond the lifetime of this GstMemory.
         */
        function dmabuf_memory_get_fd(mem: Gst.Memory): number
        /**
         * Exports a DMABuf from the DRM Bumb buffer object. One can check if this
         * feature is supported using gst_drm_dumb_allocator_has_prime_export();
         * @since 1.24
         * @param mem the memory to export from
         * @returns a #GstMemory from #GstDmaBufAllocator wrapping the exported dma-buf    file descriptor.
         */
        function drm_dumb_memory_export_dmabuf(mem: Gst.Memory): Gst.Memory
        /**
         * Return the DRM buffer object handle associated with @mem.
         * @since 1.24
         * @param mem the memory to get the handle from
         * @returns the DRM buffer object handle associated with the memory, or 0.     The handle is still owned by the GstMemory and cannot be used     beyond the lifetime of this GstMemory unless it is being passed     to DRM driver, which does handle a refcount internally.
         */
        function drm_dumb_memory_get_handle(mem: Gst.Memory): number
        /**
         * Get the fd from @mem. Call gst_is_fd_memory() to check if @mem has
         * an fd.
         * @since 1.6
         * @param mem #GstMemory
         * @returns the fd of `mem` or -1 when there is no fd on `mem`
         */
        function fd_memory_get_fd(mem: Gst.Memory): number
        /**
         * Check if @mem is dmabuf memory.
         * @since 1.2
         * @param mem the memory to be check
         * @returns %TRUE if `mem` is dmabuf memory, otherwise %FALSE
         */
        function is_dmabuf_memory(mem: Gst.Memory): boolean
        /**
         * @since 1.24
         * @param mem the memory to be checked
         * @returns %TRUE if `mem` is DRM Dumb memory, otherwise %FALSE
         */
        function is_drm_dumb_memory(mem: Gst.Memory): boolean
        /**
         * Check if @mem is memory backed by an fd
         * @since 1.6
         * @param mem #GstMemory
         * @returns %TRUE when `mem` has an fd that can be retrieved with gst_fd_memory_get_fd().
         */
        function is_fd_memory(mem: Gst.Memory): boolean
        /**
         * @since 1.14
         * @param mem a #GstMemory
         * @returns whether the memory at `mem` is backed by physical memory
         */
        function is_phys_memory(mem: Gst.Memory): boolean
        /**
         * @since 1.14
         * @param mem a #GstMemory
         * @returns Physical memory address that is backing `mem`, or 0 if none
         */
        function phys_memory_get_phys_addr(mem: Gst.Memory): never
        const ALLOCATOR_DMABUF: "dmabuf"
        const ALLOCATOR_FD: "fd"
        const ALLOCATOR_SHM: "shm"
        const CAPS_FEATURE_MEMORY_DMABUF: "memory:DMABuf"
        
        namespace FdMemoryFlags {
            const $gtype: GObject.GType<FdMemoryFlags>
        }

        /**
         * Various flags to control the operation of the fd backed memory.
         * @since 1.6
         */
        enum FdMemoryFlags {
            /**
             * no flag
             */
            "NONE" = 0,
            /**
             * once the memory is mapped,
             *        keep it mapped until the memory is destroyed.
             */
            "KEEP_MAPPED" = 1,
            /**
             * do a private mapping instead of
             *        the default shared mapping.
             */
            "MAP_PRIVATE" = 2,
            /**
             * don't close the file descriptor when
             *        the memory is freed. Since: 1.10
             */
            "DONT_CLOSE" = 4,
        }
    }

    export default GstAllocators
}