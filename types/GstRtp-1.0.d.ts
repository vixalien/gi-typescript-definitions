
/// <reference path="./GLib-2.0.d.ts" />
/// <reference path="./GModule-2.0.d.ts" />
/// <reference path="./GObject-2.0.d.ts" />
/// <reference path="./Gst-1.0.d.ts" />
/// <reference path="./GstBase-1.0.d.ts" />

/**
 * Type Definitions for GJS (https://gjs.guide/), generated by [GirGen](https://github.com/aylur/girgen)
 * If you found a bug, create a bug report on [GirGen's Repository](https://github.com/aylur/girgen/issues/new)
 */
declare module "gi://GstRtp?version=1.0" {
    import type GLib from "gi://GLib?version=2.0"
    import type GModule from "gi://GModule?version=2.0"
    import type GObject from "gi://GObject?version=2.0"
    import type Gst from "gi://Gst?version=1.0"
    import type GstBase from "gi://GstBase?version=1.0"

    


    namespace GstRtp {
        const __name__: "GstRtp"
        const __version: "1.0"
        

        namespace RTPBaseAudioPayload {
            interface SignalSignatures extends RTPBasePayload.SignalSignatures {
            }

            interface ReadableProperties extends RTPBasePayload.ReadableProperties {
                "buffer-list": boolean
            }

            interface WritableProperties extends RTPBasePayload.WritableProperties {
                "buffer-list": boolean
            }

            interface ConstructOnlyProperties extends RTPBasePayload.ConstructOnlyProperties {
            }
        }

        /**
         * Provides a base class for audio RTP payloaders for frame or sample based
         * audio codecs (constant bitrate)
         *
         * This class derives from GstRTPBasePayload. It can be used for payloading
         * audio codecs. It will only work with constant bitrate codecs. It supports
         * both frame based and sample based codecs. It takes care of packing up the
         * audio data into RTP packets and filling up the headers accordingly. The
         * payloading is done based on the maximum MTU (mtu) and the maximum time per
         * packet (max-ptime). The general idea is to divide large data buffers into
         * smaller RTP packets. The RTP packet size is the minimum of either the MTU,
         * max-ptime (if set) or available data. The RTP packet size is always larger or
         * equal to min-ptime (if set). If min-ptime is not set, any residual data is
         * sent in a last RTP packet. In the case of frame based codecs, the resulting
         * RTP packets always contain full frames.
         *
         * ## Usage
         *
         * To use this base class, your child element needs to call either
         * gst_rtp_base_audio_payload_set_frame_based() or
         * gst_rtp_base_audio_payload_set_sample_based(). This is usually done in the
         * element's `_init()` function. Then, the child element must call either
         * gst_rtp_base_audio_payload_set_frame_options(),
         * gst_rtp_base_audio_payload_set_sample_options() or
         * gst_rtp_base_audio_payload_set_samplebits_options. Since
         * GstRTPBaseAudioPayload derives from GstRTPBasePayload, the child element
         * must set any variables or call/override any functions required by that base
         * class. The child element does not need to override any other functions
         * specific to GstRTPBaseAudioPayload.
         */
        interface RTPBaseAudioPayload extends RTPBasePayload {
            readonly $signals: RTPBaseAudioPayload.SignalSignatures
            readonly $readableProperties: RTPBaseAudioPayload.ReadableProperties
            readonly $writableProperties: RTPBaseAudioPayload.WritableProperties
            readonly $constructOnlyProperties: RTPBaseAudioPayload.ConstructOnlyProperties
            /**
             * @default FALSE
             */
            get bufferList(): boolean
            set bufferList(value: boolean)
            /**
             * Create an RTP buffer and store @payload_len bytes of the adapter as the
             * payload. Set the timestamp on the new buffer to @timestamp before pushing
             * the buffer downstream.
             *
             * If @payload_len is -1, all pending bytes will be flushed. If @timestamp is
             * -1, the timestamp will be calculated automatically.
             * @param payload_len length of payload
             * @param timestamp a #GstClockTime
             * @returns a #GstFlowReturn
             */
            flush(payload_len: number, timestamp: Gst.ClockTime): Gst.FlowReturn
            /**
             * Gets the internal adapter used by the depayloader.
             * @returns a #GstAdapter.
             */
            get_adapter(): GstBase.Adapter
            /**
             * Create an RTP buffer and store @payload_len bytes of @data as the
             * payload. Set the timestamp on the new buffer to @timestamp before pushing
             * the buffer downstream.
             * @param data data to set as payload
             * @param timestamp a #GstClockTime
             * @returns a #GstFlowReturn
             */
            push(data: Uint8Array, timestamp: Gst.ClockTime): Gst.FlowReturn
            /**
             * Tells #GstRTPBaseAudioPayload that the child element is for a frame based
             * audio codec
             */
            set_frame_based(): void
            /**
             * Sets the options for frame based audio codecs.
             * @param frame_duration The duraction of an audio frame in milliseconds.
             * @param frame_size The size of an audio frame in bytes.
             */
            set_frame_options(frame_duration: number, frame_size: number): void
            /**
             * Tells #GstRTPBaseAudioPayload that the child element is for a sample based
             * audio codec
             */
            set_sample_based(): void
            /**
             * Sets the options for sample based audio codecs.
             * @param sample_size Size per sample in bytes.
             */
            set_sample_options(sample_size: number): void
            /**
             * Sets the options for sample based audio codecs.
             * @param sample_size Size per sample in bits.
             */
            set_samplebits_options(sample_size: number): void
        }

        interface RTPBaseAudioPayloadClass extends Omit<RTPBasePayloadClass, "new"> {
            readonly $gtype: GObject.GType<RTPBaseAudioPayload>
            readonly prototype: RTPBaseAudioPayload
            new (props?: Partial<GObject.ConstructorProps<RTPBaseAudioPayload>>): RTPBaseAudioPayload
        }

        const RTPBaseAudioPayload: RTPBaseAudioPayloadClass
        

        namespace RTPBaseDepayload {
            interface SignalSignatures extends Gst.Element.SignalSignatures {
                /**
                 * Add @ext as an extension for reading part of an RTP header extension from
                 * incoming RTP packets.
                 * @since 1.20
                 * @param ext the #GstRTPHeaderExtension
                 */
                "add-extension"(ext: RTPHeaderExtension): void
                /**
                 * Clear all RTP header extensions used by this depayloader.
                 * @since 1.20
                 */
                "clear-extensions"(): void
                /**
                 * The returned @ext must be configured with the correct @ext_id and with the
                 * necessary attributes as required by the extension implementation.
                 * @since 1.20
                 * @param ext_id the extension id being requested
                 * @param ext_uri the extension URI being requested
                 * @returns the #GstRTPHeaderExtension for `ext_id`, or %NULL
                 */
                "request-extension"(ext_id: number, ext_uri: string | null): RTPHeaderExtension | null
            }

            interface ReadableProperties extends Gst.Element.ReadableProperties {
                "auto-header-extension": boolean
                "extensions": Gst.ValueArray
                "max-reorder": number
                "source-info": boolean
                "stats": Gst.Structure
            }

            interface WritableProperties extends Gst.Element.WritableProperties {
                "auto-header-extension": boolean
                "extensions": Gst.ValueArray
                "max-reorder": number
                "source-info": boolean
                "stats": Gst.Structure
            }

            interface ConstructOnlyProperties extends Gst.Element.ConstructOnlyProperties {
            }
        }

        /**
         * Provides a base class for RTP depayloaders
         *
         * In order to handle RTP header extensions correctly if the
         * depayloader aggregates multiple RTP packet payloads into one output
         * buffer this class provides the function
         * gst_rtp_base_depayload_set_aggregate_hdrext_enabled(). If the
         * aggregation is enabled the virtual functions
         * @GstRTPBaseDepayload.process or
         * @GstRTPBaseDepayload.process_rtp_packet must tell the base class
         * what happens to the current RTP packet. By default the base class
         * assumes that the packet payload is used with the next output
         * buffer.
         *
         * If the RTP packet will not be used with an output buffer
         * gst_rtp_base_depayload_dropped() must be called. A typical
         * situation would be if we are waiting for a keyframe.
         *
         * If the RTP packet will be used but not with the current output
         * buffer but with the next one gst_rtp_base_depayload_delayed() must
         * be called. This may happen if the current RTP packet signals the
         * start of a new output buffer and the currently processed output
         * buffer will be pushed first. The undelay happens implicitly once
         * the current buffer has been pushed or
         * gst_rtp_base_depayload_flush() has been called.
         *
         * If gst_rtp_base_depayload_flush() is called all RTP packets that
         * have not been dropped since the last output buffer are dropped,
         * e.g. if an output buffer is discarded due to malformed data. This
         * may or may not include the current RTP packet depending on the 2nd
         * parameter @keep_current.
         *
         * Be aware that in case gst_rtp_base_depayload_push_list() is used
         * each buffer will see the same list of RTP header extensions.
         */
        interface RTPBaseDepayload extends Gst.Element {
            readonly $signals: RTPBaseDepayload.SignalSignatures
            readonly $readableProperties: RTPBaseDepayload.ReadableProperties
            readonly $writableProperties: RTPBaseDepayload.WritableProperties
            readonly $constructOnlyProperties: RTPBaseDepayload.ConstructOnlyProperties
            /**
             * If enabled, the depayloader will automatically try to enable all the
             * RTP header extensions provided in the sink caps, saving the application
             * the need to handle these extensions manually using the
             * GstRTPBaseDepayload::request-extension: signal.
             * @since 1.20
             * @default TRUE
             */
            get autoHeaderExtension(): boolean
            set autoHeaderExtension(value: boolean)
            /**
             * A list of already enabled RTP header extensions. This may be useful for finding
             * out which extensions are already enabled (with add-extension signal) and picking a non-conflicting
             * ID for a new extension that needs to be added on top of the existing ones.
             *
             * Note that the value returned by reading this property is not dynamically updated when the set of
             * enabled extensions changes by any of existing action signals. Rather, it represents the current state
             * at the time the property is read.
             *
             * Dynamic updates of this property can be received by subscribing to its corresponding "notify" signal, i.e.
             * "notify::extensions".
             * @since 1.24
             * @default <  >
             */
            get extensions(): Gst.ValueArray
            set extensions(value: Gst.ValueArray)
            /**
             * Max seqnum reorder before the sender is assumed to have restarted.
             *
             * When max-reorder is set to 0 all reordered/duplicate packets are
             * considered coming from a restarted sender.
             * @since 1.18
             * @default 100
             */
            get maxReorder(): number
            set maxReorder(value: number)
            /**
             * Add RTP source information found in RTP header as meta to output buffer.
             * @since 1.16
             * @default FALSE
             */
            get sourceInfo(): boolean
            set sourceInfo(value: boolean)
            /**
             * Various depayloader statistics retrieved atomically (and are therefore
             * synchroized with each other). This property return a GstStructure named
             * application/x-rtp-depayload-stats containing the following fields relating to
             * the last processed buffer and current state of the stream being depayloaded:
             *
             *   * `clock-rate`: #G_TYPE_UINT, clock-rate of the stream
             *   * `npt-start`: #G_TYPE_UINT64, time of playback start
             *   * `npt-stop`: #G_TYPE_UINT64, time of playback stop
             *   * `play-speed`: #G_TYPE_DOUBLE, the playback speed
             *   * `play-scale`: #G_TYPE_DOUBLE, the playback scale
             *   * `running-time-dts`: #G_TYPE_UINT64, the last running-time of the
             *      last DTS
             *   * `running-time-pts`: #G_TYPE_UINT64, the last running-time of the
             *      last PTS
             *   * `seqnum`: #G_TYPE_UINT, the last seen seqnum
             *   * `timestamp`: #G_TYPE_UINT, the last seen RTP timestamp
             */
            get stats(): Gst.Structure
            set stats(value: Gst.Structure)
            /**
             * Called from @GstRTPBaseDepayload.process or
             * @GstRTPBaseDepayload.process_rtp_packet when the depayloader needs
             * to keep the current input RTP header for use with the next output
             * buffer.
             *
             * The delayed buffer will remain until the end of processing the
             * current output buffer and then enqueued for processing with the
             * next output buffer.
             *
             * A typical use-case is when the depayloader implementation will
             * start a new output buffer for the current input RTP buffer but push
             * the current output buffer first.
             *
             * Must be called with the stream lock held.
             * @since 1.24
             */
            delayed(): void
            /**
             * Called from @GstRTPBaseDepayload.process or
             * @GstRTPBaseDepayload.process_rtp_packet if the depayloader does not
             * use the current buffer for the output buffer. This will either drop
             * the delayed buffer or the last buffer from the header extension
             * cache.
             *
             * A typical use-case is when the depayloader implementation is
             * dropping an input RTP buffer while waiting for the first keyframe.
             *
             * Must be called with the stream lock held.
             * @since 1.24
             */
            dropped(): void
            /**
             * If @GstRTPBaseDepayload.process or
             * @GstRTPBaseDepayload.process_rtp_packet drop an output buffer this
             * function tells the base class to flush header extension cache as
             * well.
             *
             * This will not drop an input RTP header marked as delayed from
             * gst_rtp_base_depayload_delayed().
             *
             * If @keep_current is %TRUE the current input RTP header will be kept
             * and enqueued after flushing the previous input RTP headers.
             *
             * A typical use-case for @keep_current is when the depayloader
             * implementation invalidates the current output buffer and starts a
             * new one with the current RTP input buffer.
             *
             * Must be called with the stream lock held.
             * @since 1.24
             * @param keep_current if the current RTP buffer shall be kept
             */
            flush(keep_current: boolean): void
            /**
             * Queries whether header extensions will be aggregated per depayloaded buffers.
             * @since 1.24
             * @returns %TRUE if aggregate-header-extension is enabled.
             */
            is_aggregate_hdrext_enabled(): boolean
            /**
             * Queries whether #GstRTPSourceMeta will be added to depayloaded buffers.
             * @since 1.16
             * @returns %TRUE if source-info is enabled.
             */
            is_source_info_enabled(): boolean
            /**
             * Push @out_buf to the peer of @filter. This function takes ownership of
             * @out_buf.
             *
             * This function will by default apply the last incoming timestamp on
             * the outgoing buffer when it didn't have a timestamp already.
             * @param out_buf a #GstBuffer
             * @returns a #GstFlowReturn.
             */
            push(out_buf: Gst.Buffer): Gst.FlowReturn
            /**
             * Push @out_list to the peer of @filter. This function takes ownership of
             * @out_list.
             * @param out_list a #GstBufferList
             * @returns a #GstFlowReturn.
             */
            push_list(out_list: Gst.BufferList): Gst.FlowReturn
            /**
             * Enable or disable aggregating header extensions.
             * @since 1.24
             * @param enable whether to aggregate header extensions per output buffer
             */
            set_aggregate_hdrext_enabled(enable: boolean): void
            /**
             * Enable or disable adding #GstRTPSourceMeta to depayloaded buffers.
             * @since 1.16
             * @param enable whether to add meta about RTP sources to buffer
             */
            set_source_info_enabled(enable: boolean): void
            /**
             * custom event handling
             * @param event
             */
            vfunc_handle_event(event: Gst.Event): boolean
            /**
             * signal the depayloader about packet loss
             * @param event
             */
            vfunc_packet_lost(event: Gst.Event): boolean
            /**
             * process incoming rtp packets. Subclass must implement either
             *   this method or @process_rtp_packet to process incoming rtp packets.
             *   If the child returns a buffer without a valid timestamp, the timestamp
             *   of the provided buffer will be applied to the result buffer and the
             *   buffer will be pushed. If this function returns %NULL, nothing is pushed.
             * @param in
             */
            vfunc_process(in_: Gst.Buffer): Gst.Buffer
            /**
             * Same as the process virtual function, but slightly more
             * efficient, since it is passed the rtp buffer structure that has already
             * been mapped (with GST_MAP_READ) by the base class and thus does not have
             * to be mapped again by the subclass. Can be used by the subclass to process
             * incoming rtp packets. If the subclass returns a buffer without a valid
             * timestamp, the timestamp of the input buffer will be applied to the result
             * buffer and the output buffer will be pushed out. If this function returns
             * %NULL, nothing is pushed out. Since: 1.6.
             * @param rtp_buffer
             */
            vfunc_process_rtp_packet(rtp_buffer: RTPBuffer): Gst.Buffer
            /**
             * configure the depayloader
             * @param caps
             */
            vfunc_set_caps(caps: Gst.Caps): boolean
        }

        interface RTPBaseDepayloadClass extends Omit<Gst.ElementClass, "new"> {
            readonly $gtype: GObject.GType<RTPBaseDepayload>
            readonly prototype: RTPBaseDepayload
            new (props?: Partial<GObject.ConstructorProps<RTPBaseDepayload>>): RTPBaseDepayload
        }

        const RTPBaseDepayload: RTPBaseDepayloadClass
        

        namespace RTPBasePayload {
            interface SignalSignatures extends Gst.Element.SignalSignatures {
                /**
                 * Add @ext as an extension for writing part of an RTP header extension onto
                 * outgoing RTP packets.
                 * @since 1.20
                 * @param ext the #GstRTPHeaderExtension
                 */
                "add-extension"(ext: RTPHeaderExtension): void
                /**
                 * Clear all RTP header extensions used by this payloader.
                 * @since 1.20
                 */
                "clear-extensions"(): void
                /**
                 * The returned @ext must be configured with the correct @ext_id and with the
                 * necessary attributes as required by the extension implementation.
                 * @since 1.20
                 * @param ext_id the extension id being requested
                 * @param ext_uri the extension URI being requested
                 * @returns the #GstRTPHeaderExtension for `ext_id`, or %NULL
                 */
                "request-extension"(ext_id: number, ext_uri: string): RTPHeaderExtension | null
            }

            interface ReadableProperties extends Gst.Element.ReadableProperties {
                "auto-header-extension": boolean
                "extensions": Gst.ValueArray
                "max-ptime": number
                "min-ptime": number
                "mtu": number
                "onvif-no-rate-control": boolean
                "perfect-rtptime": boolean
                "pt": number
                "ptime-multiple": number
                "scale-rtptime": boolean
                "seqnum": number
                "seqnum-offset": number
                "source-info": boolean
                "ssrc": number
                "stats": Gst.Structure
                "timestamp": number
                "timestamp-offset": number
            }

            interface WritableProperties extends Gst.Element.WritableProperties {
                "auto-header-extension": boolean
                "extensions": Gst.ValueArray
                "max-ptime": number
                "min-ptime": number
                "mtu": number
                "onvif-no-rate-control": boolean
                "perfect-rtptime": boolean
                "pt": number
                "ptime-multiple": number
                "scale-rtptime": boolean
                "seqnum": number
                "seqnum-offset": number
                "source-info": boolean
                "ssrc": number
                "stats": Gst.Structure
                "timestamp": number
                "timestamp-offset": number
            }

            interface ConstructOnlyProperties extends Gst.Element.ConstructOnlyProperties {
            }
        }

        /**
         * Provides a base class for RTP payloaders
         */
        interface RTPBasePayload extends Gst.Element {
            readonly $signals: RTPBasePayload.SignalSignatures
            readonly $readableProperties: RTPBasePayload.ReadableProperties
            readonly $writableProperties: RTPBasePayload.WritableProperties
            readonly $constructOnlyProperties: RTPBasePayload.ConstructOnlyProperties
            /**
             * If enabled, the payloader will automatically try to enable all the
             * RTP header extensions provided in the src caps, saving the application
             * the need to handle these extensions manually using the
             * GstRTPBasePayload::request-extension: signal.
             * @since 1.20
             * @default TRUE
             */
            get autoHeaderExtension(): boolean
            set autoHeaderExtension(value: boolean)
            /**
             * A list of already enabled RTP header extensions. This may be useful for finding
             * out which extensions are already enabled (with add-extension signal) and picking a non-conflicting
             * ID for a new extension that needs to be added on top of the existing ones.
             *
             * Note that the value returned by reading this property is not dynamically updated when the set of
             * enabled extensions changes by any of existing action signals. Rather, it represents the current state
             * at the time the property is read.
             *
             * Dynamic updates of this property can be received by subscribing to its corresponding "notify" signal, i.e.
             * "notify::extensions".
             * @since 1.24
             * @default <  >
             */
            get extensions(): Gst.ValueArray
            set extensions(value: Gst.ValueArray)
            /**
             * @default -1
             */
            get maxPtime(): number
            set maxPtime(value: number)
            /**
             * Minimum duration of the packet data in ns (can't go above MTU)
             * @default 0
             */
            get minPtime(): number
            set minPtime(value: number)
            /**
             * @default 1400
             */
            get mtu(): number
            set mtu(value: number)
            /**
             * Make the payloader timestamp packets according to the Rate-Control=no
             * behaviour specified in the ONVIF replay spec.
             * @since 1.16
             * @default FALSE
             */
            get onvifNoRateControl(): boolean
            set onvifNoRateControl(value: boolean)
            /**
             * Try to use the offset fields to generate perfect RTP timestamps. When this
             * option is disabled, RTP timestamps are generated from GST_BUFFER_PTS of
             * each payloaded buffer. The PTSes of buffers may not necessarily increment
             * with the amount of data in each input buffer, consider e.g. the case where
             * the buffer arrives from a network which means that the PTS is unrelated to
             * the amount of data. Because the RTP timestamps are generated from
             * GST_BUFFER_PTS this can result in RTP timestamps that also don't increment
             * with the amount of data in the payloaded packet. To circumvent this it is
             * possible to set the perfect rtptime option enabled. When this option is
             * enabled the payloader will increment the RTP timestamps based on
             * GST_BUFFER_OFFSET which relates to the amount of data in each packet
             * rather than the GST_BUFFER_PTS of each buffer and therefore the RTP
             * timestamps will more closely correlate with the amount of data in each
             * buffer. Currently GstRTPBasePayload is limited to handling perfect RTP
             * timestamps for audio streams.
             * @default TRUE
             */
            get perfectRtptime(): boolean
            set perfectRtptime(value: boolean)
            /**
             * @default 96
             */
            get pt(): number
            set pt(value: number)
            /**
             * Force buffers to be multiples of this duration in ns (0 disables)
             * @default 0
             */
            get ptimeMultiple(): number
            set ptimeMultiple(value: number)
            /**
             * Make the RTP packets' timestamps be scaled with the segment's rate
             * (corresponding to RTSP speed parameter). Disabling this property means
             * the timestamps will not be affected by the set delivery speed (RTSP speed).
             *
             * Example: A server wants to allow streaming a recorded video in double
             * speed but still have the timestamps correspond to the position in the
             * video. This is achieved by the client setting RTSP Speed to 2 while the
             * server has this property disabled.
             * @since 1.18
             * @default TRUE
             */
            get scaleRtptime(): boolean
            set scaleRtptime(value: boolean)
            /**
             * @default 0
             */
            get seqnum(): number
            set seqnum(value: number)
            /**
             * @default -1
             */
            get seqnumOffset(): number
            set seqnumOffset(value: number)
            /**
             * Enable writing the CSRC field in allocated RTP header based on RTP source
             * information found in the input buffer's #GstRTPSourceMeta.
             * @since 1.16
             * @default FALSE
             */
            get sourceInfo(): boolean
            set sourceInfo(value: boolean)
            /**
             * @default 4294967295
             */
            get ssrc(): number
            set ssrc(value: number)
            /**
             * Various payloader statistics retrieved atomically (and are therefore
             * synchroized with each other), these can be used e.g. to generate an
             * RTP-Info header. This property return a GstStructure named
             * application/x-rtp-payload-stats containing the following fields relating to
             * the last processed buffer and current state of the stream being payloaded:
             *
             *   * `clock-rate` :#G_TYPE_UINT, clock-rate of the stream
             *   * `running-time` :#G_TYPE_UINT64, running time
             *   * `seqnum` :#G_TYPE_UINT, sequence number, same as #GstRTPBasePayload:seqnum
             *   * `timestamp` :#G_TYPE_UINT, RTP timestamp, same as #GstRTPBasePayload:timestamp
             *   * `ssrc` :#G_TYPE_UINT, The SSRC in use
             *   * `pt` :#G_TYPE_UINT, The Payload type in use, same as #GstRTPBasePayload:pt
             *   * `seqnum-offset` :#G_TYPE_UINT, The current offset added to the seqnum
             *   * `timestamp-offset` :#G_TYPE_UINT, The current offset added to the timestamp
             */
            get stats(): Gst.Structure
            set stats(value: Gst.Structure)
            /**
             * @default 0
             */
            get timestamp(): number
            set timestamp(value: number)
            /**
             * @default 4294967295
             */
            get timestampOffset(): number
            set timestampOffset(value: number)
            /**
             * Allocate a new #GstBuffer with enough data to hold an RTP packet with
             * minimum @csrc_count CSRCs, a payload length of @payload_len and padding of
             * @pad_len. If @payload has #GstRTPBasePayload:source-info %TRUE additional
             * CSRCs may be allocated and filled with RTP source information.
             * @since 1.16
             * @param payload_len the length of the payload
             * @param pad_len the amount of padding
             * @param csrc_count the minimum number of CSRC entries
             * @returns A newly allocated buffer that can hold an RTP packet with given parameters.
             */
            allocate_output_buffer(payload_len: number, pad_len: number, csrc_count: number): Gst.Buffer
            /**
             * Count the total number of RTP sources found in the meta of @buffer, which
             * will be automically added by gst_rtp_base_payload_allocate_output_buffer().
             * If #GstRTPBasePayload:source-info is %FALSE the count will be 0.
             * @since 1.16
             * @param buffer a #GstBuffer, typically the buffer to payload
             * @returns The number of sources.
             */
            get_source_count(buffer: Gst.Buffer): number
            /**
             * Check if the packet with @size and @duration would exceed the configured
             * maximum size.
             * @param size the size of the packet
             * @param duration the duration of the packet
             * @returns %TRUE if the packet of `size` and `duration` would exceed the configured MTU or max_ptime.
             */
            is_filled(size: number, duration: Gst.ClockTime): boolean
            /**
             * Queries whether the payloader will add contributing sources (CSRCs) to the
             * RTP header from #GstRTPSourceMeta.
             * @since 1.16
             * @returns %TRUE if source-info is enabled.
             */
            is_source_info_enabled(): boolean
            /**
             * Push @buffer to the peer element of the payloader. The SSRC, payload type,
             * seqnum and timestamp of the RTP buffer will be updated first.
             *
             * This function takes ownership of @buffer.
             * @param buffer a #GstBuffer
             * @returns a #GstFlowReturn.
             */
            push(buffer: Gst.Buffer): Gst.FlowReturn
            /**
             * Push @list to the peer element of the payloader. The SSRC, payload type,
             * seqnum and timestamp of the RTP buffer will be updated first.
             *
             * This function takes ownership of @list.
             * @param list a #GstBufferList
             * @returns a #GstFlowReturn.
             */
            push_list(list: Gst.BufferList): Gst.FlowReturn
            /**
             * Set the rtp options of the payloader. These options will be set in the caps
             * of the payloader. Subclasses must call this method before calling
             * gst_rtp_base_payload_push() or gst_rtp_base_payload_set_outcaps().
             * @param media the media type (typically "audio" or "video")
             * @param dynamic if the payload type is dynamic
             * @param encoding_name the encoding name
             * @param clock_rate the clock rate of the media
             */
            set_options(media: string, dynamic: boolean, encoding_name: string, clock_rate: number): void
            /**
             * Configure the output caps with the optional fields.
             * @since 1.20
             * @param s a #GstStructure with the caps fields
             * @returns %TRUE if the caps could be set.
             */
            set_outcaps_structure(s: Gst.Structure | null): boolean
            /**
             * Enable or disable adding contributing sources to RTP packets from
             * #GstRTPSourceMeta.
             * @since 1.16
             * @param enable whether to add contributing sources to RTP packets
             */
            set_source_info_enabled(enable: boolean): void
            /**
             * get desired caps
             * @param pad
             * @param filter
             */
            vfunc_get_caps(pad: Gst.Pad, filter: Gst.Caps): Gst.Caps
            /**
             * process data
             * @param buffer
             */
            vfunc_handle_buffer(buffer: Gst.Buffer): Gst.FlowReturn
            /**
             * custom query handling
             * @param pad
             * @param query
             */
            vfunc_query(pad: Gst.Pad, query: Gst.Query): boolean
            /**
             * configure the payloader
             * @param caps
             */
            vfunc_set_caps(caps: Gst.Caps): boolean
            /**
             * custom event handling on the sinkpad
             * @param event
             */
            vfunc_sink_event(event: Gst.Event): boolean
            /**
             * custom event handling on the srcpad
             * @param event
             */
            vfunc_src_event(event: Gst.Event): boolean
        }

        interface RTPBasePayloadClass extends Omit<Gst.ElementClass, "new"> {
            readonly $gtype: GObject.GType<RTPBasePayload>
            readonly prototype: RTPBasePayload
            new (props?: Partial<GObject.ConstructorProps<RTPBasePayload>>): RTPBasePayload
        }

        const RTPBasePayload: RTPBasePayloadClass
        

        namespace RTPHeaderExtension {
            interface SignalSignatures extends Gst.Element.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Element.ReadableProperties {
            }

            interface WritableProperties extends Gst.Element.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.Element.ConstructOnlyProperties {
            }
        }

        /**
         * Instance struct for a RTP Audio/Video header extension.
         * @since 1.20
         */
        interface RTPHeaderExtension extends Gst.Element {
            readonly $signals: RTPHeaderExtension.SignalSignatures
            readonly $readableProperties: RTPHeaderExtension.ReadableProperties
            readonly $writableProperties: RTPHeaderExtension.WritableProperties
            readonly $constructOnlyProperties: RTPHeaderExtension.ConstructOnlyProperties
            /**
             * Retrieve the direction
             * @since 1.20
             * @returns The direction
             */
            get_direction(): RTPHeaderExtensionDirection
            /**
             * @since 1.20
             * @returns the RTP extension id configured on `ext`
             */
            get_id(): number
            /**
             * This is used to know how much data a certain header extension will need for
             * both allocating the resulting data, and deciding how much payload data can
             * be generated.
             *
             * Implementations should return as accurate a value as is possible using the
             * information given in the input @buffer.
             * @since 1.20
             * @param input_meta a #GstBuffer
             * @returns the maximum size of the data written by this extension
             */
            get_max_size(input_meta: Gst.Buffer): number
            /**
             * @since 1.20
             * @returns the #GstStructure field name used in SDP-like #GstCaps for this `ext` configuration
             */
            get_sdp_caps_field_name(): string
            /**
             * @since 1.20
             * @returns the flags supported by this instance of `ext`
             */
            get_supported_flags(): RTPHeaderExtensionFlags
            /**
             * @since 1.20
             * @returns the RTP extension URI for this object
             */
            get_uri(): string | null
            /**
             * Read the RTP header extension from @data.
             * @since 1.20
             * @param read_flags #GstRTPHeaderExtensionFlags for how the extension should
                          be written
             * @param data location to read the rtp header extension from
             * @param buffer a #GstBuffer to modify if necessary
             * @returns whether the extension could be read from `data`
             */
            read(read_flags: RTPHeaderExtensionFlags, data: Uint8Array, buffer: Gst.Buffer): boolean
            /**
             * gst_rtp_header_extension_set_id() must have been called with a valid
             * extension id that is contained in these caps.
             *
             * The only current known caps format is based on the SDP standard as produced
             * by gst_sdp_media_attributes_to_caps().
             * @since 1.20
             * @param caps the #GstCaps to configure this extension with
             * @returns whether the `caps` could be successfully set on `ext`.
             */
            set_attributes_from_caps(caps: Gst.Caps): boolean
            /**
             * gst_rtp_header_extension_set_id() must have been called with a valid
             * extension id that is contained in these caps.
             *
             * The only current known caps format is based on the SDP standard as produced
             * by gst_sdp_media_attributes_to_caps().
             * @since 1.20
             * @param caps writable #GstCaps to modify
             * @returns whether the configured attributes on `ext` can successfully be set on  `caps`
             */
            set_caps_from_attributes(caps: Gst.Caps): boolean
            /**
             * Helper implementation for GstRTPExtensionClass::set_caps_from_attributes
             * that sets the @ext uri on caps with the specified extension id as required
             * for sdp #GstCaps.
             *
             * Requires that the extension does not have any attributes or direction
             * advertised in @caps.
             * @since 1.20
             * @param caps #GstCaps to write fields into
             * @param attributes
             * @returns whether the `ext` attributes could be set on `caps`.
             */
            set_caps_from_attributes_helper(caps: Gst.Caps, attributes: string): boolean
            /**
             * Set the direction that this header extension should be used in.
             * If #GST_RTP_HEADER_EXTENSION_DIRECTION_INHERITED is included, the
             * direction will not be included in the caps (as it shouldn't be in the
             * extmap line in the SDP).
             * @since 1.20
             * @param direction The direction
             */
            set_direction(direction: RTPHeaderExtensionDirection): void
            /**
             * sets the RTP extension id on @ext
             * @since 1.20
             * @param ext_id The id of this extension
             */
            set_id(ext_id: number): void
            /**
             * Passes RTP payloader's sink (i.e. not payloaded) @caps to the header
             * extension.
             * @since 1.20
             * @param caps sink #GstCaps
             * @returns Whether `caps` could be read successfully
             */
            set_non_rtp_sink_caps(caps: Gst.Caps): boolean
            /**
             * Call this function in a subclass from #GstRTPHeaderExtensionClass::read to
             * tell the depayloader whether the data just parsed from RTP packet require
             * updating its src (non-RTP) caps. If @state is TRUE, #GstRTPBaseDepayload will
             * eventually invoke gst_rtp_header_extension_update_non_rtp_src_caps() to
             * have the caps update applied. Applying the update also flips the internal
             * "wants update" flag back to FALSE.
             * @since 1.20
             * @param state TRUE if caps update is needed
             */
            set_wants_update_non_rtp_src_caps(state: boolean): void
            /**
             * Updates depayloader src caps based on the information received in RTP header.
             * @caps must be writable as this function may modify them.
             * @since 1.20
             * @param caps src #GstCaps to modify
             * @returns whether `caps` were modified successfully
             */
            update_non_rtp_src_caps(caps: Gst.Caps): boolean
            /**
             * Call this function after gst_rtp_header_extension_read() to check if
             * the depayloader's src caps need updating with data received in the last RTP
             * packet.
             * @since 1.20
             * @returns Whether `ext` wants to update depayloader's src caps.
             */
            wants_update_non_rtp_src_caps(): boolean
            /**
             * Writes the RTP header extension to @data using information available from
             * the @input_meta.  @data will be sized to be at least the value returned
             * from gst_rtp_header_extension_get_max_size().
             * @since 1.20
             * @param input_meta the input #GstBuffer to read information from if necessary
             * @param write_flags #GstRTPHeaderExtensionFlags for how the extension should
                          be written
             * @param output output RTP #GstBuffer
             * @param data location to write the rtp header extension into
             * @returns  0 on failure
             */
            write(input_meta: Gst.Buffer, write_flags: RTPHeaderExtensionFlags, output: Gst.Buffer, data: Uint8Array): number
            /**
             * This is used to know how much data a certain header extension will need for
             * both allocating the resulting data, and deciding how much payload data can
             * be generated.
             *
             * Implementations should return as accurate a value as is possible using the
             * information given in the input @buffer.
             * @since 1.20
             * @param input_meta a #GstBuffer
             * @returns the maximum size of the data written by this extension
             */
            vfunc_get_max_size(input_meta: Gst.Buffer): number
            /**
             * retrieve the supported flags
             * @since 1.20
             * @returns the flags supported by this instance of `ext`
             */
            vfunc_get_supported_flags(): RTPHeaderExtensionFlags
            /**
             * Read the RTP header extension from @data.
             * @since 1.20
             * @param read_flags #GstRTPHeaderExtensionFlags for how the extension should
                          be written
             * @param data location to read the rtp header extension from
             * @param buffer a #GstBuffer to modify if necessary
             * @returns whether the extension could be read from `data`
             */
            vfunc_read(read_flags: RTPHeaderExtensionFlags, data: Uint8Array, buffer: Gst.Buffer): boolean
            /**
             * set the necessary attributes that may be signaled e.g. with
             *     an SDP.
             * @param direction
             * @param attributes
             */
            vfunc_set_attributes(direction: RTPHeaderExtensionDirection, attributes: string): boolean
            /**
             * gst_rtp_header_extension_set_id() must have been called with a valid
             * extension id that is contained in these caps.
             *
             * The only current known caps format is based on the SDP standard as produced
             * by gst_sdp_media_attributes_to_caps().
             * @since 1.20
             * @param caps writable #GstCaps to modify
             * @returns whether the configured attributes on `ext` can successfully be set on  `caps`
             */
            vfunc_set_caps_from_attributes(caps: Gst.Caps): boolean
            /**
             * Passes RTP payloader's sink (i.e. not payloaded) @caps to the header
             * extension.
             * @since 1.20
             * @param caps sink #GstCaps
             * @returns Whether `caps` could be read successfully
             */
            vfunc_set_non_rtp_sink_caps(caps: Gst.Caps): boolean
            /**
             * Updates depayloader src caps based on the information received in RTP header.
             * @caps must be writable as this function may modify them.
             * @since 1.20
             * @param caps src #GstCaps to modify
             * @returns whether `caps` were modified successfully
             */
            vfunc_update_non_rtp_src_caps(caps: Gst.Caps): boolean
            /**
             * Writes the RTP header extension to @data using information available from
             * the @input_meta.  @data will be sized to be at least the value returned
             * from gst_rtp_header_extension_get_max_size().
             * @since 1.20
             * @param input_meta the input #GstBuffer to read information from if necessary
             * @param write_flags #GstRTPHeaderExtensionFlags for how the extension should
                          be written
             * @param output output RTP #GstBuffer
             * @param data location to write the rtp header extension into
             * @returns  0 on failure
             */
            vfunc_write(input_meta: Gst.Buffer, write_flags: RTPHeaderExtensionFlags, output: Gst.Buffer, data: Uint8Array): number
        }

        interface RTPHeaderExtensionClass extends Omit<Gst.ElementClass, "new"> {
            readonly $gtype: GObject.GType<RTPHeaderExtension>
            readonly prototype: RTPHeaderExtension
            new (props?: Partial<GObject.ConstructorProps<RTPHeaderExtension>>): RTPHeaderExtension
            /**
             * @since 1.20
             * @param uri the rtp header extension URI to search for
             * @returns the #GstRTPHeaderExtension for `uri` or %NULL
             */
            create_from_uri(uri: string): RTPHeaderExtension | null
            /**
             * Set the URI for this RTP header extension implementation.
             * @since 1.20
             * @param uri the RTP Header extension uri for @klass
             */
            set_uri(uri: string): void
        }

        const RTPHeaderExtension: RTPHeaderExtensionClass
        /**
         * Note: The API in this module is not yet declared stable.
         *
         * The GstRTPCBuffer helper functions makes it easy to parse and create regular
         * #GstBuffer objects that contain compound RTCP packets. These buffers are typically
         * of 'application/x-rtcp' #GstCaps.
         *
         * An RTCP buffer consists of 1 or more #GstRTCPPacket structures that you can
         * retrieve with gst_rtcp_buffer_get_first_packet(). #GstRTCPPacket acts as a pointer
         * into the RTCP buffer; you can move to the next packet with
         * gst_rtcp_packet_move_to_next().
         */
        abstract class RTCPBuffer {
            static readonly $gtype: GObject.GType<RTCPBuffer>

            
            /**
             * Open @buffer for reading or writing, depending on @flags. The resulting RTCP
             * buffer state is stored in @rtcp.
             * @param buffer a buffer with an RTCP packet
             * @param flags flags for the mapping
             * @param rtcp resulting #GstRTCPBuffer
             */
            static map(buffer: Gst.Buffer, flags: Gst.MapFlags, rtcp: RTCPBuffer): boolean
            /**
             * Create a new buffer for constructing RTCP packets. The packet will have a
             * maximum size of @mtu.
             * @param mtu the maximum mtu size.
             * @returns A newly allocated buffer.
             */
            static "new"(mtu: number): Gst.Buffer
            /**
             * Create a new buffer and set the data to a copy of @len
             * bytes of @data and the size to @len. The data will be freed when the buffer
             * is freed.
             * @param data data for the new buffer
             * @returns A newly allocated buffer with a copy of `data` and of size `len`.
             */
            static new_copy_data(data: Uint8Array): Gst.Buffer
            /**
             * Create a new buffer and set the data and size of the buffer to @data and @len
             * respectively. @data will be freed when the buffer is unreffed, so this
             * function transfers ownership of @data to the new buffer.
             * @param data data for the new buffer
             * @returns A newly allocated buffer with `data` and of size `len`.
             */
            static new_take_data(data: Uint8Array): Gst.Buffer
            /**
             * Check if the data pointed to by @buffer is a valid RTCP packet using
             * gst_rtcp_buffer_validate_data().
             * @param buffer the buffer to validate
             * @returns TRUE if `buffer` is a valid RTCP packet.
             */
            static validate(buffer: Gst.Buffer): boolean
            /**
             * Check if the @data and @size point to the data of a valid compound,
             * non-reduced size RTCP packet.
             * Use this function to validate a packet before using the other functions in
             * this module.
             * @param data the data to validate
             * @returns TRUE if the data points to a valid RTCP packet.
             */
            static validate_data(data: Uint8Array): boolean
            /**
             * Check if the @data and @size point to the data of a valid RTCP packet.
             * Use this function to validate a packet before using the other functions in
             * this module.
             *
             * This function is updated to support reduced size rtcp packets according to
             * RFC 5506 and will validate full compound RTCP packets as well as reduced
             * size RTCP packets.
             * @since 1.6
             * @param data the data to validate
             * @returns TRUE if the data points to a valid RTCP packet.
             */
            static validate_data_reduced(data: Uint8Array): boolean
            /**
             * Check if the data pointed to by @buffer is a valid RTCP packet using
             * gst_rtcp_buffer_validate_reduced().
             * @since 1.6
             * @param buffer the buffer to validate
             * @returns TRUE if `buffer` is a valid RTCP packet.
             */
            static validate_reduced(buffer: Gst.Buffer): boolean
            /**
             */
            buffer: Gst.Buffer
            /**
             */
            map: Gst.MapInfo
            /**
             * Add a new packet of @type to @rtcp. @packet will point to the newly created
             * packet.
             * @param type the #GstRTCPType of the new packet
             * @param packet pointer to new packet
             * @returns %TRUE if the packet could be created. This function returns %FALSE if the max mtu is exceeded for the buffer.
             */
            add_packet(type: RTCPType, packet: RTCPPacket): boolean
            /**
             * Initialize a new #GstRTCPPacket pointer that points to the first packet in
             * @rtcp.
             * @param packet a #GstRTCPPacket
             * @returns TRUE if the packet existed in `rtcp`.
             */
            get_first_packet(packet: RTCPPacket): boolean
            /**
             * Get the number of RTCP packets in @rtcp.
             * @returns the number of RTCP packets in `rtcp`.
             */
            get_packet_count(): number
            /**
             * Finish @rtcp after being constructed. This function is usually called
             * after gst_rtcp_buffer_map() and after adding the RTCP items to the new buffer.
             *
             * The function adjusts the size of @rtcp with the total length of all the
             * added packets.
             */
            unmap(): boolean
        }
        /**
         * Data structure that points to a packet at @offset in @buffer.
         * The size of the structure is made public to allow stack allocations.
         */
        abstract class RTCPPacket {
            static readonly $gtype: GObject.GType<RTCPPacket>

            
            /**
             * pointer to RTCP buffer
             */
            rtcp: RTCPBuffer
            /**
             * offset of packet in buffer data
             */
            offset: number
            /**
             * Add profile-specific extension @data to @packet. If @packet already
             * contains profile-specific extension @data will be appended to the existing
             * extension.
             * @since 1.10
             * @param data profile-specific data
             * @returns %TRUE if the profile specific extension data was added.
             */
            add_profile_specific_ext(data: Uint8Array): boolean
            /**
             * Add a new report block to @packet with the given values.
             * @param ssrc data source being reported
             * @param fractionlost fraction lost since last SR/RR
             * @param packetslost the cumululative number of packets lost
             * @param exthighestseq the extended last sequence number received
             * @param jitter the interarrival jitter
             * @param lsr the last SR packet from this source
             * @param dlsr the delay since last SR packet
             * @returns %TRUE if the packet was created. This function can return %FALSE if the max MTU is exceeded or the number of report blocks is greater than #GST_RTCP_MAX_RB_COUNT.
             */
            add_rb(ssrc: number, fractionlost: number, packetslost: number, exthighestseq: number, jitter: number, lsr: number, dlsr: number): boolean
            /**
             * Get the application-dependent data attached to a RTPFB or PSFB @packet.
             * @since 1.10
             * @returns A pointer to the data
             */
            app_get_data(): number
            /**
             * Get the length of the application-dependent data attached to an APP
             * @packet.
             * @since 1.10
             * @returns The length of data in 32-bit words.
             */
            app_get_data_length(): number
            /**
             * Get the name field of the APP @packet.
             * @since 1.10
             * @returns The 4-byte name field, not zero-terminated.
             */
            app_get_name(): string
            /**
             * Get the SSRC/CSRC field of the APP @packet.
             * @since 1.10
             * @returns The SSRC/CSRC.
             */
            app_get_ssrc(): number
            /**
             * Get the subtype field of the APP @packet.
             * @since 1.10
             * @returns The subtype.
             */
            app_get_subtype(): number
            /**
             * Set the length of the application-dependent data attached to an APP
             * @packet.
             * @since 1.10
             * @param wordlen Length of the data in 32-bit words
             * @returns %TRUE if there was enough space in the packet to add this much data.
             */
            app_set_data_length(wordlen: number): boolean
            /**
             * Set the name field of the APP @packet.
             * @since 1.10
             * @param name 4-byte ASCII name
             */
            app_set_name(name: string): void
            /**
             * Set the SSRC/CSRC field of the APP @packet.
             * @since 1.10
             * @param ssrc SSRC/CSRC of the packet
             */
            app_set_ssrc(ssrc: number): void
            /**
             * Set the subtype field of the APP @packet.
             * @since 1.10
             * @param subtype subtype of the packet
             */
            app_set_subtype(subtype: number): void
            /**
             * Add @ssrc to the BYE @packet.
             * @param ssrc an SSRC to add
             * @returns %TRUE if the ssrc was added. This function can return %FALSE if the max MTU is exceeded or the number of sources blocks is greater than #GST_RTCP_MAX_BYE_SSRC_COUNT.
             */
            bye_add_ssrc(ssrc: number): boolean
            /**
             * Adds @len SSRCs in @ssrc to BYE @packet.
             * @param ssrc an array of SSRCs to add
             * @returns %TRUE if the all the SSRCs were added. This function can return %FALSE if the max MTU is exceeded or the number of sources blocks is greater than #GST_RTCP_MAX_BYE_SSRC_COUNT.
             */
            bye_add_ssrcs(ssrc: number[]): boolean
            /**
             * Get the @nth SSRC of the BYE @packet.
             * @param nth the nth SSRC to get
             * @returns The `nth` SSRC of `packet`.
             */
            bye_get_nth_ssrc(nth: number): number
            /**
             * Get the reason in @packet.
             * @returns The reason for the BYE `packet` or NULL if the packet did not contain a reason string. The string must be freed with g_free() after usage.
             */
            bye_get_reason(): string | null
            /**
             * Get the length of the reason string.
             * @returns The length of the reason string or 0 when there is no reason string present.
             */
            bye_get_reason_len(): number
            /**
             * Get the number of SSRC fields in @packet.
             * @returns The number of SSRC fields in `packet`.
             */
            bye_get_ssrc_count(): number
            /**
             * Set the reason string to @reason in @packet.
             * @param reason a reason string
             * @returns TRUE if the string could be set.
             */
            bye_set_reason(reason: string): boolean
            /**
             * The profile-specific extension data is copied into a new allocated
             * memory area @data. This must be freed with g_free() after usage.
             * @since 1.10
             * @returns %TRUE if there was valid data., result profile-specific data
             */
            copy_profile_specific_ext(): [boolean, Uint8Array]
            /**
             * Get the Feedback Control Information attached to a RTPFB or PSFB @packet.
             * @returns a pointer to the FCI
             */
            fb_get_fci(): number
            /**
             * Get the length of the Feedback Control Information attached to a
             * RTPFB or PSFB @packet.
             * @returns The length of the FCI in 32-bit words.
             */
            fb_get_fci_length(): number
            /**
             * Get the media SSRC field of the RTPFB or PSFB @packet.
             * @returns the media SSRC.
             */
            fb_get_media_ssrc(): number
            /**
             * Get the sender SSRC field of the RTPFB or PSFB @packet.
             * @returns the sender SSRC.
             */
            fb_get_sender_ssrc(): number
            /**
             * Get the feedback message type of the FB @packet.
             * @returns The feedback message type.
             */
            fb_get_type(): RTCPFBType
            /**
             * Set the length of the Feedback Control Information attached to a
             * RTPFB or PSFB @packet.
             * @param wordlen Length of the FCI in 32-bit words
             * @returns %TRUE if there was enough space in the packet to add this much FCI
             */
            fb_set_fci_length(wordlen: number): boolean
            /**
             * Set the media SSRC field of the RTPFB or PSFB @packet.
             * @param ssrc a media SSRC
             */
            fb_set_media_ssrc(ssrc: number): void
            /**
             * Set the sender SSRC field of the RTPFB or PSFB @packet.
             * @param ssrc a sender SSRC
             */
            fb_set_sender_ssrc(ssrc: number): void
            /**
             * Set the feedback message type of the FB @packet.
             * @param type the #GstRTCPFBType to set
             */
            fb_set_type(type: RTCPFBType): void
            /**
             * Get the count field in @packet.
             * @returns The count field in `packet` or -1 if `packet` does not point to a valid packet.
             */
            get_count(): number
            /**
             * Get the length field of @packet. This is the length of the packet in
             * 32-bit words minus one.
             * @returns The length field of `packet`.
             */
            get_length(): number
            /**
             * Get the packet padding of the packet pointed to by @packet.
             * @returns If the packet has the padding bit set.
             */
            get_padding(): boolean
            /**
             * @since 1.10
             * @returns %TRUE if there was valid data., result profile-specific data
             */
            get_profile_specific_ext(): [boolean, Uint8Array]
            /**
             * @since 1.10
             * @returns The number of 32-bit words containing profile-specific extension          data from `packet`.
             */
            get_profile_specific_ext_length(): number
            /**
             * Parse the values of the @nth report block in @packet and store the result in
             * the values.
             * @param nth the nth report block in @packet
             * @returns , result for data source being reported, result for fraction lost since last SR/RR, result for the cumululative number of packets lost, result for the extended last sequence number received, result for the interarrival jitter, result for the last SR packet from this source, result for the delay since last SR packet
             */
            get_rb(nth: number): [number, number, number, number, number, number, number]
            /**
             * Get the number of report blocks in @packet.
             * @returns The number of report blocks in `packet`.
             */
            get_rb_count(): number
            /**
             * Get the packet type of the packet pointed to by @packet.
             * @returns The packet type or GST_RTCP_TYPE_INVALID when `packet` is not pointing to a valid packet.
             */
            get_type(): RTCPType
            /**
             * Move the packet pointer @packet to the next packet in the payload.
             * Use gst_rtcp_buffer_get_first_packet() to initialize @packet.
             * @returns TRUE if `packet` is pointing to a valid packet after calling this function.
             */
            move_to_next(): boolean
            /**
             * Removes the packet pointed to by @packet and moves pointer to the next one
             * @returns TRUE if `packet` is pointing to a valid packet after calling this function.
             */
            remove(): boolean
            /**
             * Get the ssrc field of the RR @packet.
             * @returns the ssrc.
             */
            rr_get_ssrc(): number
            /**
             * Set the ssrc field of the RR @packet.
             * @param ssrc the SSRC to set
             */
            rr_set_ssrc(ssrc: number): void
            /**
             * Add a new SDES entry to the current item in @packet.
             * @param type the #GstRTCPSDESType of the SDES entry
             * @param data the data
             * @returns %TRUE if the item could be added, %FALSE if the MTU has been reached.
             */
            sdes_add_entry(type: RTCPSDESType, data: Uint8Array): boolean
            /**
             * Add a new SDES item for @ssrc to @packet.
             * @param ssrc the SSRC of the new item to add
             * @returns %TRUE if the item could be added, %FALSE if the maximum amount of items has been exceeded for the SDES packet or the MTU has been reached.
             */
            sdes_add_item(ssrc: number): boolean
            /**
             * This function is like gst_rtcp_packet_sdes_get_entry() but it returns a
             * null-terminated copy of the data instead. use g_free() after usage.
             * @param type result of the entry type
             * @returns %TRUE if there was valid data., result entry data
             */
            sdes_copy_entry(type: RTCPSDESType): [boolean, Uint8Array]
            /**
             * Move to the first SDES entry in the current item.
             * @returns %TRUE if there was a first entry.
             */
            sdes_first_entry(): boolean
            /**
             * Move to the first SDES item in @packet.
             * @returns TRUE if there was a first item.
             */
            sdes_first_item(): boolean
            /**
             * Get the data of the current SDES item entry. @type (when not NULL) will
             * contain the type of the entry. @data (when not NULL) will point to @len
             * bytes.
             *
             * When @type refers to a text item, @data will point to a UTF8 string. Note
             * that this UTF8 string is NOT null-terminated. Use
             * gst_rtcp_packet_sdes_copy_entry() to get a null-terminated copy of the entry.
             * @param type result of the entry type
             * @returns %TRUE if there was valid data., result entry data
             */
            sdes_get_entry(type: RTCPSDESType): [boolean, Uint8Array]
            /**
             * Get the number of items in the SDES packet @packet.
             * @returns The number of items in `packet`.
             */
            sdes_get_item_count(): number
            /**
             * Get the SSRC of the current SDES item.
             * @returns the SSRC of the current item.
             */
            sdes_get_ssrc(): number
            /**
             * Move to the next SDES entry in the current item.
             * @returns %TRUE if there was a next entry.
             */
            sdes_next_entry(): boolean
            /**
             * Move to the next SDES item in @packet.
             * @returns TRUE if there was a next item.
             */
            sdes_next_item(): boolean
            /**
             * Set the @nth new report block in @packet with the given values.
             *
             * Note: Not implemented.
             * @param nth the nth report block to set
             * @param ssrc data source being reported
             * @param fractionlost fraction lost since last SR/RR
             * @param packetslost the cumululative number of packets lost
             * @param exthighestseq the extended last sequence number received
             * @param jitter the interarrival jitter
             * @param lsr the last SR packet from this source
             * @param dlsr the delay since last SR packet
             */
            set_rb(nth: number, ssrc: number, fractionlost: number, packetslost: number, exthighestseq: number, jitter: number, lsr: number, dlsr: number): void
            /**
             * Parse the SR sender info and store the values.
             * @returns , result SSRC, result NTP time, result RTP time, result packet count, result octet count
             */
            sr_get_sender_info(): [number, number, number, number, number]
            /**
             * Set the given values in the SR packet @packet.
             * @param ssrc the SSRC
             * @param ntptime the NTP time
             * @param rtptime the RTP time
             * @param packet_count the packet count
             * @param octet_count the octet count
             */
            sr_set_sender_info(ssrc: number, ntptime: number, rtptime: number, packet_count: number, octet_count: number): void
            /**
             * Move to the first extended report block in XR @packet.
             * @since 1.16
             * @returns TRUE if there was a first extended report block.
             */
            xr_first_rb(): boolean
            /**
             * @since 1.16
             * @returns The number of 32-bit words containing type-specific block          data from `packet`.
             */
            xr_get_block_length(): number
            /**
             * Get the extended report block type of the XR @packet.
             * @since 1.16
             * @returns The extended report block type.
             */
            xr_get_block_type(): RTCPXRType
            /**
             * Parse the extended report block for DLRR report block type.
             * @since 1.16
             * @param nth the index of sub-block to retrieve.
             * @param ssrc the SSRC of the receiver.
             * @param last_rr the last receiver reference timestamp of @ssrc.
             * @param delay the delay since @last_rr.
             * @returns %TRUE if the report block is correctly parsed.
             */
            xr_get_dlrr_block(nth: number, ssrc: number, last_rr: number, delay: number): boolean
            /**
             * Retrieve the packet receipt time of @seq which ranges in [begin_seq, end_seq).
             * @since 1.16
             * @param seq the sequence to retrieve the time.
             * @param receipt_time the packet receipt time of @seq.
             * @returns %TRUE if the report block returns the receipt time correctly.
             */
            xr_get_prt_by_seq(seq: number, receipt_time: number): boolean
            /**
             * Parse the Packet Recept Times Report Block from a XR @packet
             * @since 1.16
             * @param ssrc the SSRC of the RTP data packet source being reported upon by this report block.
             * @param thinning the amount of thinning performed on the sequence number space.
             * @param begin_seq the first sequence number that this block reports on.
             * @param end_seq the last sequence number that this block reports on plus one.
             * @returns %TRUE if the report block is correctly parsed.
             */
            xr_get_prt_info(ssrc: number, thinning: number, begin_seq: number, end_seq: number): boolean
            /**
             * Parse the extended report block for Loss RLE and Duplicated LRE block type.
             * @since 1.16
             * @param ssrc the SSRC of the RTP data packet source being reported upon by this report block.
             * @param thinning the amount of thinning performed on the sequence number space.
             * @param begin_seq the first sequence number that this block reports on.
             * @param end_seq the last sequence number that this block reports on plus one.
             * @param chunk_count the number of chunks calculated by block length.
             * @returns %TRUE if the report block is correctly parsed.
             */
            xr_get_rle_info(ssrc: number, thinning: number, begin_seq: number, end_seq: number, chunk_count: number): boolean
            /**
             * Retrieve actual chunk data.
             * @since 1.16
             * @param nth the index of chunk to retrieve.
             * @param chunk the @nth chunk.
             * @returns %TRUE if the report block returns chunk correctly.
             */
            xr_get_rle_nth_chunk(nth: number, chunk: number): boolean
            /**
             * @since 1.16
             * @param timestamp NTP timestamp
             * @returns %TRUE if the report block returns the reference time correctly.
             */
            xr_get_rrt(timestamp: number): boolean
            /**
             * Get the ssrc field of the XR @packet.
             * @since 1.16
             * @returns the ssrc.
             */
            xr_get_ssrc(): number
            /**
             * Extract a basic information from static summary report block of XR @packet.
             * @since 1.16
             * @param ssrc the SSRC of the source.
             * @param begin_seq the first sequence number that this block reports on.
             * @param end_seq the last sequence number that this block reports on plus one.
             * @returns %TRUE if the report block is correctly parsed.
             */
            xr_get_summary_info(ssrc: number, begin_seq: number, end_seq: number): boolean
            /**
             * Extract jitter information from the statistics summary. If the jitter flag in
             * a block header is set as zero, all of jitters will be zero.
             * @since 1.16
             * @param min_jitter the minimum relative transit time between two sequences.
             * @param max_jitter the maximum relative transit time between two sequences.
             * @param mean_jitter the mean relative transit time between two sequences.
             * @param dev_jitter the standard deviation of the relative transit time between two sequences.
             * @returns %TRUE if the report block is correctly parsed.
             */
            xr_get_summary_jitter(min_jitter: number, max_jitter: number, mean_jitter: number, dev_jitter: number): boolean
            /**
             * Get the number of lost or duplicate packets. If the flag in a block header
             * is set as zero, @lost_packets or @dup_packets will be zero.
             * @since 1.16
             * @param lost_packets the number of lost packets between begin_seq and end_seq.
             * @param dup_packets the number of duplicate packets between begin_seq and end_seq.
             * @returns %TRUE if the report block is correctly parsed.
             */
            xr_get_summary_pkt(lost_packets: number, dup_packets: number): boolean
            /**
             * Extract the value of ttl for ipv4, or hop limit for ipv6.
             * @since 1.16
             * @param is_ipv4 the flag to indicate that the return values are ipv4 ttl or ipv6 hop limits.
             * @param min_ttl the minimum TTL or Hop Limit value of data packets between two sequences.
             * @param max_ttl the maximum TTL or Hop Limit value of data packets between two sequences.
             * @param mean_ttl the mean TTL or Hop Limit value of data packets between two sequences.
             * @param dev_ttl the standard deviation of the TTL or Hop Limit value of data packets between two sequences.
             * @returns %TRUE if the report block is correctly parsed.
             */
            xr_get_summary_ttl(is_ipv4: boolean, min_ttl: number, max_ttl: number, mean_ttl: number, dev_ttl: number): boolean
            /**
             * @since 1.16
             * @param burst_density the fraction of RTP data packets within burst periods.
             * @param gap_density the fraction of RTP data packets within inter-burst gaps.
             * @param burst_duration the mean duration(ms) of the burst periods.
             * @param gap_duration the mean duration(ms) of the gap periods.
             * @returns %TRUE if the report block is correctly parsed.
             */
            xr_get_voip_burst_metrics(burst_density: number, gap_density: number, burst_duration: number, gap_duration: number): boolean
            /**
             * @since 1.16
             * @param gmin the gap threshold.
             * @param rx_config the receiver configuration byte.
             * @returns %TRUE if the report block is correctly parsed.
             */
            xr_get_voip_configuration_params(gmin: number, rx_config: number): boolean
            /**
             * @since 1.16
             * @param roundtrip_delay the most recently calculated round trip time between RTP interfaces(ms)
             * @param end_system_delay the most recently estimated end system delay(ms)
             * @returns %TRUE if the report block is correctly parsed.
             */
            xr_get_voip_delay_metrics(roundtrip_delay: number, end_system_delay: number): boolean
            /**
             * @since 1.16
             * @param jb_nominal the current nominal jitter buffer delay(ms)
             * @param jb_maximum the current maximum jitter buffer delay(ms)
             * @param jb_abs_max the absolute maximum delay(ms)
             * @returns %TRUE if the report block is correctly parsed.
             */
            xr_get_voip_jitter_buffer_params(jb_nominal: number, jb_maximum: number, jb_abs_max: number): boolean
            /**
             * @since 1.16
             * @param ssrc the SSRC of source
             * @returns %TRUE if the report block is correctly parsed.
             */
            xr_get_voip_metrics_ssrc(ssrc: number): boolean
            /**
             * @since 1.16
             * @param loss_rate the fraction of RTP data packets from the source lost.
             * @param discard_rate the fraction of RTP data packets from the source that have been discarded.
             * @returns %TRUE if the report block is correctly parsed.
             */
            xr_get_voip_packet_metrics(loss_rate: number, discard_rate: number): boolean
            /**
             * @since 1.16
             * @param r_factor the R factor is a voice quality metric describing the segment of the call.
             * @param ext_r_factor the external R factor is a voice quality metric.
             * @param mos_lq the estimated mean opinion score for listening quality.
             * @param mos_cq the estimated mean opinion score for conversational quality.
             * @returns %TRUE if the report block is correctly parsed.
             */
            xr_get_voip_quality_metrics(r_factor: number, ext_r_factor: number, mos_lq: number, mos_cq: number): boolean
            /**
             * @since 1.16
             * @param signal_level the ratio of the signal level to a 0 dBm reference.
             * @param noise_level the ratio of the silent period background noise level to a 0 dBm reference.
             * @param rerl the residual echo return loss value.
             * @param gmin the gap threshold.
             * @returns %TRUE if the report block is correctly parsed.
             */
            xr_get_voip_signal_metrics(signal_level: number, noise_level: number, rerl: number, gmin: number): boolean
            /**
             * Move to the next extended report block in XR @packet.
             * @since 1.16
             * @returns TRUE if there was a next extended report block.
             */
            xr_next_rb(): boolean
        }
        none
        /**
         */
        abstract class RTPBaseAudioPayloadPrivate {
            static readonly $gtype: GObject.GType<RTPBaseAudioPayloadPrivate>

            
        }
        none
        /**
         */
        abstract class RTPBaseDepayloadPrivate {
            static readonly $gtype: GObject.GType<RTPBaseDepayloadPrivate>

            
        }
        none
        /**
         */
        abstract class RTPBasePayloadPrivate {
            static readonly $gtype: GObject.GType<RTPBasePayloadPrivate>

            
        }
        /**
         * The GstRTPBuffer helper functions makes it easy to parse and create regular
         * #GstBuffer objects that contain RTP payloads. These buffers are typically of
         * 'application/x-rtp' #GstCaps.
         */
        abstract class RTPBuffer {
            static readonly $gtype: GObject.GType<RTPBuffer>

            
            /**
             * 0, the padding bit will be set. All other RTP header fields
             * will be set to 0/FALSE.
             * @param buffer a #GstBuffer
             * @param payload_len the length of the payload
             * @param pad_len the amount of padding
             * @param csrc_count the number of CSRC entries
             */
            static allocate_data(buffer: Gst.Buffer, payload_len: number, pad_len: number, csrc_count: number): void
            /**
             * Calculate the header length of an RTP packet with @csrc_count CSRC entries.
             * An RTP packet can have at most 15 CSRC entries.
             * @param csrc_count the number of CSRC entries
             * @returns The length of an RTP header with `csrc_count` CSRC entries.
             */
            static calc_header_len(csrc_count: number): number
            /**
             * Calculate the total length of an RTP packet with a payload size of @payload_len,
             * a padding of @pad_len and a @csrc_count CSRC entries.
             * @param payload_len the length of the payload
             * @param pad_len the amount of padding
             * @param csrc_count the number of CSRC entries
             * @returns The total length of an RTP header with given parameters.
             */
            static calc_packet_len(payload_len: number, pad_len: number, csrc_count: number): number
            /**
             * Calculate the length of the payload of an RTP packet with size @packet_len,
             * a padding of @pad_len and a @csrc_count CSRC entries.
             * @param packet_len the length of the total RTP packet
             * @param pad_len the amount of padding
             * @param csrc_count the number of CSRC entries
             * @returns The length of the payload of an RTP packet  with given parameters.
             */
            static calc_payload_len(packet_len: number, pad_len: number, csrc_count: number): number
            /**
             * Compare two sequence numbers, taking care of wraparounds. This function
             * returns the difference between @seqnum1 and @seqnum2.
             * @param seqnum1 a sequence number
             * @param seqnum2 a sequence number
             * @returns a negative value if `seqnum1` is bigger than `seqnum2`, 0 if they are equal or a positive value if `seqnum1` is smaller than `segnum2`.
             */
            static compare_seqnum(seqnum1: number, seqnum2: number): number
            /**
             * Get the default clock-rate for the static payload type @payload_type.
             * @param payload_type the static payload type
             * @returns the default clock rate or -1 if the payload type is not static or the clock-rate is undefined.
             */
            static default_clock_rate(payload_type: number): number
            /**
             * Update the @exttimestamp field with the extended timestamp of @timestamp
             * For the first call of the method, @exttimestamp should point to a location
             * with a value of -1.
             *
             * This function is able to handle both forward and backward timestamps taking
             * into account:
             *   - timestamp wraparound making sure that the returned value is properly increased.
             *   - timestamp unwraparound making sure that the returned value is properly decreased.
             * @param timestamp a new timestamp
             * @returns The extended timestamp of `timestamp` or 0 if the result can't go anywhere backwards., a previous extended timestamp
             */
            static ext_timestamp(timestamp: number): [number, number]
            /**
             * Similar to gst_rtp_buffer_get_extension_onebyte_header, but working
             * on the #GBytes you get from gst_rtp_buffer_get_extension_bytes.
             * Parses RFC 5285 style header extensions with a one byte header. It will
             * return the nth extension with the requested id.
             * @since 1.18
             * @param bytes #GBytes
             * @param bit_pattern The bit-pattern. Anything but 0xBEDE is rejected.
             * @param id The ID of the header extension to be read (between 1 and 14).
             * @param nth Read the nth extension packet with the requested ID
             * @returns TRUE if `bytes` had the requested header extension,    location for data
             */
            static get_extension_onebyte_header_from_bytes(bytes: GLib.Bytes, bit_pattern: number, id: number, nth: number): [boolean, Uint8Array]
            /**
             * Map the contents of @buffer into @rtp.
             * @param buffer a #GstBuffer
             * @param flags #GstMapFlags
             * @returns %TRUE if `buffer` could be mapped., a #GstRTPBuffer
             */
            static map(buffer: Gst.Buffer, flags: Gst.MapFlags): [boolean, RTPBuffer]
            /**
             * Allocate a new #GstBuffer with enough data to hold an RTP packet with
             * @csrc_count CSRCs, a payload length of @payload_len and padding of @pad_len.
             * All other RTP header fields will be set to 0/FALSE.
             * @param payload_len the length of the payload
             * @param pad_len the amount of padding
             * @param csrc_count the number of CSRC entries
             * @returns A newly allocated buffer that can hold an RTP packet with given parameters.
             */
            static new_allocate(payload_len: number, pad_len: number, csrc_count: number): Gst.Buffer
            /**
             * Create a new #GstBuffer that can hold an RTP packet that is exactly
             * @packet_len long. The length of the payload depends on @pad_len and
             * @csrc_count and can be calculated with gst_rtp_buffer_calc_payload_len().
             * All RTP header fields will be set to 0/FALSE.
             * @param packet_len the total length of the packet
             * @param pad_len the amount of padding
             * @param csrc_count the number of CSRC entries
             * @returns A newly allocated buffer that can hold an RTP packet of `packet_len`.
             */
            static new_allocate_len(packet_len: number, pad_len: number, csrc_count: number): Gst.Buffer
            /**
             * Create a new buffer and set the data to a copy of @len
             * bytes of @data and the size to @len. The data will be freed when the buffer
             * is freed.
             * @param data data for the new
              buffer
             * @returns A newly allocated buffer with a copy of `data` and of size `len`.
             */
            static new_copy_data(data: Uint8Array): Gst.Buffer
            /**
             * Create a new buffer and set the data and size of the buffer to @data and @len
             * respectively. @data will be freed when the buffer is unreffed, so this
             * function transfers ownership of @data to the new buffer.
             * @param data 
              data for the new buffer
             * @returns A newly allocated buffer with `data` and of size `len`.
             */
            static new_take_data(data: Uint8Array): Gst.Buffer
            /**
             * pointer to RTP buffer
             */
            buffer: Gst.Buffer
            /**
             * internal state
             */
            state: number
            /**
             * array of data
             */
            data: never[]
            /**
             * array of size
             */
            size: number[]
            /**
             * array of #GstMapInfo
             */
            map: Gst.MapInfo[]
            /**
             * Adds a RFC 5285 header extension with a one byte header to the end of the
             * RTP header. If there is already a RFC 5285 header extension with a one byte
             * header, the new extension will be appended.
             * It will not work if there is already a header extension that does not follow
             * the mechanism described in RFC 5285 or if there is a header extension with
             * a two bytes header as described in RFC 5285. In that case, use
             * gst_rtp_buffer_add_extension_twobytes_header()
             * @param id The ID of the header extension (between 1 and 14).
             * @param data location for data
             * @returns %TRUE if header extension could be added
             */
            add_extension_onebyte_header(id: number, data: Uint8Array): boolean
            /**
             * Adds a RFC 5285 header extension with a two bytes header to the end of the
             * RTP header. If there is already a RFC 5285 header extension with a two bytes
             * header, the new extension will be appended.
             * It will not work if there is already a header extension that does not follow
             * the mechanism described in RFC 5285 or if there is a header extension with
             * a one byte header as described in RFC 5285. In that case, use
             * gst_rtp_buffer_add_extension_onebyte_header()
             * @param appbits Application specific bits
             * @param id The ID of the header extension
             * @param data location for data
             * @returns %TRUE if header extension could be added
             */
            add_extension_twobytes_header(appbits: number, id: number, data: Uint8Array): boolean
            /**
             * Get the CSRC at index @idx in @buffer.
             * @param idx the index of the CSRC to get
             * @returns the CSRC at index `idx` in host order.
             */
            get_csrc(idx: number): number
            /**
             * Get the CSRC count of the RTP packet in @buffer.
             * @returns the CSRC count of `buffer`.
             */
            get_csrc_count(): number
            /**
             * Check if the extension bit is set on the RTP packet in @buffer.
             * @returns TRUE if `buffer` has the extension bit set.
             */
            get_extension(): boolean
            /**
             * Similar to gst_rtp_buffer_get_extension_data, but more suitable for language
             * bindings usage. @bits will contain the extension 16 bits of custom data and
             * the extension data (not including the extension header) is placed in a new
             * #GBytes structure.
             *
             * If @rtp did not contain an extension, this function will return %NULL, with
             * @bits unchanged. If there is an extension header but no extension data then
             * an empty #GBytes will be returned.
             * @since 1.2
             * @returns A new #GBytes if an extension header was present and %NULL otherwise., location for header bits
             */
            get_extension_data(): [GLib.Bytes | null, number]
            /**
             * Parses RFC 5285 style header extensions with a one byte header. It will
             * return the nth extension with the requested id.
             * @param id The ID of the header extension to be read (between 1 and 14).
             * @param nth Read the nth extension packet with the requested ID
             * @returns TRUE if `buffer` had the requested header extension,    location for data
             */
            get_extension_onebyte_header(id: number, nth: number): boolean
            /**
             * Parses RFC 5285 style header extensions with a two bytes header. It will
             * return the nth extension with the requested id.
             * @param id The ID of the header extension to be read (between 1 and 14).
             * @param nth Read the nth extension packet with the requested ID
             * @returns TRUE if `buffer` had the requested header extension, Application specific bits,    location for data
             */
            get_extension_twobytes_header(id: number, nth: number): boolean
            /**
             * Return the total length of the header in @buffer. This include the length of
             * the fixed header, the CSRC list and the extension header.
             * @returns The total length of the header in `buffer`.
             */
            get_header_len(): number
            /**
             * Check if the marker bit is set on the RTP packet in @buffer.
             * @returns TRUE if `buffer` has the marker bit set.
             */
            get_marker(): boolean
            /**
             * Return the total length of the packet in @buffer.
             * @returns The total length of the packet in `buffer`.
             */
            get_packet_len(): number
            /**
             * Check if the padding bit is set on the RTP packet in @buffer.
             * @returns TRUE if `buffer` has the padding bit set.
             */
            get_padding(): boolean
            /**
             * Create a buffer of the payload of the RTP packet in @buffer. This function
             * will internally create a subbuffer of @buffer so that a memcpy can be
             * avoided.
             * @returns A new buffer with the data of the payload.
             */
            get_payload_buffer(): Gst.Buffer
            /**
             * Similar to gst_rtp_buffer_get_payload, but more suitable for language
             * bindings usage. The return value is a pointer to a #GBytes structure
             * containing the payload data in @rtp.
             * @since 1.2
             * @returns A new #GBytes containing the payload data in `rtp`.
             */
            get_payload(): GLib.Bytes | null
            /**
             * Get the length of the payload of the RTP packet in @buffer.
             * @returns The length of the payload in `buffer`.
             */
            get_payload_len(): number
            /**
             * Create a subbuffer of the payload of the RTP packet in @buffer. @offset bytes
             * are skipped in the payload and the subbuffer will be of size @len.
             * If @len is -1 the total payload starting from @offset is subbuffered.
             * @param offset the offset in the payload
             * @param len the length in the payload
             * @returns A new buffer with the specified data of the payload.
             */
            get_payload_subbuffer(offset: number, len: number): Gst.Buffer
            /**
             * Get the payload type of the RTP packet in @buffer.
             * @returns The payload type.
             */
            get_payload_type(): number
            /**
             * Get the sequence number of the RTP packet in @buffer.
             * @returns The sequence number in host order.
             */
            get_seq(): number
            /**
             * Get the SSRC of the RTP packet in @buffer.
             * @returns the SSRC of `buffer` in host order.
             */
            get_ssrc(): number
            /**
             * Get the timestamp of the RTP packet in @buffer.
             * @returns The timestamp in host order.
             */
            get_timestamp(): number
            /**
             * Get the version number of the RTP packet in @buffer.
             * @returns The version of `buffer`.
             */
            get_version(): number
            /**
             * Set the amount of padding in the RTP packet in @buffer to
             * @len. If @len is 0, the padding is removed.
             *
             * NOTE: This function does not work correctly.
             * @param len the new amount of padding
             */
            pad_to(len: number): void
            /**
             * Unsets the extension bit of the RTP buffer and removes the extension header
             * and data.
             *
             * If the RTP buffer has no header extension data, the action has no effect.
             * The RTP buffer must be mapped READWRITE only once and the underlying
             * GstBuffer must be writable.
             * @since 1.20
             */
            remove_extension_data(): void
            /**
             * Modify the CSRC at index @idx in @buffer to @csrc.
             * @param idx the CSRC index to set
             * @param csrc the CSRC in host order to set at @idx
             */
            set_csrc(idx: number, csrc: number): void
            /**
             * Set the extension bit on the RTP packet in @buffer to @extension.
             * @param extension the new extension
             */
            set_extension(extension: boolean): void
            /**
             * Set the extension bit of the rtp buffer and fill in the @bits and @length of the
             * extension header. If the existing extension data is not large enough, it will
             * be made larger.
             *
             * Will also shorten the extension data from 1.20.
             * @param bits the bits specific for the extension
             * @param length the length that counts the number of 32-bit words in
            the extension, excluding the extension header ( therefore zero is a valid length)
             * @returns True if done.
             */
            set_extension_data(bits: number, length: number): boolean
            /**
             * Set the marker bit on the RTP packet in @buffer to @marker.
             * @param marker the new marker
             */
            set_marker(marker: boolean): void
            /**
             * Set the total @rtp size to @len. The data in the buffer will be made
             * larger if needed. Any padding will be removed from the packet.
             * @param len the new packet length
             */
            set_packet_len(len: number): void
            /**
             * Set the padding bit on the RTP packet in @buffer to @padding.
             * @param padding the new padding
             */
            set_padding(padding: boolean): void
            /**
             * Set the payload type of the RTP packet in @buffer to @payload_type.
             * @param payload_type the new type
             */
            set_payload_type(payload_type: number): void
            /**
             * Set the sequence number of the RTP packet in @buffer to @seq.
             * @param seq the new sequence number
             */
            set_seq(seq: number): void
            /**
             * Set the SSRC on the RTP packet in @buffer to @ssrc.
             * @param ssrc the new SSRC
             */
            set_ssrc(ssrc: number): void
            /**
             * Set the timestamp of the RTP packet in @buffer to @timestamp.
             * @param timestamp the new timestamp
             */
            set_timestamp(timestamp: number): void
            /**
             * Set the version of the RTP packet in @buffer to @version.
             * @param version the new version
             */
            set_version(version: number): void
            /**
             * Unmap @rtp previously mapped with gst_rtp_buffer_map().
             */
            unmap(): void
        }
        none
        /**
         * Structure holding default payload type information.
         */
        abstract class RTPPayloadInfo {
            static readonly $gtype: GObject.GType<RTPPayloadInfo>

            
            /**
             * Get the #GstRTPPayloadInfo for @media and @encoding_name. This function is
             * mostly used to get the default clock-rate and bandwidth for dynamic payload
             * types specified with @media and @encoding name.
             *
             * The search for @encoding_name will be performed in a case insensitive way.
             * @param media the media to find
             * @param encoding_name the encoding name to find
             * @returns a #GstRTPPayloadInfo or NULL when no info could be found.
             */
            static for_name(media: string, encoding_name: string): RTPPayloadInfo | null
            /**
             * Get the #GstRTPPayloadInfo for @payload_type. This function is
             * mostly used to get the default clock-rate and bandwidth for static payload
             * types specified with @payload_type.
             * @param payload_type the payload_type to find
             * @returns a #GstRTPPayloadInfo or NULL when no info could be found.
             */
            static for_pt(payload_type: number): RTPPayloadInfo | null
            /**
             * payload type, -1 means dynamic
             */
            payload_type: number
            /**
             * the media type(s), usually "audio", "video", "application", "text",
             * "message".
             */
            media: string
            /**
             * the encoding name of @pt
             */
            encoding_name: string
            /**
             * default clock rate, 0 = unknown/variable
             */
            clock_rate: number
            /**
             * encoding parameters. For audio this is the number of
             * channels. NULL = not applicable.
             */
            encoding_parameters: string
            /**
             * the bitrate of the media. 0 = unknown/variable.
             */
            bitrate: number
        }
        /**
         * Meta describing the source(s) of the buffer.
         * @since 1.16
         */
        abstract class RTPSourceMeta {
            static readonly $gtype: GObject.GType<RTPSourceMeta>

            
            /**
             */
            static get_info(): Gst.MetaInfo
            /**
             * parent #GstMeta
             */
            meta: Gst.Meta
            /**
             * the SSRC
             */
            ssrc: number
            /**
             * whether @ssrc is set and valid
             */
            ssrc_valid: boolean
            /**
             * pointer to the CSRCs
             */
            csrc: number[]
            /**
             * number of elements in @csrc
             */
            csrc_count: number
            /**
             * Appends @csrc to the list of contributing sources in @meta.
             * @since 1.16
             * @param csrc the csrcs to append
             * @returns %TRUE if all elements in `csrc` was added, %FALSE otherwise.
             */
            append_csrc(csrc: number[]): boolean
            /**
             * Count the total number of RTP sources found in @meta, both SSRC and CSRC.
             * @since 1.16
             * @returns The number of RTP sources
             */
            get_source_count(): number
            /**
             * Sets @ssrc in @meta. If @ssrc is %NULL the ssrc of @meta will be unset.
             * @since 1.16
             * @param ssrc pointer to the SSRC
             * @returns %TRUE on success, %FALSE otherwise.
             */
            set_ssrc(ssrc: number | null): boolean
        }
        /**
         * Attaches RTP source information to @buffer.
         * @since 1.16
         * @param buffer a #GstBuffer
         * @param ssrc pointer to the SSRC
         * @param csrc pointer to the CSRCs
         * @returns the #GstRTPSourceMeta on `buffer`.
         */
        function buffer_add_rtp_source_meta(buffer: Gst.Buffer, ssrc: number | null, csrc: number[] | null): RTPSourceMeta
        /**
         * Find the #GstRTPSourceMeta on @buffer.
         * @since 1.16
         * @param buffer a #GstBuffer
         * @returns the #GstRTPSourceMeta or %NULL when there is no such metadata on `buffer`.
         */
        function buffer_get_rtp_source_meta(buffer: Gst.Buffer): RTPSourceMeta | null
        /**
         * Open @buffer for reading or writing, depending on @flags. The resulting RTCP
         * buffer state is stored in @rtcp.
         * @param buffer a buffer with an RTCP packet
         * @param flags flags for the mapping
         * @param rtcp resulting #GstRTCPBuffer
         */
        function rtcp_buffer_map(buffer: Gst.Buffer, flags: Gst.MapFlags, rtcp: RTCPBuffer): boolean
        /**
         * Create a new buffer for constructing RTCP packets. The packet will have a
         * maximum size of @mtu.
         * @param mtu the maximum mtu size.
         * @returns A newly allocated buffer.
         */
        function rtcp_buffer_new(mtu: number): Gst.Buffer
        /**
         * Create a new buffer and set the data to a copy of @len
         * bytes of @data and the size to @len. The data will be freed when the buffer
         * is freed.
         * @param data data for the new buffer
         * @returns A newly allocated buffer with a copy of `data` and of size `len`.
         */
        function rtcp_buffer_new_copy_data(data: Uint8Array): Gst.Buffer
        /**
         * Create a new buffer and set the data and size of the buffer to @data and @len
         * respectively. @data will be freed when the buffer is unreffed, so this
         * function transfers ownership of @data to the new buffer.
         * @param data data for the new buffer
         * @returns A newly allocated buffer with `data` and of size `len`.
         */
        function rtcp_buffer_new_take_data(data: Uint8Array): Gst.Buffer
        /**
         * Check if the data pointed to by @buffer is a valid RTCP packet using
         * gst_rtcp_buffer_validate_data().
         * @param buffer the buffer to validate
         * @returns TRUE if `buffer` is a valid RTCP packet.
         */
        function rtcp_buffer_validate(buffer: Gst.Buffer): boolean
        /**
         * Check if the @data and @size point to the data of a valid compound,
         * non-reduced size RTCP packet.
         * Use this function to validate a packet before using the other functions in
         * this module.
         * @param data the data to validate
         * @returns TRUE if the data points to a valid RTCP packet.
         */
        function rtcp_buffer_validate_data(data: Uint8Array): boolean
        /**
         * Check if the @data and @size point to the data of a valid RTCP packet.
         * Use this function to validate a packet before using the other functions in
         * this module.
         *
         * This function is updated to support reduced size rtcp packets according to
         * RFC 5506 and will validate full compound RTCP packets as well as reduced
         * size RTCP packets.
         * @since 1.6
         * @param data the data to validate
         * @returns TRUE if the data points to a valid RTCP packet.
         */
        function rtcp_buffer_validate_data_reduced(data: Uint8Array): boolean
        /**
         * Check if the data pointed to by @buffer is a valid RTCP packet using
         * gst_rtcp_buffer_validate_reduced().
         * @since 1.6
         * @param buffer the buffer to validate
         * @returns TRUE if `buffer` is a valid RTCP packet.
         */
        function rtcp_buffer_validate_reduced(buffer: Gst.Buffer): boolean
        /**
         * Converts an NTP time to UNIX nanoseconds. @ntptime can typically be
         * the NTP time of an SR RTCP message and contains, in the upper 32 bits, the
         * number of seconds since 1900 and, in the lower 32 bits, the fractional
         * seconds. The resulting value will be the number of nanoseconds since 1970.
         * @param ntptime an NTP timestamp
         * @returns the UNIX time for `ntptime` in nanoseconds.
         */
        function rtcp_ntp_to_unix(ntptime: number): number
        /**
         * Convert @name into a @GstRTCPSDESType. @name is typically a key in a
         * #GstStructure containing SDES items.
         * @param name a SDES name
         * @returns the #GstRTCPSDESType for `name` or #GST_RTCP_SDES_PRIV when `name` is a private sdes item.
         */
        function rtcp_sdes_name_to_type(name: string): RTCPSDESType
        /**
         * Converts @type to the string equivalent. The string is typically used as a
         * key in a #GstStructure containing SDES items.
         * @param type a #GstRTCPSDESType
         * @returns the string equivalent of `type`
         */
        function rtcp_sdes_type_to_name(type: RTCPSDESType): string
        /**
         * Converts a UNIX timestamp in nanoseconds to an NTP time. The caller should
         * pass a value with nanoseconds since 1970. The NTP time will, in the upper
         * 32 bits, contain the number of seconds since 1900 and, in the lower 32
         * bits, the fractional seconds. The resulting value can be used as an ntptime
         * for constructing SR RTCP packets.
         * @param unixtime an UNIX timestamp in nanoseconds
         * @returns the NTP time for `unixtime`.
         */
        function rtcp_unix_to_ntp(unixtime: number): number
        /**
         * 0, the padding bit will be set. All other RTP header fields
         * will be set to 0/FALSE.
         * @param buffer a #GstBuffer
         * @param payload_len the length of the payload
         * @param pad_len the amount of padding
         * @param csrc_count the number of CSRC entries
         */
        function rtp_buffer_allocate_data(buffer: Gst.Buffer, payload_len: number, pad_len: number, csrc_count: number): void
        /**
         * Calculate the header length of an RTP packet with @csrc_count CSRC entries.
         * An RTP packet can have at most 15 CSRC entries.
         * @param csrc_count the number of CSRC entries
         * @returns The length of an RTP header with `csrc_count` CSRC entries.
         */
        function rtp_buffer_calc_header_len(csrc_count: number): number
        /**
         * Calculate the total length of an RTP packet with a payload size of @payload_len,
         * a padding of @pad_len and a @csrc_count CSRC entries.
         * @param payload_len the length of the payload
         * @param pad_len the amount of padding
         * @param csrc_count the number of CSRC entries
         * @returns The total length of an RTP header with given parameters.
         */
        function rtp_buffer_calc_packet_len(payload_len: number, pad_len: number, csrc_count: number): number
        /**
         * Calculate the length of the payload of an RTP packet with size @packet_len,
         * a padding of @pad_len and a @csrc_count CSRC entries.
         * @param packet_len the length of the total RTP packet
         * @param pad_len the amount of padding
         * @param csrc_count the number of CSRC entries
         * @returns The length of the payload of an RTP packet  with given parameters.
         */
        function rtp_buffer_calc_payload_len(packet_len: number, pad_len: number, csrc_count: number): number
        /**
         * Compare two sequence numbers, taking care of wraparounds. This function
         * returns the difference between @seqnum1 and @seqnum2.
         * @param seqnum1 a sequence number
         * @param seqnum2 a sequence number
         * @returns a negative value if `seqnum1` is bigger than `seqnum2`, 0 if they are equal or a positive value if `seqnum1` is smaller than `segnum2`.
         */
        function rtp_buffer_compare_seqnum(seqnum1: number, seqnum2: number): number
        /**
         * Get the default clock-rate for the static payload type @payload_type.
         * @param payload_type the static payload type
         * @returns the default clock rate or -1 if the payload type is not static or the clock-rate is undefined.
         */
        function rtp_buffer_default_clock_rate(payload_type: number): number
        /**
         * Update the @exttimestamp field with the extended timestamp of @timestamp
         * For the first call of the method, @exttimestamp should point to a location
         * with a value of -1.
         *
         * This function is able to handle both forward and backward timestamps taking
         * into account:
         *   - timestamp wraparound making sure that the returned value is properly increased.
         *   - timestamp unwraparound making sure that the returned value is properly decreased.
         * @param timestamp a new timestamp
         * @returns The extended timestamp of `timestamp` or 0 if the result can't go anywhere backwards., a previous extended timestamp
         */
        function rtp_buffer_ext_timestamp(timestamp: number): [number, number]
        /**
         * Similar to gst_rtp_buffer_get_extension_onebyte_header, but working
         * on the #GBytes you get from gst_rtp_buffer_get_extension_bytes.
         * Parses RFC 5285 style header extensions with a one byte header. It will
         * return the nth extension with the requested id.
         * @since 1.18
         * @param bytes #GBytes
         * @param bit_pattern The bit-pattern. Anything but 0xBEDE is rejected.
         * @param id The ID of the header extension to be read (between 1 and 14).
         * @param nth Read the nth extension packet with the requested ID
         * @returns TRUE if `bytes` had the requested header extension,    location for data
         */
        function rtp_buffer_get_extension_onebyte_header_from_bytes(bytes: GLib.Bytes, bit_pattern: number, id: number, nth: number): [boolean, Uint8Array]
        /**
         * Map the contents of @buffer into @rtp.
         * @param buffer a #GstBuffer
         * @param flags #GstMapFlags
         * @returns %TRUE if `buffer` could be mapped., a #GstRTPBuffer
         */
        function rtp_buffer_map(buffer: Gst.Buffer, flags: Gst.MapFlags): [boolean, RTPBuffer]
        /**
         * Allocate a new #GstBuffer with enough data to hold an RTP packet with
         * @csrc_count CSRCs, a payload length of @payload_len and padding of @pad_len.
         * All other RTP header fields will be set to 0/FALSE.
         * @param payload_len the length of the payload
         * @param pad_len the amount of padding
         * @param csrc_count the number of CSRC entries
         * @returns A newly allocated buffer that can hold an RTP packet with given parameters.
         */
        function rtp_buffer_new_allocate(payload_len: number, pad_len: number, csrc_count: number): Gst.Buffer
        /**
         * Create a new #GstBuffer that can hold an RTP packet that is exactly
         * @packet_len long. The length of the payload depends on @pad_len and
         * @csrc_count and can be calculated with gst_rtp_buffer_calc_payload_len().
         * All RTP header fields will be set to 0/FALSE.
         * @param packet_len the total length of the packet
         * @param pad_len the amount of padding
         * @param csrc_count the number of CSRC entries
         * @returns A newly allocated buffer that can hold an RTP packet of `packet_len`.
         */
        function rtp_buffer_new_allocate_len(packet_len: number, pad_len: number, csrc_count: number): Gst.Buffer
        /**
         * Create a new buffer and set the data to a copy of @len
         * bytes of @data and the size to @len. The data will be freed when the buffer
         * is freed.
         * @param data data for the new
          buffer
         * @returns A newly allocated buffer with a copy of `data` and of size `len`.
         */
        function rtp_buffer_new_copy_data(data: Uint8Array): Gst.Buffer
        /**
         * Create a new buffer and set the data and size of the buffer to @data and @len
         * respectively. @data will be freed when the buffer is unreffed, so this
         * function transfers ownership of @data to the new buffer.
         * @param data 
          data for the new buffer
         * @returns A newly allocated buffer with `data` and of size `len`.
         */
        function rtp_buffer_new_take_data(data: Uint8Array): Gst.Buffer
        /**
         * Retrieve all the factories of the currently registered RTP header
         * extensions.  Call gst_element_factory_create() with each factory to create
         * the associated #GstRTPHeaderExtension.
         * @since 1.20
         * @returns a #GList of     #GstElementFactory's. Use gst_plugin_feature_list_free() after use
         */
        function rtp_get_header_extension_list(): Gst.ElementFactory[]
        /**
         * Reads the NTP time from the @size NTP-56 extension bytes in @data and store the
         * result in @ntptime.
         * @param data the data to read from
         * @returns %TRUE on success., the result NTP time
         */
        function rtp_hdrext_get_ntp_56(data: Uint8Array): [boolean, number]
        /**
         * Reads the NTP time from the @size NTP-64 extension bytes in @data and store the
         * result in @ntptime.
         * @param data the data to read from
         * @returns %TRUE on success., the result NTP time
         */
        function rtp_hdrext_get_ntp_64(data: Uint8Array): [boolean, number]
        /**
         * Writes the NTP time in @ntptime to the format required for the NTP-56 header
         * extension. @data must hold at least #GST_RTP_HDREXT_NTP_56_SIZE bytes.
         * @param data the data to write to
         * @param size the size of @data
         * @param ntptime the NTP time
         * @returns %TRUE on success.
         */
        function rtp_hdrext_set_ntp_56(data: never | null, size: number, ntptime: number): boolean
        /**
         * Writes the NTP time in @ntptime to the format required for the NTP-64 header
         * extension. @data must hold at least #GST_RTP_HDREXT_NTP_64_SIZE bytes.
         * @param data the data to write to
         * @param size the size of @data
         * @param ntptime the NTP time
         * @returns %TRUE on success.
         */
        function rtp_hdrext_set_ntp_64(data: never | null, size: number, ntptime: number): boolean
        /**
         * Get the #GstRTPPayloadInfo for @media and @encoding_name. This function is
         * mostly used to get the default clock-rate and bandwidth for dynamic payload
         * types specified with @media and @encoding name.
         *
         * The search for @encoding_name will be performed in a case insensitive way.
         * @param media the media to find
         * @param encoding_name the encoding name to find
         * @returns a #GstRTPPayloadInfo or NULL when no info could be found.
         */
        function rtp_payload_info_for_name(media: string, encoding_name: string): RTPPayloadInfo | null
        /**
         * Get the #GstRTPPayloadInfo for @payload_type. This function is
         * mostly used to get the default clock-rate and bandwidth for static payload
         * types specified with @payload_type.
         * @param payload_type the payload_type to find
         * @returns a #GstRTPPayloadInfo or NULL when no info could be found.
         */
        function rtp_payload_info_for_pt(payload_type: number): RTPPayloadInfo | null
        /**
         */
        function rtp_source_meta_api_get_type(): GObject.GType
        /**
         */
        function rtp_source_meta_get_info(): Gst.MetaInfo
        const RTCP_MAX_BYE_SSRC_COUNT: 31
        const RTCP_MAX_RB_COUNT: 31
        const RTCP_MAX_SDES: 255
        const RTCP_MAX_SDES_ITEM_COUNT: 31
        const RTCP_REDUCED_SIZE_VALID_MASK: 49400
        const RTCP_VALID_MASK: 57598
        const RTCP_VALID_VALUE: 32968
        const RTCP_VERSION: 2
        const RTP_HDREXT_BASE: "urn:ietf:params:rtp-hdrext:"
        const RTP_HDREXT_ELEMENT_CLASS: "Network/Extension/RTPHeader"
        const RTP_HDREXT_NTP_56: "ntp-56"
        const RTP_HDREXT_NTP_56_SIZE: 7
        const RTP_HDREXT_NTP_64: "ntp-64"
        const RTP_HDREXT_NTP_64_SIZE: 8
        const RTP_HEADER_EXTENSION_URI_METADATA_KEY: "RTP-Header-Extension-URI"
        const RTP_PAYLOAD_1016_STRING: "1"
        const RTP_PAYLOAD_CELLB_STRING: "25"
        const RTP_PAYLOAD_CN_STRING: "13"
        const RTP_PAYLOAD_DVI4_11025_STRING: "16"
        const RTP_PAYLOAD_DVI4_16000_STRING: "6"
        const RTP_PAYLOAD_DVI4_22050_STRING: "17"
        const RTP_PAYLOAD_DVI4_8000_STRING: "5"
        const RTP_PAYLOAD_DYNAMIC_STRING: "[96, 127]"
        const RTP_PAYLOAD_G721_STRING: "2"
        const RTP_PAYLOAD_G722_STRING: "9"
        const RTP_PAYLOAD_G723_53: 17
        const RTP_PAYLOAD_G723_53_STRING: "17"
        const RTP_PAYLOAD_G723_63: 16
        const RTP_PAYLOAD_G723_63_STRING: "16"
        const RTP_PAYLOAD_G723_STRING: "4"
        const RTP_PAYLOAD_G728_STRING: "15"
        const RTP_PAYLOAD_G729_STRING: "18"
        const RTP_PAYLOAD_GSM_STRING: "3"
        const RTP_PAYLOAD_H261_STRING: "31"
        const RTP_PAYLOAD_H263_STRING: "34"
        const RTP_PAYLOAD_JPEG_STRING: "26"
        const RTP_PAYLOAD_L16_MONO_STRING: "11"
        const RTP_PAYLOAD_L16_STEREO_STRING: "10"
        const RTP_PAYLOAD_LPC_STRING: "7"
        const RTP_PAYLOAD_MP2T_STRING: "33"
        const RTP_PAYLOAD_MPA_STRING: "14"
        const RTP_PAYLOAD_MPV_STRING: "32"
        const RTP_PAYLOAD_NV_STRING: "28"
        const RTP_PAYLOAD_PCMA_STRING: "8"
        const RTP_PAYLOAD_PCMU_STRING: "0"
        const RTP_PAYLOAD_QCELP_STRING: "12"
        const RTP_PAYLOAD_TS41: 19
        const RTP_PAYLOAD_TS41_STRING: "19"
        const RTP_PAYLOAD_TS48: 18
        const RTP_PAYLOAD_TS48_STRING: "18"
        const RTP_SOURCE_META_MAX_CSRC_COUNT: 15
        const RTP_VERSION: 2
        
        namespace RTCPFBType {
            const $gtype: GObject.GType<RTCPFBType>
        }

        /**
         * Different types of feedback messages.
         */
        enum RTCPFBType {
            /**
             * Invalid type
             */
            "FB_TYPE_INVALID" = 0,
            /**
             * Generic NACK
             */
            "RTPFB_TYPE_NACK" = 1,
            /**
             * Temporary Maximum Media Stream Bit Rate Request
             */
            "RTPFB_TYPE_TMMBR" = 3,
            /**
             * Temporary Maximum Media Stream Bit Rate
             *    Notification
             */
            "RTPFB_TYPE_TMMBN" = 4,
            /**
             * Request an SR packet for early
             *    synchronization
             */
            "RTPFB_TYPE_RTCP_SR_REQ" = 5,
            /**
             */
            "RTPFB_TYPE_TWCC" = 15,
            /**
             * Picture Loss Indication
             */
            "PSFB_TYPE_PLI" = 1,
            /**
             * Slice Loss Indication
             */
            "PSFB_TYPE_SLI" = 2,
            /**
             * Reference Picture Selection Indication
             */
            "PSFB_TYPE_RPSI" = 3,
            /**
             * Application layer Feedback
             */
            "PSFB_TYPE_AFB" = 15,
            /**
             * Full Intra Request Command
             */
            "PSFB_TYPE_FIR" = 4,
            /**
             * Temporal-Spatial Trade-off Request
             */
            "PSFB_TYPE_TSTR" = 5,
            /**
             * Temporal-Spatial Trade-off Notification
             */
            "PSFB_TYPE_TSTN" = 6,
            /**
             * Video Back Channel Message
             */
            "PSFB_TYPE_VBCN" = 7,
        }
        
        namespace RTCPSDESType {
            const $gtype: GObject.GType<RTCPSDESType>
        }

        /**
         * Different types of SDES content.
         */
        enum RTCPSDESType {
            /**
             * Invalid SDES entry
             */
            "INVALID" = -1,
            /**
             * End of SDES list
             */
            "END" = 0,
            /**
             * Canonical name
             */
            "CNAME" = 1,
            /**
             * User name
             */
            "NAME" = 2,
            /**
             * User's electronic mail address
             */
            "EMAIL" = 3,
            /**
             * User's phone number
             */
            "PHONE" = 4,
            /**
             * Geographic user location
             */
            "LOC" = 5,
            /**
             * Name of application or tool
             */
            "TOOL" = 6,
            /**
             * Notice about the source
             */
            "NOTE" = 7,
            /**
             * Private extensions
             */
            "PRIV" = 8,
            /**
             * H.323 callable address
             * @since 1.20
             */
            "H323_CADDR" = 9,
            /**
             * Application Specific Identifier (RFC6776)
             * @since 1.20
             */
            "APSI" = 10,
            /**
             * Reporting Group Identifier (RFC8861)
             * @since 1.20
             */
            "RGRP" = 11,
            /**
             * RtpStreamId SDES item (RFC8852).
             * @since 1.20
             */
            "RTP_STREAM_ID" = 12,
            /**
             * RepairedRtpStreamId SDES item (RFC8852).
             * @since 1.20
             */
            "REPAIRED_RTP_STREAM_ID" = 13,
            /**
             * CLUE CaptId (RFC8849)
             * @since 1.20
             */
            "CCID" = 14,
            /**
             * MID SDES item (RFC8843).
             * @since 1.20
             */
            "MID" = 15,
        }
        
        namespace RTCPType {
            const $gtype: GObject.GType<RTCPType>
        }

        /**
         * Different RTCP packet types.
         */
        enum RTCPType {
            /**
             * Invalid type
             */
            "INVALID" = 0,
            /**
             * Sender report
             */
            "SR" = 200,
            /**
             * Receiver report
             */
            "RR" = 201,
            /**
             * Source description
             */
            "SDES" = 202,
            /**
             * Goodbye
             */
            "BYE" = 203,
            /**
             * Application defined
             */
            "APP" = 204,
            /**
             * Transport layer feedback.
             */
            "RTPFB" = 205,
            /**
             * Payload-specific feedback.
             */
            "PSFB" = 206,
            /**
             * Extended report.
             */
            "XR" = 207,
        }
        
        namespace RTCPXRType {
            const $gtype: GObject.GType<RTCPXRType>
        }

        /**
         * Types of RTCP Extended Reports, those are defined in RFC 3611 and other RFCs
         * according to the [IANA registry](https://www.iana.org/assignments/rtcp-xr-block-types/rtcp-xr-block-types.xhtml).
         * @since 1.16
         */
        enum RTCPXRType {
            /**
             * Invalid XR Report Block
             */
            "INVALID" = -1,
            /**
             * Loss RLE Report Block
             */
            "LRLE" = 1,
            /**
             * Duplicate RLE Report Block
             */
            "DRLE" = 2,
            /**
             * Packet Receipt Times Report Block
             */
            "PRT" = 3,
            /**
             * Receiver Reference Time Report Block
             */
            "RRT" = 4,
            /**
             * Delay since the last Receiver Report
             */
            "DLRR" = 5,
            /**
             * Statistics Summary Report Block
             */
            "SSUMM" = 6,
            /**
             * VoIP Metrics Report Block
             */
            "VOIP_METRICS" = 7,
        }
        
        namespace RTPPayload {
            const $gtype: GObject.GType<RTPPayload>
        }

        /**
         * Standard predefined fixed payload types.
         *
         * The official list is at:
         * http://www.iana.org/assignments/rtp-parameters
         *
         * Audio:
         * reserved: 19
         * unassigned: 20-23,
         *
         * Video:
         * unassigned: 24, 27, 29, 30, 35-71, 77-95
         * Reserved for RTCP conflict avoidance: 72-76
         */
        enum RTPPayload {
            /**
             * ITU-T G.711. mu-law audio (RFC 3551)
             */
            "PCMU" = 0,
            /**
             * RFC 3551 says reserved
             */
            "1016" = 1,
            /**
             * RFC 3551 says reserved
             */
            "G721" = 2,
            /**
             * GSM audio
             */
            "GSM" = 3,
            /**
             * ITU G.723.1 audio
             */
            "G723" = 4,
            /**
             * IMA ADPCM wave type (RFC 3551)
             */
            "DVI4_8000" = 5,
            /**
             * IMA ADPCM wave type (RFC 3551)
             */
            "DVI4_16000" = 6,
            /**
             * experimental linear predictive encoding
             */
            "LPC" = 7,
            /**
             * ITU-T G.711 A-law audio (RFC 3551)
             */
            "PCMA" = 8,
            /**
             * ITU-T G.722 (RFC 3551)
             */
            "G722" = 9,
            /**
             * stereo PCM
             */
            "L16_STEREO" = 10,
            /**
             * mono PCM
             */
            "L16_MONO" = 11,
            /**
             *  TIA standard IS-733
             */
            "QCELP" = 12,
            /**
             * Comfort Noise (RFC 3389)
             */
            "CN" = 13,
            /**
             * Audio MPEG 1-3.
             */
            "MPA" = 14,
            /**
             * ITU-T G.728 Speech coder (RFC 3551)
             */
            "G728" = 15,
            /**
             * IMA ADPCM wave type (RFC 3551)
             */
            "DVI4_11025" = 16,
            /**
             * IMA ADPCM wave type (RFC 3551)
             */
            "DVI4_22050" = 17,
            /**
             * ITU-T G.729 Speech coder (RFC 3551)
             */
            "G729" = 18,
            /**
             * See RFC 2029
             */
            "CELLB" = 25,
            /**
             * ISO Standards 10918-1 and 10918-2 (RFC 2435)
             */
            "JPEG" = 26,
            /**
             * nv encoding by Ron Frederick
             */
            "NV" = 28,
            /**
             * ITU-T Recommendation H.261 (RFC 2032)
             */
            "H261" = 31,
            /**
             *  2 (RFC 2250)
             */
            "MPV" = 32,
            /**
             * MPEG-2 transport stream (RFC 2250)
             */
            "MP2T" = 33,
            /**
             * Video H263 (RFC 2190)
             */
            "H263" = 34,
        }
        
        namespace RTPProfile {
            const $gtype: GObject.GType<RTPProfile>
        }

        /**
         * The transfer profile to use.
         * @since 1.6
         */
        enum RTPProfile {
            /**
             * invalid profile
             */
            "UNKNOWN" = 0,
            /**
             * the Audio/Visual profile (RFC 3551)
             */
            "AVP" = 1,
            /**
             * the secure Audio/Visual profile (RFC 3711)
             */
            "SAVP" = 2,
            /**
             * the Audio/Visual profile with feedback (RFC 4585)
             */
            "AVPF" = 3,
            /**
             * the secure Audio/Visual profile with feedback (RFC 5124)
             */
            "SAVPF" = 4,
        }
        
        namespace RTPBufferFlags {
            const $gtype: GObject.GType<RTPBufferFlags>
        }

        /**
         * Additional RTP buffer flags. These flags can potentially be used on any
         * buffers carrying RTP packets.
         *
         * Note that these are only valid for #GstCaps of type: application/x-rtp (x-rtcp).
         * They can conflict with other extended buffer flags.
         * @since 1.10
         */
        enum RTPBufferFlags {
            /**
             * The #GstBuffer was once wrapped
             *           in a retransmitted packet as specified by RFC 4588.
             */
            "RETRANSMISSION" = 1048576,
            /**
             * The packet represents redundant RTP packet.
             *           The flag is used in gstrtpstorage to be able to hold the packetback
             *           and use it only for recovery from packet loss.
             *           Since: 1.14
             */
            "REDUNDANT" = 2097152,
            /**
             * Offset to define more flags.
             */
            "LAST" = 268435456,
        }
        
        namespace RTPBufferMapFlags {
            const $gtype: GObject.GType<RTPBufferMapFlags>
        }

        /**
         * Additional mapping flags for gst_rtp_buffer_map().
         * @since 1.6.1
         */
        enum RTPBufferMapFlags {
            /**
             * Skip mapping and validation of RTP
             *           padding and RTP pad count when present. Useful for buffers where
             *           the padding may be encrypted.
             */
            "SKIP_PADDING" = 65536,
            /**
             * Offset to define more flags
             */
            "LAST" = 16777216,
        }
        
        namespace RTPHeaderExtensionDirection {
            const $gtype: GObject.GType<RTPHeaderExtensionDirection>
        }

        /**
         * Direction to which to apply the RTP Header Extension
         * @since 1.20
         */
        enum RTPHeaderExtensionDirection {
            /**
             * Neither send nor
             * receive RTP Header Extensions
             */
            "INACTIVE" = 0,
            /**
             * Only send RTP Header
             * Extensions @GST_RTP_HEADER_EXTENSION_DIRECTION_RECVONLY: Only
             * receive RTP Header Extensions
             */
            "SENDONLY" = 1,
            /**
             */
            "RECVONLY" = 2,
            /**
             * Send and receive RTP
             * Header Extensions ext
             */
            "SENDRECV" = 3,
            /**
             * RTP header extension
             * direction is inherited from the stream
             */
            "INHERITED" = 4,
        }
        
        namespace RTPHeaderExtensionFlags {
            const $gtype: GObject.GType<RTPHeaderExtensionFlags>
        }

        /**
         * Flags that apply to a RTP Audio/Video header extension.
         * @since 1.20
         */
        enum RTPHeaderExtensionFlags {
            /**
             * The one byte rtp extension header.
             *              1-16 data bytes per extension with a maximum of
             *              14 extension ids in total.
             */
            "ONE_BYTE" = 1,
            /**
             * The two byte rtp extension header.
             *              256 data bytes per extension with a maximum of 255 (or 256
             *              including appbits) extensions in total.
             */
            "TWO_BYTE" = 2,
        }
    }

    export default GstRtp
}