
/// <reference path="./GLib-2.0.d.ts" />
/// <reference path="./GModule-2.0.d.ts" />
/// <reference path="./GObject-2.0.d.ts" />
/// <reference path="./Gst-1.0.d.ts" />
/// <reference path="./GstBase-1.0.d.ts" />
/// <reference path="./GstVideo-1.0.d.ts" />

/**
 * Type Definitions for GJS (https://gjs.guide/), generated by [GirGen](https://github.com/aylur/girgen)
 * If you found a bug, create a bug report on [GirGen's Repository](https://github.com/aylur/girgen/issues/new)
 */
declare module "gi://GstVa?version=1.0" {
    import type GLib from "gi://GLib?version=2.0"
    import type GModule from "gi://GModule?version=2.0"
    import type GObject from "gi://GObject?version=2.0"
    import type Gst from "gi://Gst?version=1.0"
    import type GstBase from "gi://GstBase?version=1.0"
    import type GstVideo from "gi://GstVideo?version=1.0"

    


    namespace GstVa {
        const __name__: "GstVa"
        const __version: "1.0"
        

        namespace VaAllocator {
            interface SignalSignatures extends Gst.Allocator.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Allocator.ReadableProperties {
            }

            interface WritableProperties extends Gst.Allocator.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.Allocator.ConstructOnlyProperties {
            }
        }

        /**
         * There are two types of VA allocators:
         *
         * * #GstVaAllocator
         * * #GstVaDmabufAllocator
         * @since 1.22
         */
        interface VaAllocator extends Gst.Allocator {
            readonly $signals: VaAllocator.SignalSignatures
            readonly $readableProperties: VaAllocator.ReadableProperties
            readonly $writableProperties: VaAllocator.WritableProperties
            readonly $constructOnlyProperties: VaAllocator.ConstructOnlyProperties
        }

        interface VaAllocatorClass extends Omit<Gst.AllocatorClass, "new"> {
            readonly $gtype: GObject.GType<VaAllocator>
            readonly prototype: VaAllocator
            new (props?: Partial<GObject.ConstructorProps<VaAllocator>>): VaAllocator
            /**
             * Instanciate a new pooled #GstAllocator backed by VASurfaceID.
             * @since 1.22
             * @param display a #GstVaDisplay
             * @param surface_formats a #GArray
                of valid #GstVideoFormat for surfaces in current VA context.
             * @returns a #GstVaDisplay
             */
            "new"(display: VaDisplay, surface_formats: number[]): Gst.Allocator
            /**
             * Allocate a new VASurfaceID backed #GstMemory.
             * @since 1.22
             * @param allocator a #GstAllocator
             * @returns a #GstMemory backed with a VASurfaceID; %NULL, otherwise.
             */
            alloc(allocator: Gst.Allocator): Gst.Memory
            /**
             * Removes all the memories in @allocator's pool.
             * @since 1.22
             * @param allocator a #GstAllocator
             */
            flush(allocator: Gst.Allocator): void
            /**
             * Gets current internal configuration of @allocator.
             * @since 1.22
             * @param allocator a #GstAllocator
             * @returns %TRUE if `allocator` is already configured; %FALSE otherwise., a #GstVideoInfo, VA usage hint, whether derived images are used for buffer     mapping.
             */
            get_format(allocator: Gst.Allocator): boolean
            /**
             * @since 1.22
             * @param allocator a #GstAllocator
             * @returns the display which this     `allocator` belongs to. The reference of the display is unchanged.
             */
            peek_display(allocator: Gst.Allocator): VaDisplay
            /**
             * This method will populate @buffer with pooled VASurfaceID
             * memories. It doesn't allocate new VASurfacesID.
             * @since 1.22
             * @param allocator a #GstAllocator
             * @param buffer an empty #GstBuffer
             * @returns %TRUE if `buffer` was populated correctly; %FALSE otherwise.
             */
            prepare_buffer(allocator: Gst.Allocator, buffer: Gst.Buffer): boolean
            /**
             * Sets the configuration defined by @info, @usage_hint and
             * @use_derived for @allocator, and it tries the configuration, if
             * @allocator has not allocated memories yet.
             *
             * If @allocator has memory allocated already, and frame size and
             * format in @info are the same as currently configured in @allocator,
             * the rest of @info parameters are updated internally.
             * @since 1.22
             * @param allocator a #GstAllocator
             * @param usage_hint VA usage hint
             * @param feat_use_derived a #GstVaFeature
             * @returns %TRUE if the configuration is valid or updated; %FALSE if configuration is not valid or not updated., a #GstVideoInfo
             */
            set_format(allocator: Gst.Allocator, usage_hint: number, feat_use_derived: VaFeature): [boolean, GstVideo.VideoInfo]
            /**
             * Populates an empty @buffer with a VASuface backed #GstMemory.
             * @since 1.22
             * @param allocator a #GstAllocator
             * @param buffer a #GstBuffer
             * @returns %TRUE if `buffer` is populated; %FALSE otherwise.
             */
            setup_buffer(allocator: Gst.Allocator, buffer: Gst.Buffer): boolean
        }

        const VaAllocator: VaAllocatorClass
        

        namespace VaDisplay {
            interface SignalSignatures extends Gst.Object.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Object.ReadableProperties {
                "description": string
                "va-display": never
            }

            interface WritableProperties extends Gst.Object.WritableProperties {
                "description": string
                "va-display": never
            }

            interface ConstructOnlyProperties extends Gst.Object.ConstructOnlyProperties {
            }
        }

        /**
         * It is a generic wrapper for VADisplay. To create new instances
         * subclasses are required, depending on the display type to use
         * (v.gr. DRM, X11, Wayland, etc.).
         *
         * The purpose of this class is to be shared among pipelines via
         * #GstContext so all the VA processing elements will use the same
         * display entry. Application developers can create their own
         * subclass, based on their display, and shared it via the synced bus
         * message for the application.
         * @since 1.20
         */
        interface VaDisplay extends Gst.Object {
            readonly $signals: VaDisplay.SignalSignatures
            readonly $readableProperties: VaDisplay.ReadableProperties
            readonly $writableProperties: VaDisplay.WritableProperties
            readonly $constructOnlyProperties: VaDisplay.ConstructOnlyProperties
            /**
             * @default NULL
             */
            get description(): string
            set description(value: string)
            /**
             */
            get vaDisplay(): never
            set vaDisplay(value: never)
            /**
             * @since 1.24
             * @param major major version to check
             * @param minor minor version to check
             * @returns whether driver version is equal or greater than `major`.@minor
             */
            check_version(major: number, minor: number): boolean
            /**
             * Get the the #GstVaImplementation type of @self.
             * @since 1.20
             * @returns #GstVaImplementation.
             */
            get_implementation(): VaImplementation
            /**
             * Get the VA display handle of the @self.
             * @since 1.20
             * @returns the VA display handle.
             */
            get_va_dpy(): never | null
            /**
             * If the display is set by the user (foreign) it is assumed that the
             * driver is already initialized, thus this function is noop.
             *
             * If the display is opened internally, this function will initialize
             * the driver and it will set driver's message callbacks.
             *
             * NOTE: this function is supposed to be private, only used by
             * GstVaDisplay descendants.
             * @since 1.20
             * @returns %TRUE if the VA driver can be initialized; %FALSE     otherwise
             */
            initialize(): boolean
            /**
             * This is called when the subclass has to create the internal
             * VADisplay.
             * @returns The created VADisplay
             */
            vfunc_create_va_display(): never | null
        }

        interface VaDisplayClass extends Omit<Gst.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<VaDisplay>
            readonly prototype: VaDisplay
            new (props?: Partial<GObject.ConstructorProps<VaDisplay>>): VaDisplay
        }

        const VaDisplay: VaDisplayClass
        

        namespace VaDisplayDrm {
            interface SignalSignatures extends VaDisplay.SignalSignatures {
            }

            interface ReadableProperties extends VaDisplay.ReadableProperties {
                "path": string
            }

            interface WritableProperties extends VaDisplay.WritableProperties {
                "path": string
            }

            interface ConstructOnlyProperties extends VaDisplay.ConstructOnlyProperties {
            }
        }

        /**
         * This is a #GstVaDisplay subclass to instantiate with DRM devices.
         * @since 1.20
         */
        interface VaDisplayDrm extends VaDisplay {
            readonly $signals: VaDisplayDrm.SignalSignatures
            readonly $readableProperties: VaDisplayDrm.ReadableProperties
            readonly $writableProperties: VaDisplayDrm.WritableProperties
            readonly $constructOnlyProperties: VaDisplayDrm.ConstructOnlyProperties
            /**
             * @default /dev/dri/renderD128
             */
            get path(): string
            set path(value: string)
        }

        interface VaDisplayDrmClass extends Omit<VaDisplayClass, "new"> {
            readonly $gtype: GObject.GType<VaDisplayDrm>
            readonly prototype: VaDisplayDrm
            new (props?: Partial<GObject.ConstructorProps<VaDisplayDrm>>): VaDisplayDrm
            /**
             * Creates a new #GstVaDisplay from a DRM device . It will try to open
             * and operate the device in @path.
             * @since 1.20
             * @param path the path to the DRM device
             * @returns a newly allocated #GstVaDisplay if the     specified DRM render device could be opened and initialized;     otherwise %NULL is returned.
             */
            new_from_path(path: string): VaDisplay
        }

        const VaDisplayDrm: VaDisplayDrmClass
        

        namespace VaDisplayWrapped {
            interface SignalSignatures extends VaDisplay.SignalSignatures {
            }

            interface ReadableProperties extends VaDisplay.ReadableProperties {
            }

            interface WritableProperties extends VaDisplay.WritableProperties {
            }

            interface ConstructOnlyProperties extends VaDisplay.ConstructOnlyProperties {
            }
        }

        /**
         * This is a #GstVaDisplay instantiaton subclass for custom created
         * VADisplay, such as X11 or Wayland, wrapping it.
         * @since 1.20
         */
        interface VaDisplayWrapped extends VaDisplay {
            readonly $signals: VaDisplayWrapped.SignalSignatures
            readonly $readableProperties: VaDisplayWrapped.ReadableProperties
            readonly $writableProperties: VaDisplayWrapped.WritableProperties
            readonly $constructOnlyProperties: VaDisplayWrapped.ConstructOnlyProperties
        }

        interface VaDisplayWrappedClass extends Omit<VaDisplayClass, "new"> {
            readonly $gtype: GObject.GType<VaDisplayWrapped>
            readonly prototype: VaDisplayWrapped
            new (props?: Partial<GObject.ConstructorProps<VaDisplayWrapped>>): VaDisplayWrapped
            /**
             * Creates a #GstVaDisplay wrapping an already created and initialized
             * VADisplay.
             *
             * The lifetime of @handle must be hold by the provider while the
             * pipeline is instantiated. Do not call vaTerminate on it while the
             * pipeline is not in NULL state.
             * @since 1.20
             * @param handle a VADisplay to wrap
             * @returns a new #GstVaDisplay if `handle` is valid,     Otherwise %NULL.
             */
            "new"(handle: never | null): VaDisplay
        }

        const VaDisplayWrapped: VaDisplayWrappedClass
        

        namespace VaDmabufAllocator {
            interface SignalSignatures extends Gst.Allocator.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Allocator.ReadableProperties {
            }

            interface WritableProperties extends Gst.Allocator.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.Allocator.ConstructOnlyProperties {
            }
        }

        /**
         * A pooled memory allocator backed by the DMABufs exported from a
         * VASurfaceID. Also it is possible to import DMAbufs into a
         * VASurfaceID.
         * @since 1.22
         */
        interface VaDmabufAllocator extends Gst.Allocator {
            readonly $signals: VaDmabufAllocator.SignalSignatures
            readonly $readableProperties: VaDmabufAllocator.ReadableProperties
            readonly $writableProperties: VaDmabufAllocator.WritableProperties
            readonly $constructOnlyProperties: VaDmabufAllocator.ConstructOnlyProperties
        }

        interface VaDmabufAllocatorClass extends Omit<Gst.AllocatorClass, "new"> {
            readonly $gtype: GObject.GType<VaDmabufAllocator>
            readonly prototype: VaDmabufAllocator
            new (props?: Partial<GObject.ConstructorProps<VaDmabufAllocator>>): VaDmabufAllocator
            /**
             * Instanciate a new pooled allocator backed with both DMABuf and
             * VASurfaceID.
             * @since 1.22
             * @param display a #GstVaDisplay
             * @returns a new allocated #GstAllocator
             */
            "new"(display: VaDisplay): Gst.Allocator
            /**
             * Removes all the memories in @allocator's pool.
             * @since 1.22
             * @param allocator a #GstAllocator
             */
            flush(allocator: Gst.Allocator): void
            /**
             * Gets current internal configuration of @allocator.
             * @since 1.22
             * @param allocator a #GstAllocator
             * @returns %TRUE if `allocator` is already configured; %FALSE otherwise., a #GstVideoInfoDmaDrm, VA usage hint
             */
            get_format(allocator: Gst.Allocator): boolean
            /**
             * This method will populate @buffer with pooled VASurfaceID/DMABuf
             * memories. It doesn't allocate new VASurfacesID.
             * @since 1.22
             * @param allocator a #GstAllocator
             * @param buffer an empty #GstBuffer
             * @returns %TRUE if `buffer` was populated correctly; %FALSE otherwise.
             */
            prepare_buffer(allocator: Gst.Allocator, buffer: Gst.Buffer): boolean
            /**
             * Sets the configuration defined by @info and @usage_hint for
             * @allocator, and it tries the configuration, if @allocator has not
             * allocated memories yet.
             *
             * If @allocator has memory allocated already, and frame size, format
             * and modifier in @info are the same as currently configured in
             * @allocator, the rest of @info parameters are updated internally.
             * @since 1.22
             * @param allocator a #GstAllocator
             * @param usage_hint VA usage hint
             * @returns %TRUE if the configuration is valid or updated; %FALSE if configuration is not valid or not updated., a #GstVideoInfoDmaDrm
             */
            set_format(allocator: Gst.Allocator, usage_hint: number): [boolean, GstVideo.VideoInfoDmaDrm]
            /**
             * This function creates a new VASurfaceID and exposes its DMABufs,
             * later it populates the @buffer with those DMABufs.
             * @since 1.22
             * @param allocator a #GstAllocator
             * @param buffer an empty #GstBuffer
             * @returns %TRUE if `buffer` is populated correctly; %FALSE otherwise.
             */
            setup_buffer(allocator: Gst.Allocator, buffer: Gst.Buffer): boolean
        }

        const VaDmabufAllocator: VaDmabufAllocatorClass
        

        namespace VaPool {
            interface SignalSignatures extends Gst.BufferPool.SignalSignatures {
            }

            interface ReadableProperties extends Gst.BufferPool.ReadableProperties {
            }

            interface WritableProperties extends Gst.BufferPool.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.BufferPool.ConstructOnlyProperties {
            }
        }

        /**
         * @GstVaPool is a buffer pool for VA allocators.
         * @since 1.22
         */
        interface VaPool extends Gst.BufferPool {
            readonly $signals: VaPool.SignalSignatures
            readonly $readableProperties: VaPool.ReadableProperties
            readonly $writableProperties: VaPool.WritableProperties
            readonly $constructOnlyProperties: VaPool.ConstructOnlyProperties
        }

        interface VaPoolClass extends Omit<Gst.BufferPoolClass, "new"> {
            readonly $gtype: GObject.GType<VaPool>
            readonly prototype: VaPool
            new (props?: Partial<GObject.ConstructorProps<VaPool>>): VaPool
            /**
             * @since 1.22
             * @returns A new #GstBufferPool for VA allocators.
             */
            "new"(): Gst.BufferPool
            /**
             * @since 1.22
             * @param caps the #GstCaps of the buffers handled by the new pool.
             * @param min_buffers minimum number of frames to create.
             * @param max_buffers maximum number of frames to create.
             * @param usage_hint VA usage hint
             * @param use_derived a #GstVaFeature for derived mapping (only used when
                VA allocator).
             * @param allocator the VA allocator to use.
             * @param alloc_params #GstAllocationParams to use.
             * @returns a new #GstBufferPool that handles VASurfacesID-backed     buffers. If the pool cannot be configured correctly, %NULL is     returned.
             */
            new_with_config(caps: Gst.Caps, min_buffers: number, max_buffers: number, usage_hint: number, use_derived: VaFeature, allocator: Gst.Allocator, alloc_params: Gst.AllocationParams): Gst.BufferPool
            /**
             * Helper function to retrieve the VA surface size provided by @pool.
             * @since 1.24
             * @param pool a #GstBufferPool
             * @returns whether the surface size was retrieved., the declared surface size
             */
            get_buffer_size(pool: Gst.BufferPool): boolean
            /**
             * Retuns: %TRUE if @pool always add #GstVideoMeta to its
             *     buffers. Otherwise, %FALSE.
             * @since 1.22
             * @param pool the #GstBufferPool
             */
            requires_video_meta(pool: Gst.BufferPool): boolean
        }

        const VaPool: VaPoolClass
        none
        none
        none
        /**
         * Video alignment is not handled as expected by VA since it uses
         * opaque surfaces, not directly mappable memory. Still, decoders
         * might need to request bigger surfaces for coded size rather than
         * display sizes. This method will set the coded size to bufferpool's
         * configuration, out of the typical video aligment.
         * @since 1.20.2
         * @param config the #GstStructure with the pool's configuration.
         * @param align a #GstVideoAlignment
         */
        function buffer_pool_config_set_va_alignment(config: Gst.Structure, align: GstVideo.VideoAlignment): void
        /**
         * Sets the usage hint for the buffers handled by the buffer pool.
         * @since 1.22
         * @param config the #GstStructure with the pool's configuration.
         * @param usage_hint the VA usage hint for new VASurfaceID.
         * @param use_derived a #GstVaFeature for derived mapping (only used when
            VA allocator).
         */
        function buffer_pool_config_set_va_allocation_params(config: Gst.Structure, usage_hint: number, use_derived: VaFeature): void
        /**
         * @since 1.22
         * @param context a #GstContext may contain the display
         * @param type_name a #gchar string of the element type
         * @param render_device_path the #gchar string of render device path
         * @returns whether we find a valid `display` in the `context`, the #GstVaDisplay we get
         */
        function context_get_va_display(context: Gst.Context, type_name: string, render_device_path: string): [boolean, VaDisplay]
        /**
         * Set the @display in the @context
         * @since 1.22
         * @param context a #GstContext
         * @param display the #GstVaDisplay we want to set
         */
        function context_set_va_display(context: Gst.Context, display: VaDisplay): void
        /**
         * Creates a new VASurfaceID with @buffer's allocator and attached it
         * to it.
         *
         * *This method is used only by plugin's internal VA decoder.*
         * @since 1.22
         * @param buffer a #GstBuffer
         * @returns %TRUE if the new VASurfaceID is attached to `buffer`     correctly; %FALSE, otherwise.
         */
        function va_buffer_create_aux_surface(buffer: Gst.Buffer): boolean
        none
        none
        /**
         * @since 1.22
         * @param buffer a #GstBuffer
         * @returns the display which this     `buffer` belongs to. The reference of the display is unchanged.
         */
        function va_buffer_peek_display(buffer: Gst.Buffer): VaDisplay
        /**
         * Query the specified context type name.
         * @since 1.22
         * @param element a #GstElement
         * @param context_type the #gchar string specify the context type name
         */
        function va_context_query(element: Gst.Element, context_type: string): void
        /**
         * Get the underlying modifier for specified @format and @usage_hint.
         * @since 1.24
         * @param display a #GstVaDisplay
         * @param format a #GstVideoFormat
         * @param usage_hint VA usage hint
         * @returns the underlying modifier.
         */
        function va_dmabuf_get_modifier_for_format(display: VaDisplay, format: GstVideo.VideoFormat, usage_hint: number): number
        /**
         * It imports the array of @mem, representing a single frame, into a
         * VASurfaceID and it's attached into every @mem.
         * @since 1.22
         * @param display a #GstVaDisplay
         * @param drm_info a #GstVideoInfoDmaDrm
         * @param mem Memories. One
            per plane.
         * @param fds array of
            DMABuf file descriptors.
         * @param offset array of memory
            offsets.
         * @param usage_hint VA usage hint.
         * @returns %TRUE if frame is imported correctly into a VASurfaceID; %FALSE otherwise.
         */
        function va_dmabuf_memories_setup(display: VaDisplay, drm_info: GstVideo.VideoInfoDmaDrm, mem: Gst.Memory[], fds: never[], offset: number[], usage_hint: number): boolean
        /**
         * Propagate @display by posting it as #GstContext in the pipeline's bus.
         * @since 1.22
         * @param element a #GstElement
         * @param display the #GstVaDisplay to propagate
         */
        function va_element_propagate_display_context(element: Gst.Element, display: VaDisplay): void
        /**
         * Called by the va element to ensure a valid #GstVaDisplay.
         * @since 1.22
         * @param element a #GstElement
         * @param render_device_path the #gchar string of render device path
         * @returns whether a #GstVaDisplay exists in `display_ptr`, The #GstVaDisplay to ensure
         */
        function va_ensure_element_data(element: never | null, render_device_path: string): [boolean, VaDisplay]
        /**
         * Used by elements when processing their pad's queries, propagating
         * element's #GstVaDisplay if the processed query requests it.
         * @since 1.22
         * @param element a #GstElement
         * @param query a #GstQuery to query the context
         * @param display a #GstVaDisplay to answer the query
         * @returns whether we can handle the context query successfully
         */
        function va_handle_context_query(element: Gst.Element, query: Gst.Query, display: VaDisplay): boolean
        /**
         * Called by elements in their #GstElementClass::set_context vmethod.
         * It gets a valid #GstVaDisplay if @context has it.
         * @since 1.22
         * @param element a #GstElement
         * @param context a #GstContext may contain the display
         * @param render_device_path the #gchar string of render device path
         * @returns whether the `display_ptr` could be successfully set to a valid #GstVaDisplay in the `context`, The #GstVaDisplay to set
         */
        function va_handle_set_context(element: Gst.Element, context: Gst.Context, render_device_path: string): [boolean, VaDisplay]
        none
        /**
         * @since 1.22
         * @param mem a #GstMemory
         * @returns the display which     this `mem` belongs to. The reference of the display is unchanged.
         */
        function va_memory_peek_display(mem: Gst.Memory): VaDisplay
        const ALLOCATOR_VASURFACE: "VAMemory"
        const CAPS_FEATURE_MEMORY_VA: "memory:VAMemory"
        const MAP_VA: 131072
        const VA_DISPLAY_HANDLE_CONTEXT_TYPE_STR: "gst.va.display.handle"
        
        namespace VaFeature {
            const $gtype: GObject.GType<VaFeature>
        }

        /**
         * @since 1.22
         */
        enum VaFeature {
            /**
             * The feature is disabled.
             */
            "DISABLED" = 0,
            /**
             * The feature is enabled.
             */
            "ENABLED" = 1,
            /**
             * The feature is enabled automatically.
             */
            "AUTO" = 2,
        }
        
        namespace VaImplementation {
            const $gtype: GObject.GType<VaImplementation>
        }

        /**
         * Types of different VA API implemented drivers. These are the typical and
         * the most widely used VA drivers.
         * @since 1.20
         */
        enum VaImplementation {
            /**
             * The mesa gallium implementation.
             */
            "MESA_GALLIUM" = 0,
            /**
             * The legacy i965 intel implementation.
             */
            "INTEL_I965" = 1,
            /**
             * The iHD intel implementation.
             */
            "INTEL_IHD" = 2,
            /**
             * Other implementation.
             */
            "OTHER" = 3,
            /**
             * Invalid implementation.
             */
            "INVALID" = 4,
        }
    }

    export default GstVa
}