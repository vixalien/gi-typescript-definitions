
/// <reference path="./GLib-2.0.d.ts" />
/// <reference path="./GModule-2.0.d.ts" />
/// <reference path="./GObject-2.0.d.ts" />
/// <reference path="./Gst-1.0.d.ts" />
/// <reference path="./GstBase-1.0.d.ts" />
/// <reference path="./GstVideo-1.0.d.ts" />

/**
 * Type Definitions for GJS (https://gjs.guide/), generated by [GirGen](https://github.com/aylur/girgen)
 * If you found a bug, create a bug report on [GirGen's Repository](https://github.com/aylur/girgen/issues/new)
 */
declare module "gi://GstGL?version=1.0" {
    import type GLib from "gi://GLib?version=2.0"
    import type GModule from "gi://GModule?version=2.0"
    import type GObject from "gi://GObject?version=2.0"
    import type Gst from "gi://Gst?version=1.0"
    import type GstBase from "gi://GstBase?version=1.0"
    import type GstVideo from "gi://GstVideo?version=1.0"

    


    namespace GstGL {
        const __name__: "GstGL"
        const __version: "1.0"
        

        namespace GLBaseFilter {
            interface SignalSignatures extends GstBase.BaseTransform.SignalSignatures {
            }

            interface ReadableProperties extends GstBase.BaseTransform.ReadableProperties {
                "context": GLContext
            }

            interface WritableProperties extends GstBase.BaseTransform.WritableProperties {
                "context": GLContext
            }

            interface ConstructOnlyProperties extends GstBase.BaseTransform.ConstructOnlyProperties {
            }
        }

        /**
         * #GstGLBaseFilter handles the nitty gritty details of retrieving an OpenGL
         * context.  It also provided some wrappers around #GstBaseTransform's
         * `start()`, `stop()` and `set_caps()` virtual methods that ensure an OpenGL
         * context is available and current in the calling thread.
         */
        interface GLBaseFilter extends GstBase.BaseTransform {
            readonly $signals: GLBaseFilter.SignalSignatures
            readonly $readableProperties: GLBaseFilter.ReadableProperties
            readonly $writableProperties: GLBaseFilter.WritableProperties
            readonly $constructOnlyProperties: GLBaseFilter.ConstructOnlyProperties
            /**
             */
            get context(): GLContext
            set context(value: GLContext)
            /**
             * @since 1.16
             * @returns Whether an OpenGL context could be retrieved or created successfully
             */
            find_gl_context(): boolean
            /**
             * @since 1.18
             * @returns the #GstGLContext found by `filter`
             */
            get_gl_context(): GLContext | null
            /**
             * called in the GL thread when caps are set on @filter.
             *               Note: this will also be called when changing OpenGL contexts
             *               where #GstBaseTransform::set_caps may not.
             * @param incaps
             * @param outcaps
             */
            vfunc_gl_set_caps(incaps: Gst.Caps, outcaps: Gst.Caps): boolean
            /**
             * called in the GL thread to setup the element GL state.
             */
            vfunc_gl_start(): boolean
            /**
             * called in the GL thread to setup the element GL state.
             */
            vfunc_gl_stop(): void
        }

        interface GLBaseFilterClass extends Omit<GstBase.BaseTransformClass, "new"> {
            readonly $gtype: GObject.GType<GLBaseFilter>
            readonly prototype: GLBaseFilter
            new (props?: Partial<GObject.ConstructorProps<GLBaseFilter>>): GLBaseFilter
        }

        const GLBaseFilter: GLBaseFilterClass
        

        namespace GLBaseMemoryAllocator {
            interface SignalSignatures extends Gst.Allocator.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Allocator.ReadableProperties {
            }

            interface WritableProperties extends Gst.Allocator.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.Allocator.ConstructOnlyProperties {
            }
        }

        /**
         * Opaque #GstGLBaseMemoryAllocator struct
         * @since 1.8
         */
        interface GLBaseMemoryAllocator extends Gst.Allocator {
            readonly $signals: GLBaseMemoryAllocator.SignalSignatures
            readonly $readableProperties: GLBaseMemoryAllocator.ReadableProperties
            readonly $writableProperties: GLBaseMemoryAllocator.WritableProperties
            readonly $constructOnlyProperties: GLBaseMemoryAllocator.ConstructOnlyProperties
            /**
             * a #GstGLBaseMemoryAllocatorAllocFunction
             * @param params the #GstGLAllocationParams to allocate the memory with
             * @returns a newly allocated #GstGLBaseMemory from `allocator` and `params`
             */
            vfunc_alloc(params: GLAllocationParams): GLBaseMemory | null
        }

        interface GLBaseMemoryAllocatorClass extends Omit<Gst.AllocatorClass, "new"> {
            readonly $gtype: GObject.GType<GLBaseMemoryAllocator>
            readonly prototype: GLBaseMemoryAllocator
            new (props?: Partial<GObject.ConstructorProps<GLBaseMemoryAllocator>>): GLBaseMemoryAllocator
        }

        const GLBaseMemoryAllocator: GLBaseMemoryAllocatorClass
        

        namespace GLBaseMixer {
            interface SignalSignatures extends GstVideo.VideoAggregator.SignalSignatures {
            }

            interface ReadableProperties extends GstVideo.VideoAggregator.ReadableProperties {
                "context": GLContext
            }

            interface WritableProperties extends GstVideo.VideoAggregator.WritableProperties {
                "context": GLContext
            }

            interface ConstructOnlyProperties extends GstVideo.VideoAggregator.ConstructOnlyProperties {
            }
        }

        /**
         * #GstGLBaseMixer handles the nitty gritty details of retrieving an OpenGL
         * context.  It provides some virtual methods to know when the OpenGL context
         * is available and is not available within this element.
         * @since 1.24
         */
        interface GLBaseMixer extends GstVideo.VideoAggregator {
            readonly $signals: GLBaseMixer.SignalSignatures
            readonly $readableProperties: GLBaseMixer.ReadableProperties
            readonly $writableProperties: GLBaseMixer.WritableProperties
            readonly $constructOnlyProperties: GLBaseMixer.ConstructOnlyProperties
            /**
             * The #GstGLContext in use by this #GstGLBaseMixer
             * @since 1.24
             */
            get context(): GLContext
            set context(value: GLContext)
            /**
             * @since 1.24
             * @returns the #GstGLContext found by `mix`
             */
            get_gl_context(): GLContext | null
            /**
             * called in the GL thread to setup the element GL state.
             * @since 1.24
             * @returns whether the start was successful
             */
            vfunc_gl_start(): boolean
            /**
             * called in the GL thread to setup the element GL state.
             * @since 1.24
             */
            vfunc_gl_stop(): void
        }

        interface GLBaseMixerClass extends Omit<GstVideo.VideoAggregatorClass, "new"> {
            readonly $gtype: GObject.GType<GLBaseMixer>
            readonly prototype: GLBaseMixer
            new (props?: Partial<GObject.ConstructorProps<GLBaseMixer>>): GLBaseMixer
        }

        const GLBaseMixer: GLBaseMixerClass
        

        namespace GLBaseMixerPad {
            interface SignalSignatures extends GstVideo.VideoAggregatorPad.SignalSignatures {
            }

            interface ReadableProperties extends GstVideo.VideoAggregatorPad.ReadableProperties {
            }

            interface WritableProperties extends GstVideo.VideoAggregatorPad.WritableProperties {
            }

            interface ConstructOnlyProperties extends GstVideo.VideoAggregatorPad.ConstructOnlyProperties {
            }
        }

        /**
         * @since 1.24
         */
        interface GLBaseMixerPad extends GstVideo.VideoAggregatorPad {
            readonly $signals: GLBaseMixerPad.SignalSignatures
            readonly $readableProperties: GLBaseMixerPad.ReadableProperties
            readonly $writableProperties: GLBaseMixerPad.WritableProperties
            readonly $constructOnlyProperties: GLBaseMixerPad.ConstructOnlyProperties
        }

        interface GLBaseMixerPadClass extends Omit<GstVideo.VideoAggregatorPadClass, "new"> {
            readonly $gtype: GObject.GType<GLBaseMixerPad>
            readonly prototype: GLBaseMixerPad
            new (props?: Partial<GObject.ConstructorProps<GLBaseMixerPad>>): GLBaseMixerPad
        }

        const GLBaseMixerPad: GLBaseMixerPadClass
        

        namespace GLBaseSrc {
            interface SignalSignatures extends GstBase.PushSrc.SignalSignatures {
            }

            interface ReadableProperties extends GstBase.PushSrc.ReadableProperties {
                "timestamp-offset": number
            }

            interface WritableProperties extends GstBase.PushSrc.WritableProperties {
                "timestamp-offset": number
            }

            interface ConstructOnlyProperties extends GstBase.PushSrc.ConstructOnlyProperties {
            }
        }

        /**
         * #GstGLBaseSrc handles the nitty gritty details of retrieving an OpenGL
         * context. It also provided some wrappers around #GstBaseSrc's `start()` and
         * `stop()` virtual methods that ensure an OpenGL context is available and
         * current in the calling thread.
         * @since 1.18
         */
        interface GLBaseSrc extends GstBase.PushSrc {
            readonly $signals: GLBaseSrc.SignalSignatures
            readonly $readableProperties: GLBaseSrc.ReadableProperties
            readonly $writableProperties: GLBaseSrc.WritableProperties
            readonly $constructOnlyProperties: GLBaseSrc.ConstructOnlyProperties
            /**
             * @default 0
             */
            get timestampOffset(): number
            set timestampOffset(value: number)
            /**
             * called in the GL thread to fill the current video texture.
             * @param mem
             */
            vfunc_fill_gl_memory(mem: GLMemory): boolean
            /**
             * called in the GL thread to setup the element GL state.
             */
            vfunc_gl_start(): boolean
            /**
             * called in the GL thread to setup the element GL state.
             */
            vfunc_gl_stop(): void
        }

        interface GLBaseSrcClass extends Omit<GstBase.PushSrcClass, "new"> {
            readonly $gtype: GObject.GType<GLBaseSrc>
            readonly prototype: GLBaseSrc
            new (props?: Partial<GObject.ConstructorProps<GLBaseSrc>>): GLBaseSrc
        }

        const GLBaseSrc: GLBaseSrcClass
        

        namespace GLBufferAllocator {
            interface SignalSignatures extends GLBaseMemoryAllocator.SignalSignatures {
            }

            interface ReadableProperties extends GLBaseMemoryAllocator.ReadableProperties {
            }

            interface WritableProperties extends GLBaseMemoryAllocator.WritableProperties {
            }

            interface ConstructOnlyProperties extends GLBaseMemoryAllocator.ConstructOnlyProperties {
            }
        }

        /**
         * Opaque #GstGLBufferAllocator struct
         */
        interface GLBufferAllocator extends GLBaseMemoryAllocator {
            readonly $signals: GLBufferAllocator.SignalSignatures
            readonly $readableProperties: GLBufferAllocator.ReadableProperties
            readonly $writableProperties: GLBufferAllocator.WritableProperties
            readonly $constructOnlyProperties: GLBufferAllocator.ConstructOnlyProperties
        }

        interface GLBufferAllocatorClass extends Omit<GLBaseMemoryAllocatorClass, "new"> {
            readonly $gtype: GObject.GType<GLBufferAllocator>
            readonly prototype: GLBufferAllocator
            new (props?: Partial<GObject.ConstructorProps<GLBufferAllocator>>): GLBufferAllocator
        }

        const GLBufferAllocator: GLBufferAllocatorClass
        

        namespace GLBufferPool {
            interface SignalSignatures extends Gst.BufferPool.SignalSignatures {
            }

            interface ReadableProperties extends Gst.BufferPool.ReadableProperties {
            }

            interface WritableProperties extends Gst.BufferPool.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.BufferPool.ConstructOnlyProperties {
            }
        }

        /**
         * a #GstGLBufferPool is an object that allocates buffers with #GstGLBaseMemory
         *
         * A #GstGLBufferPool is created with gst_gl_buffer_pool_new()
         *
         * #GstGLBufferPool implements the VideoMeta buffer pool option
         * %GST_BUFFER_POOL_OPTION_VIDEO_META, the VideoAligment buffer pool option
         * %GST_BUFFER_POOL_OPTION_VIDEO_ALIGNMENT as well as the OpenGL specific
         * %GST_BUFFER_POOL_OPTION_GL_SYNC_META buffer pool option.
         */
        interface GLBufferPool extends Gst.BufferPool {
            readonly $signals: GLBufferPool.SignalSignatures
            readonly $readableProperties: GLBufferPool.ReadableProperties
            readonly $writableProperties: GLBufferPool.WritableProperties
            readonly $constructOnlyProperties: GLBufferPool.ConstructOnlyProperties
            /**
             * The returned #GstGLAllocationParams will by %NULL before the first successful
             * call to gst_buffer_pool_set_config().  Subsequent successful calls to
             * gst_buffer_pool_set_config() will cause this function to return a new
             * #GstGLAllocationParams which may or may not contain the same information.
             * @since 1.20
             * @returns a copy of the #GstGLAllocationParams being used by the `pool`
             */
            get_gl_allocation_params(): GLAllocationParams | null
        }

        interface GLBufferPoolClass extends Omit<Gst.BufferPoolClass, "new"> {
            readonly $gtype: GObject.GType<GLBufferPool>
            readonly prototype: GLBufferPool
            new (props?: Partial<GObject.ConstructorProps<GLBufferPool>>): GLBufferPool
            /**
             * @param context the #GstGLContext to use
             * @returns a #GstBufferPool that allocates buffers with #GstGLMemory
             */
            "new"(context: GLContext): GLBufferPool
        }

        const GLBufferPool: GLBufferPoolClass
        

        namespace GLColorConvert {
            interface SignalSignatures extends Gst.Object.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Object.ReadableProperties {
            }

            interface WritableProperties extends Gst.Object.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.Object.ConstructOnlyProperties {
            }
        }

        /**
         * #GstGLColorConvert is an object that converts between color spaces and/or
         * formats using OpenGL Shaders.
         *
         * A #GstGLColorConvert can be created with gst_gl_color_convert_new(), the
         * configuration negotiated with gst_gl_color_convert_transform_caps() and the
         * conversion performed with gst_gl_color_convert_perform().
         *
         * The glcolorconvertelement provides a GStreamer element that uses
         * #GstGLColorConvert to convert between video formats and color spaces.
         */
        interface GLColorConvert extends Gst.Object {
            readonly $signals: GLColorConvert.SignalSignatures
            readonly $readableProperties: GLColorConvert.ReadableProperties
            readonly $writableProperties: GLColorConvert.WritableProperties
            readonly $constructOnlyProperties: GLColorConvert.ConstructOnlyProperties
            /**
             * Provides an implementation of #GstBaseTransformClass.decide_allocation()
             * @since 1.8
             * @param query a completed ALLOCATION #GstQuery
             * @returns whether the allocation parameters were successfully chosen
             */
            decide_allocation(query: Gst.Query): boolean
            /**
             * Converts the data contained by @inbuf using the formats specified by the
             * #GstCaps passed to gst_gl_color_convert_set_caps()
             * @since 1.4
             * @param inbuf the #GstGLMemory filled #GstBuffer to convert
             * @returns a converted #GstBuffer or %NULL
             */
            perform(inbuf: Gst.Buffer): Gst.Buffer | null
            /**
             * Initializes @convert with the information required for conversion.
             * @since 1.6
             * @param in_caps input #GstCaps
             * @param out_caps output #GstCaps
             */
            set_caps(in_caps: Gst.Caps, out_caps: Gst.Caps): boolean
        }

        interface GLColorConvertClass extends Omit<Gst.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<GLColorConvert>
            readonly prototype: GLColorConvert
            new (props?: Partial<GObject.ConstructorProps<GLColorConvert>>): GLColorConvert
            /**
             * @since 1.4
             * @param context a #GstGLContext
             * @returns a new #GstGLColorConvert object
             */
            "new"(context: GLContext): GLColorConvert
            /**
             * Provides an implementation of #GstBaseTransformClass.fixate_caps()
             * @since 1.8
             * @param context a #GstGLContext to use for transforming @caps
             * @param direction a #GstPadDirection
             * @param caps the #GstCaps of @direction
             * @param other the #GstCaps to fixate
             * @returns the fixated #GstCaps
             */
            fixate_caps(context: GLContext, direction: Gst.PadDirection, caps: Gst.Caps, other: Gst.Caps): Gst.Caps
            /**
             * @since 1.24
             * @param context a #GstGLContext
             * @returns a shader string that can be used to swizzle vec components in a GLSL shader.
             */
            swizzle_shader_string(context: GLContext): string
            /**
             * Provides an implementation of #GstBaseTransformClass.transform_caps()
             * @since 1.6
             * @param context a #GstGLContext to use for transforming @caps
             * @param direction a #GstPadDirection
             * @param caps the #GstCaps to transform
             * @param filter a set of filter #GstCaps
             * @returns the converted #GstCaps
             */
            transform_caps(context: GLContext, direction: Gst.PadDirection, caps: Gst.Caps, filter: Gst.Caps): Gst.Caps
            /**
             * The returned glsl function has declaration:
             *
             * `vec3 yuv_to_rgb (vec3 rgb, vec3 offset, vec3 ycoeff, vec3 ucoeff, vec3 vcoeff);`
             *
             * The Y component is placed in the 0th index of the returned value, The U component in the
             * 1st, and the V component in the 2nd.  offset, ycoeff, ucoeff, and vcoeff are the
             * specific coefficients and offset used for the conversion.
             * @since 1.24
             * @param context a #GstGLContext
             * @returns a glsl function that can be used to convert from yuv to rgb
             */
            yuv_to_rgb_shader_string(context: GLContext): string
        }

        const GLColorConvert: GLColorConvertClass
        

        namespace GLContext {
            interface SignalSignatures extends Gst.Object.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Object.ReadableProperties {
            }

            interface WritableProperties extends Gst.Object.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.Object.ConstructOnlyProperties {
            }
        }

        /**
         * #GstGLContext wraps an OpenGL context object in a uniform API.  As a result
         * of the limitation on OpenGL context, this object is not thread safe unless
         * specified and must only be activated in a single thread.
         *
         * Environment variables:
         * - `GST_GL_API`: select which OpenGL API to create and OpenGL context for.
         *                 Depending on the platform, the available values are
         *                 'opengl', 'opengl3' (core profile), and 'gles2'.  See the
         *                 the #GstGLAPI enumeration for more details.
         * - `GST_GL_PLATFORM`: select which OpenGL platform to create an OpenGL
         *                      context with.  Depending on the platform and the
         *                      dependencies available build-time, the available values
         *                      are, 'glx', 'egl', 'cgl', 'wgl', and 'eagl'
         * - `GST_GL_CONFIG`: select the configuration used for creating the OpenGL
         *                    context and OpenGL surface.  Written out as a GstStructure
         *                    that has been serialized to string.  e.g.
         *                    `GST_GL_CONFIG="gst-gl-context-config,red-size=8,green-size=8,blue-size=8,alpha-size=8,depth-size=16"`.
         *                    Not all platforms will support the same level of
         *                    functionality.
         */
        interface GLContext extends Gst.Object {
            readonly $signals: GLContext.SignalSignatures
            readonly $readableProperties: GLContext.ReadableProperties
            readonly $writableProperties: GLContext.WritableProperties
            readonly $constructOnlyProperties: GLContext.ConstructOnlyProperties
            /**
             * (De)activate the OpenGL context represented by this @context.
             *
             * In OpenGL terms, calls eglMakeCurrent or similar with this context and the
             * currently set window.  See gst_gl_context_set_window() for details.
             * @since 1.4
             * @param activate %TRUE to activate, %FALSE to deactivate
             * @returns Whether the activation succeeded
             */
            activate(activate: boolean): boolean
            /**
             * Note: This will always fail for two wrapped #GstGLContext's
             * @since 1.6
             * @param other_context another #GstGLContext
             * @returns whether `context` and `other_context` are able to share OpenGL      resources.
             */
            can_share(other_context: GLContext): boolean
            /**
             * Check for an OpenGL @feature being supported.
             *
             * Note: Most features require that the context be created before it is
             * possible to determine their existence and so will fail if that is not the
             * case.
             * @since 1.4
             * @param feature a platform specific feature
             * @returns Whether `feature` is supported by `context`
             */
            check_feature(feature: string): boolean
            /**
             * Must be called with @context current.
             * @since 1.10
             * @param fbo_target the GL value of the framebuffer target, GL_FRAMEBUFFER,
                         GL_READ_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER
             * @returns whether whether the current framebuffer is complete
             */
            check_framebuffer_status(fbo_target: number): boolean
            /**
             * @since 1.4
             * @param api api type required
             * @param maj major version required
             * @param min minor version required
             * @returns whether OpenGL context implements the required api and specified version.
             */
            check_gl_version(api: GLAPI, maj: number, min: number): boolean
            /**
             * Unbind the current framebuffer
             * @since 1.10
             */
            clear_framebuffer(): void
            /**
             * Clear's the currently set shader from the GL state machine.
             *
             * Note: must be called in the GL thread.
             */
            clear_shader(): void
            /**
             * Creates an OpenGL context with the specified @other_context as a context
             * to share shareable OpenGL objects with.  See the OpenGL specification for
             * what is shared between OpenGL contexts.
             *
             * Since 1.20, the configuration can be overriden with the environment variable
             * `GST_GL_CONFIG` which is a stringified #GstStructure as would be returned
             * from gst_gl_context_get_config().  If `GST_GL_CONFIG` is not set, then the
             * config will be chosen from @other_context by calling
             * gst_gl_context_get_config() on @other_context.  Otherwise, a default
             * configuration is used.
             *
             * Calling gst_gl_context_request_config()) before calling
             * gst_gl_context_create() will override the config from @other_context but
             * will not override the `GST_GL_CONFIG` environment variable.
             *
             * If an error occurs, and @error is not %NULL, then @error will contain
             * details of the error and %FALSE will be returned.
             *
             * Should only be called once.
             * @throws {GLib.Error}
             * @since 1.4
             * @param other_context a #GstGLContext to share OpenGL objects with
             * @returns whether the context could successfully be created
             */
            create(other_context: GLContext | null): boolean
            /**
             * Destroys an OpenGL context.
             *
             * Should only be called after gst_gl_context_create() has been successfully
             * called for this context.
             * @since 1.6
             */
            destroy(): void
            /**
             * Fills @context's info (version, extensions, vtable, etc) from the GL
             * context in the current thread.  Typically used with wrapped contexts to
             * allow wrapped contexts to be used as regular #GstGLContext's.
             * @throws {GLib.Error}
             * @since 1.6
             */
            fill_info(): boolean
            /**
             * Retrieve the OpenGL configuration for this context.  The context must
             * have been successfully created for this function to return a valid value.
             *
             * Not all implementations currently support retrieving the config and will
             * return %NULL when not supported.
             * @since 1.20
             * @returns the configuration chosen for this OpenGL context.
             */
            get_config(): Gst.Structure | null
            /**
             * @since 1.4
             * @returns the #GstGLDisplay associated with this `context`
             */
            get_display(): GLDisplay
            /**
             * Get the currently enabled OpenGL api.
             *
             * The currently available API may be limited by the #GstGLDisplay in use and/or
             * the #GstGLWindow chosen.
             * @since 1.4
             * @returns the available OpenGL api
             */
            get_gl_api(): GLAPI
            /**
             * Gets the backing OpenGL context used by @context.
             * @since 1.4
             * @returns The platform specific backing OpenGL context
             */
            get_gl_context(): never
            /**
             * Gets the OpenGL platform that used by @context.
             * @since 1.4
             * @returns The platform specific backing OpenGL context
             */
            get_gl_platform(): GLPlatform
            /**
             * Get the version of the OpenGL platform (GLX, EGL, etc) used.  Only valid
             * after a call to gst_gl_context_create().
             * @returns , return for the major version, return for the minor version
             */
            get_gl_platform_version(): [number, number]
            /**
             * Returns the OpenGL version implemented by @context.  See
             * gst_gl_context_get_gl_api() for retrieving the OpenGL api implemented by
             * @context.
             * @since 1.4
             * @returns , resulting major version, resulting minor version
             */
            get_gl_version(): [number, number]
            /**
             *
             * void (GSTGLAPI *PFN_glGetIntegerv) (GLenum name, GLint * ret)
             * ]|
             * @since 1.4
             * @param name an opengl function name
             * @returns a function pointer or %NULL
             */
            get_proc_address(name: string): never | null
            /**
             * @since 1.6
             * @returns The #GThread, `context` is current in or NULL
             */
            get_thread(): GLib.Thread | null
            /**
             * @since 1.4
             * @returns the currently set window
             */
            get_window(): GLWindow | null
            /**
             * @since 1.8
             * @returns Whether the #GstGLContext has been shared with another #GstGLContext
             */
            is_shared(): boolean
            /**
             * Set the OpenGL configuration for this context.  The context must not
             * have been created for this function to succeed.  Setting a %NULL
             * @config has the affect of removing any specific configuration request.
             *
             * Not all implementations currently support retrieving the config and this
             * function will return FALSE when not supported.
             *
             * Note that calling this function may cause a subsequent
             * gst_gl_context_create() to fail if @config could not be matched with
             * the platform-specific configuration.
             *
             * Note that the actual config used may be differ from the requested values.
             * @since 1.20
             * @param gl_config a configuration structure for
                        configuring the OpenGL context
             * @returns whether `gl_config` could be successfully set on `context`
             */
            request_config(gl_config: Gst.Structure | null): boolean
            /**
             * Will internally set @context as shared with @share
             * @since 1.8
             * @param share another #GstGLContext
             */
            set_shared_with(share: GLContext): void
            /**
             * Set's the current window on @context to @window.  The window can only be
             * changed before gst_gl_context_create() has been called and the @window is not
             * already running.
             * @since 1.4
             * @param window a #GstGLWindow
             * @returns Whether the window was successfully updated
             */
            set_window(window: GLWindow): boolean
            /**
             * @param version a #GstGLSLVersion
             * @param profile a #GstGLSLProfile
             * @returns Whether `context` supports the combination of `version` with `profile`
             */
            supports_glsl_profile_version(version: GLSLVersion, profile: GLSLProfile): boolean
            /**
             * @since 1.16
             * @param version a #GstGLSLVersion
             * @param profile a #GstGLSLProfile
             * @returns whether `context` supports the 'precision' specifier in GLSL shaders
             */
            supports_precision(version: GLSLVersion, profile: GLSLProfile): boolean
            /**
             * @since 1.16
             * @param version a #GstGLSLVersion
             * @param profile a #GstGLSLProfile
             * @returns whether `context` supports the 'precision highp' specifier in GLSL shaders
             */
            supports_precision_highp(version: GLSLVersion, profile: GLSLProfile): boolean
            /**
             * Swap the front and back buffers on the window attached to @context.
             * This will display the frame on the next refresh cycle.
             */
            swap_buffers(): void
            /**
             * Execute @func in the OpenGL thread of @context with @data
             *
             * MT-safe
             * @since 1.4
             * @param func a #GstGLContextThreadFunc
             */
            thread_add(func: GLContextThreadFunc): void
            /**
             * (De)activate the OpenGL context represented by this @context.
             *
             * In OpenGL terms, calls eglMakeCurrent or similar with this context and the
             * currently set window.  See gst_gl_context_set_window() for details.
             * @since 1.4
             * @param activate %TRUE to activate, %FALSE to deactivate
             * @returns Whether the activation succeeded
             */
            vfunc_activate(activate: boolean): boolean
            /**
             * Check for an OpenGL @feature being supported.
             *
             * Note: Most features require that the context be created before it is
             * possible to determine their existence and so will fail if that is not the
             * case.
             * @since 1.4
             * @param feature a platform specific feature
             * @returns Whether `feature` is supported by `context`
             */
            vfunc_check_feature(feature: string): boolean
            /**
             * choose a format for the framebuffer
             * @throws {GLib.Error}
             */
            vfunc_choose_format(): boolean
            /**
             * create the OpenGL context
             * @throws {GLib.Error}
             * @param gl_api
             * @param other_context
             */
            vfunc_create_context(gl_api: GLAPI, other_context: GLContext): boolean
            /**
             * destroy the OpenGL context
             */
            vfunc_destroy_context(): void
            /**
             * Retrieve the OpenGL configuration for this context.  The context must
             * have been successfully created for this function to return a valid value.
             *
             * Not all implementations currently support retrieving the config and will
             * return %NULL when not supported.
             * @since 1.20
             * @returns the configuration chosen for this OpenGL context.
             */
            vfunc_get_config(): Gst.Structure | null
            /**
             * Get the currently enabled OpenGL api.
             *
             * The currently available API may be limited by the #GstGLDisplay in use and/or
             * the #GstGLWindow chosen.
             * @since 1.4
             * @returns the available OpenGL api
             */
            vfunc_get_gl_api(): GLAPI
            /**
             * Gets the backing OpenGL context used by @context.
             * @since 1.4
             * @returns The platform specific backing OpenGL context
             */
            vfunc_get_gl_context(): never
            /**
             * Gets the OpenGL platform that used by @context.
             * @since 1.4
             * @returns The platform specific backing OpenGL context
             */
            vfunc_get_gl_platform(): GLPlatform
            /**
             * Get the version of the OpenGL platform (GLX, EGL, etc) used.  Only valid
             * after a call to gst_gl_context_create().
             * @returns , return for the major version, return for the minor version
             */
            vfunc_get_gl_platform_version(): [number, number]
            /**
             * Set the OpenGL configuration for this context.  The context must not
             * have been created for this function to succeed.  Setting a %NULL
             * @config has the affect of removing any specific configuration request.
             *
             * Not all implementations currently support retrieving the config and this
             * function will return FALSE when not supported.
             *
             * Note that calling this function may cause a subsequent
             * gst_gl_context_create() to fail if @config could not be matched with
             * the platform-specific configuration.
             *
             * Note that the actual config used may be differ from the requested values.
             * @since 1.20
             * @param gl_config a configuration structure for
                        configuring the OpenGL context
             * @returns whether `gl_config` could be successfully set on `context`
             */
            vfunc_request_config(gl_config: Gst.Structure | null): boolean
            /**
             * Swap the front and back buffers on the window attached to @context.
             * This will display the frame on the next refresh cycle.
             */
            vfunc_swap_buffers(): void
        }

        interface GLContextClass extends Omit<Gst.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<GLContext>
            readonly prototype: GLContext
            new (props?: Partial<GObject.ConstructorProps<GLContext>>): GLContext
            /**
             * Create a new #GstGLContext with the specified @display
             * @since 1.4
             * @param display a #GstGLDisplay
             * @returns a new #GstGLContext
             */
            "new"(display: GLDisplay): GLContext
            /**
             * Wraps an existing OpenGL context into a #GstGLContext.
             *
             * Note: The caller is responsible for ensuring that the OpenGL context
             * represented by @handle stays alive while the returned #GstGLContext is
             * active.
             *
             * @context_type must not be %GST_GL_PLATFORM_NONE or %GST_GL_PLATFORM_ANY
             *
             * @available_apis must not be %GST_GL_API_NONE or %GST_GL_API_ANY
             * @since 1.4
             * @param display a #GstGLDisplay
             * @param handle the OpenGL context to wrap
             * @param context_type a #GstGLPlatform specifying the type of context in @handle
             * @param available_apis a #GstGLAPI containing the available OpenGL apis in @handle
             * @returns a #GstGLContext wrapping `handle`
             */
            new_wrapped(display: GLDisplay, handle: never, context_type: GLPlatform, available_apis: GLAPI): GLContext | null
            /**
             * A default implementation of the various GetProcAddress functions that looks
             * for @name in the OpenGL shared libraries or in the current process.
             *
             * See also: gst_gl_context_get_proc_address()
             * @since 1.4
             * @param gl_api a #GstGLAPI
             * @param name then function to get the address of
             * @returns an address pointing to `name` or %NULL
             */
            default_get_proc_address(gl_api: GLAPI, name: string): never | null
            /**
             * See also gst_gl_context_activate().
             * @since 1.6
             * @returns the #GstGLContext active in the current thread or %NULL
             */
            get_current(): GLContext | null
            /**
             * If an error occurs, @major and @minor are not modified and %GST_GL_API_NONE is
             * returned.
             * @since 1.6
             * @param platform the #GstGLPlatform to retrieve the API for
             * @returns The version supported by the OpenGL context current in the calling          thread or %GST_GL_API_NONE, the major version, the minor version
             */
            get_current_gl_api(platform: GLPlatform): GLAPI
            /**
             * @since 1.6
             * @param context_type a #GstGLPlatform specifying the type of context to retrieve
             * @returns The OpenGL context handle current in the calling thread or %NULL
             */
            get_current_gl_context(context_type: GLPlatform): never | null
            /**
             * Attempts to use the @context_type specific GetProcAddress implementations
             * to retrieve @name.
             *
             * See also gst_gl_context_get_proc_address().
             * @since 1.6
             * @param context_type a #GstGLPlatform
             * @param gl_api a #GstGLAPI
             * @param name the name of the function to retrieve
             * @returns a function pointer for `name`, or %NULL
             */
            get_proc_address_with_platform(context_type: GLPlatform, gl_api: GLAPI, name: string): never | null
        }

        const GLContext: GLContextClass
        

        namespace GLDisplay {
            interface SignalSignatures extends Gst.Object.SignalSignatures {
                /**
                 * Overrides the @GstGLContext creation mechanism.
                 * It can be called in any thread and it is emitted with
                 * display's object lock held.
                 * @param context other context to share resources with.
                 * @returns the new context.
                 */
                "create-context"(context: GLContext): GLContext | null
            }

            interface ReadableProperties extends Gst.Object.ReadableProperties {
            }

            interface WritableProperties extends Gst.Object.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.Object.ConstructOnlyProperties {
            }
        }

        /**
         *  example of such a function is X11's XInitThreads\().
         */
        interface GLDisplay extends Gst.Object {
            readonly $signals: GLDisplay.SignalSignatures
            readonly $readableProperties: GLDisplay.ReadableProperties
            readonly $writableProperties: GLDisplay.WritableProperties
            readonly $constructOnlyProperties: GLDisplay.ConstructOnlyProperties
            /**
             * @since 1.6
             * @param context a #GstGLContext
             * @returns whether `context` was successfully added. %FALSE may be returned if there already exists another context for `context`'s active thread.  Must be called with the object lock held.
             */
            add_context(context: GLContext): boolean
            /**
             * It requires the display's object lock to be held.
             * @throws {GLib.Error}
             * @since 1.6
             * @param other_context other #GstGLContext to share resources with.
             * @returns whether a new context could be created., resulting #GstGLContext
             */
            create_context(other_context: GLContext | null): [boolean, GLContext]
            /**
             * @returns a new #GstGLWindow for `display` or %NULL.
             */
            create_window(): GLWindow | null
            /**
             * Ensures that the display has a valid GL context for the current thread. If
             * @context already contains a valid context, this does nothing.
             * @throws {GLib.Error}
             * @since 1.24
             * @param other_context other #GstGLContext to share resources with.
             * @returns wether `context` contains a valid context., the resulting #GstGLContext
             */
            ensure_context(other_context: GLContext | null): [boolean, GLContext | null]
            /**
             * limit the use of OpenGL to the requested @gl_api.  This is intended to allow
             * application and elements to request a specific set of OpenGL API's based on
             * what they support.  See gst_gl_context_get_gl_api() for the retrieving the
             * API supported by a #GstGLContext.
             * @param gl_api a #GstGLAPI to filter with
             */
            filter_gl_api(gl_api: GLAPI): void
            /**
             * Execute @compare_func over the list of windows stored by @display.  The
             * first argument to @compare_func is the #GstGLWindow being checked and the
             * second argument is @data.
             * @since 1.12
             * @deprecated since 1.18 Use gst_gl_display_retrieve_window() instead.
             * @param compare_func a comparison function to run
             * @returns The first #GstGLWindow that causes a match          from `compare_func`
             */
            find_window(compare_func: GLib.CompareFunc): GLWindow | null
            /**
             * see gst_gl_display_filter_gl_api() for what the returned value represents
             * @returns the #GstGLAPI configured for `display`
             */
            get_gl_api(): GLAPI
            /**
             */
            get_gl_api_unlocked(): GLAPI
            /**
             * @since 1.6
             * @param thread a #GThread
             * @returns the #GstGLContext current on `thread` or %NULL  Must be called with the object lock held.
             */
            get_gl_context_for_thread(thread: GLib.Thread): GLContext | null
            /**
             * @since 1.4
             * @returns the native handle for the display
             */
            get_handle(): never
            /**
             * @since 1.4
             * @returns the #GstGLDisplayType of `display`
             */
            get_handle_type(): GLDisplayType
            /**
             * Must be called with the object lock held.
             * @since 1.18
             * @param context the #GstGLContext to remove
             */
            remove_context(context: GLContext): void
            /**
             * @since 1.12
             * @param window a #GstGLWindow to remove
             * @returns if `window` could be removed from `display`
             */
            remove_window(window: GLWindow): boolean
            /**
             * Execute @compare_func over the list of windows stored by @display.  The
             * first argument to @compare_func is the #GstGLWindow being checked and the
             * second argument is @data.
             * @since 1.18
             * @param compare_func a comparison function to run
             * @returns The first #GstGLWindow that causes a match          from `compare_func`
             */
            retrieve_window(compare_func: GLib.CompareFunc): GLWindow | null
            /**
             * @returns a new #GstGLWindow for `display` or %NULL.
             */
            vfunc_create_window(): GLWindow | null
            /**
             * @since 1.4
             * @returns the native handle for the display
             */
            vfunc_get_handle(): never
        }

        interface GLDisplayClass extends Omit<Gst.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<GLDisplay>
            readonly prototype: GLDisplay
            new (props?: Partial<GObject.ConstructorProps<GLDisplay>>): GLDisplay
            /**
             * @since 1.4
             * @returns a new #GstGLDisplay
             */
            "new"(): GLDisplay
            /**
             * Will always return a #GstGLDisplay of a single type.  This differs from
             * gst_gl_display_new() and the seemingly equivalent call
             * gst_gl_display_new_with_type (GST_GL_DISPLAY_TYPE_ANY) in that the latter
             * may return NULL.
             * @since 1.20
             * @param type #GstGLDisplayType
             * @returns a new #GstGLDisplay or %NULL if `type` is          not supported
             */
            new_with_type(type: GLDisplayType): GLDisplay | null
        }

        const GLDisplay: GLDisplayClass
        

        namespace GLFilter {
            interface SignalSignatures extends GLBaseFilter.SignalSignatures {
            }

            interface ReadableProperties extends GLBaseFilter.ReadableProperties {
            }

            interface WritableProperties extends GLBaseFilter.WritableProperties {
            }

            interface ConstructOnlyProperties extends GLBaseFilter.ConstructOnlyProperties {
            }
        }

        /**
         * #GstGLFilter helps to implement simple OpenGL filter elements taking a
         * single input and producing a single output with a #GstGLFramebuffer
         */
        interface GLFilter extends GLBaseFilter {
            readonly $signals: GLFilter.SignalSignatures
            readonly $readableProperties: GLFilter.ReadableProperties
            readonly $writableProperties: GLFilter.WritableProperties
            readonly $constructOnlyProperties: GLFilter.ConstructOnlyProperties
            /**
             * Render a fullscreen quad using the current GL state.  The only GL state this
             * modifies is the necessary vertex/index buffers and, if necessary, a
             * Vertex Array Object for drawing a fullscreen quad.  Framebuffer state,
             * any shaders, viewport state, etc must be setup by the caller.
             * @since 1.10
             */
            draw_fullscreen_quad(): void
            /**
             * Calls filter_texture vfunc with correctly mapped #GstGLMemorys
             * @since 1.4
             * @param input an input buffer
             * @param output an output buffer
             * @returns whether the transformation succeeded
             */
            filter_texture(input: Gst.Buffer, output: Gst.Buffer): boolean
            /**
             * Transforms @input into @output using @func on through FBO.
             * @since 1.10
             * @param input the input texture
             * @param output the output texture
             * @param func the function to transform @input into @output. called with @data
             * @returns the return value of `func`
             */
            render_to_target(input: GLMemory, output: GLMemory, func: GLFilterRenderFunc): boolean
            /**
             * Transforms @input into @output using @shader with a FBO.
             *
             * See also: gst_gl_filter_render_to_target()
             * @since 1.4
             * @param input the input texture
             * @param output the output texture
             * @param shader the shader to use.
             */
            render_to_target_with_shader(input: GLMemory, output: GLMemory, shader: GLShader): void
            /**
             * perform operations on the input and output buffers.  In general,
             *          you should avoid using this method if at all possible. One valid
             *          use-case for using this is keeping previous buffers for future calculations.
             *          Note: If @filter exists, then @filter_texture is not run
             * @param inbuf
             * @param outbuf
             */
            vfunc_filter(inbuf: Gst.Buffer, outbuf: Gst.Buffer): boolean
            /**
             * Calls filter_texture vfunc with correctly mapped #GstGLMemorys
             * @since 1.4
             * @param input an input buffer
             * @param output an output buffer
             * @returns whether the transformation succeeded
             */
            vfunc_filter_texture(input: GLMemory, output: GLMemory): boolean
            /**
             * perform initialization when the Framebuffer object is created
             */
            vfunc_init_fbo(): boolean
            /**
             * mirror from #GstBaseTransform
             * @param incaps
             * @param outcaps
             */
            vfunc_set_caps(incaps: Gst.Caps, outcaps: Gst.Caps): boolean
            /**
             * Perform sub-class specific modifications of the
             *   caps to be processed between upload on input and before download for output.
             * @param direction
             * @param caps
             * @param filter_caps
             */
            vfunc_transform_internal_caps(direction: Gst.PadDirection, caps: Gst.Caps, filter_caps: Gst.Caps): Gst.Caps
        }

        interface GLFilterClass extends Omit<GLBaseFilterClass, "new"> {
            readonly $gtype: GObject.GType<GLFilter>
            readonly prototype: GLFilter
            new (props?: Partial<GObject.ConstructorProps<GLFilter>>): GLFilter
            /**
             * @param klass
             */
            add_rgba_pad_templates(klass: GLFilterClass): void
        }

        const GLFilter: GLFilterClass
        

        namespace GLFramebuffer {
            interface SignalSignatures extends Gst.Object.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Object.ReadableProperties {
            }

            interface WritableProperties extends Gst.Object.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.Object.ConstructOnlyProperties {
            }
        }

        /**
         * A #GstGLFramebuffer represents and holds an OpenGL framebuffer object with
         * it's associated attachments.
         *
         * A #GstGLFramebuffer can be created with gst_gl_framebuffer_new() or
         * gst_gl_framebuffer_new_with_default_depth() and bound with
         * gst_gl_framebuffer_bind().  Other resources can be bound with
         * gst_gl_framebuffer_attach()
         *
         * Note: OpenGL framebuffers are not shareable resources so cannot be used
         * between multiple OpenGL contexts.
         * @since 1.10
         */
        interface GLFramebuffer extends Gst.Object {
            readonly $signals: GLFramebuffer.SignalSignatures
            readonly $readableProperties: GLFramebuffer.ReadableProperties
            readonly $writableProperties: GLFramebuffer.WritableProperties
            readonly $constructOnlyProperties: GLFramebuffer.ConstructOnlyProperties
            /**
             * attach @mem to @attachment_point
             *
             * Must be called with the same OpenGL context current that @fb was created
             * with.
             * @since 1.10
             * @param attachment_point the OpenGL attachment point to bind @mem to
             * @param mem the memory object to bind to @attachment_point
             */
            attach(attachment_point: number, mem: GLBaseMemory): void
            /**
             * Bind @fb into the current thread
             *
             * Must be called with the same OpenGL context current that @fb was created
             * with.
             * @since 1.10
             */
            bind(): void
            /**
             * Perform the steps necessary to have the output of a glDraw* command in
             * @func update the contents of @mem.
             *
             * Note: this function does not map @mem for writing with OpenGL and that must
             * be done manually by the caller using any of the mapping functions such as
             * gst_memory_map() with the map flags %GST_MAP_WRITE | %GST_MAP_GL.
             *
             * Must be called with the same OpenGL context current that @fb was created
             * with.
             * @since 1.10
             * @param mem the #GstGLMemory to draw to
             * @param func the function to run
             * @returns the result of executing `func`
             */
            draw_to_texture(mem: GLMemory, func: GLFramebufferFunc): boolean
            /**
             * Retrieve the effective dimensions from the current attachments attached to
             * @fb.
             * @since 1.10
             * @returns , output width, output height
             */
            get_effective_dimensions(): void
            /**
             * @since 1.10
             * @returns the OpenGL id for `fb`
             */
            get_id(): number
        }

        interface GLFramebufferClass extends Omit<Gst.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<GLFramebuffer>
            readonly prototype: GLFramebuffer
            new (props?: Partial<GObject.ConstructorProps<GLFramebuffer>>): GLFramebuffer
            /**
             * This function will internally create an OpenGL framebuffer object and must
             * be called on @context's OpenGL thread.
             * @since 1.10
             * @param context a #GstGLContext
             * @returns a new #GstGLFramebuffer
             */
            "new"(context: GLContext): GLFramebuffer
            /**
             * This function will internally create an OpenGL framebuffer object and must
             * be called on @context's OpenGL thread.
             * @since 1.10
             * @param context a #GstGLContext
             * @param width width for the depth buffer
             * @param height for the depth buffer
             * @returns a new #GstGLFramebuffer with a depth buffer of `width` and `height`
             */
            new_with_default_depth(context: GLContext, width: number, height: number): GLFramebuffer
        }

        const GLFramebuffer: GLFramebufferClass
        

        namespace GLMemoryAllocator {
            interface SignalSignatures extends GLBaseMemoryAllocator.SignalSignatures {
            }

            interface ReadableProperties extends GLBaseMemoryAllocator.ReadableProperties {
            }

            interface WritableProperties extends GLBaseMemoryAllocator.WritableProperties {
            }

            interface ConstructOnlyProperties extends GLBaseMemoryAllocator.ConstructOnlyProperties {
            }
        }

        /**
         * Opaque #GstGLMemoryAllocator struct
         */
        interface GLMemoryAllocator extends GLBaseMemoryAllocator {
            readonly $signals: GLMemoryAllocator.SignalSignatures
            readonly $readableProperties: GLMemoryAllocator.ReadableProperties
            readonly $writableProperties: GLMemoryAllocator.WritableProperties
            readonly $constructOnlyProperties: GLMemoryAllocator.ConstructOnlyProperties
        }

        interface GLMemoryAllocatorClass extends Omit<GLBaseMemoryAllocatorClass, "new"> {
            readonly $gtype: GObject.GType<GLMemoryAllocator>
            readonly prototype: GLMemoryAllocator
            new (props?: Partial<GObject.ConstructorProps<GLMemoryAllocator>>): GLMemoryAllocator
            /**
             * @since 1.8
             * @param context a #GstGLContext
             * @returns the default #GstGLMemoryAllocator supported by          `context`
             */
            get_default(context: GLContext): GLMemoryAllocator
        }

        const GLMemoryAllocator: GLMemoryAllocatorClass
        

        namespace GLMemoryPBOAllocator {
            interface SignalSignatures extends GLMemoryAllocator.SignalSignatures {
            }

            interface ReadableProperties extends GLMemoryAllocator.ReadableProperties {
            }

            interface WritableProperties extends GLMemoryAllocator.WritableProperties {
            }

            interface ConstructOnlyProperties extends GLMemoryAllocator.ConstructOnlyProperties {
            }
        }

        /**
         * Opaque #GstGLMemoryPBOAllocator struct
         */
        interface GLMemoryPBOAllocator extends GLMemoryAllocator {
            readonly $signals: GLMemoryPBOAllocator.SignalSignatures
            readonly $readableProperties: GLMemoryPBOAllocator.ReadableProperties
            readonly $writableProperties: GLMemoryPBOAllocator.WritableProperties
            readonly $constructOnlyProperties: GLMemoryPBOAllocator.ConstructOnlyProperties
        }

        interface GLMemoryPBOAllocatorClass extends Omit<GLMemoryAllocatorClass, "new"> {
            readonly $gtype: GObject.GType<GLMemoryPBOAllocator>
            readonly prototype: GLMemoryPBOAllocator
            new (props?: Partial<GObject.ConstructorProps<GLMemoryPBOAllocator>>): GLMemoryPBOAllocator
        }

        const GLMemoryPBOAllocator: GLMemoryPBOAllocatorClass
        

        namespace GLMixer {
            interface SignalSignatures extends GLBaseMixer.SignalSignatures {
            }

            interface ReadableProperties extends GLBaseMixer.ReadableProperties {
            }

            interface WritableProperties extends GLBaseMixer.WritableProperties {
            }

            interface ConstructOnlyProperties extends GLBaseMixer.ConstructOnlyProperties {
            }
        }

        /**
         * #GstGLMixer helps implement an element that operates on RGBA textures.
         * @since 1.24
         */
        interface GLMixer extends GLBaseMixer {
            readonly $signals: GLMixer.SignalSignatures
            readonly $readableProperties: GLMixer.ReadableProperties
            readonly $writableProperties: GLMixer.WritableProperties
            readonly $constructOnlyProperties: GLMixer.ConstructOnlyProperties
            /**
             * @since 1.24
             * @returns (nullable): The #GstGLFramebuffer in use by this `mix`
             */
            get_framebuffer(): GLFramebuffer
            /**
             * Perform processing required and call #GstGLMixerClass::process_textures().
             * Intended for use within implementations of
             * #GstGLMixerClass::process_buffers().
             * @since 1.24
             * @param outbuf output @GstBuffer
             * @returns whether processing of textures succeeded
             */
            process_textures(outbuf: Gst.Buffer): boolean
            /**
             * Perform operations on the input buffers to produce an
             * output buffer.
             * @since 1.24
             * @param outbuf
             */
            vfunc_process_buffers(outbuf: Gst.Buffer): boolean
            /**
             * Perform processing required and call #GstGLMixerClass::process_textures().
             * Intended for use within implementations of
             * #GstGLMixerClass::process_buffers().
             * @since 1.24
             * @param out_tex
             * @returns whether processing of textures succeeded
             */
            vfunc_process_textures(out_tex: GLMemory): boolean
        }

        interface GLMixerClass extends Omit<GLBaseMixerClass, "new"> {
            readonly $gtype: GObject.GType<GLMixer>
            readonly prototype: GLMixer
            new (props?: Partial<GObject.ConstructorProps<GLMixer>>): GLMixer
            /**
             * Adds the default RGBA pad templates to this class.  If you have any special
             * template requirements like a different pad subclass or different supported
             * caps, you should not call this function and add the pad templates yourself
             * manually.
             * @since 1.24
             */
            add_rgba_pad_templates(): void
        }

        const GLMixer: GLMixerClass
        

        namespace GLMixerPad {
            interface SignalSignatures extends GLBaseMixerPad.SignalSignatures {
            }

            interface ReadableProperties extends GLBaseMixerPad.ReadableProperties {
            }

            interface WritableProperties extends GLBaseMixerPad.WritableProperties {
            }

            interface ConstructOnlyProperties extends GLBaseMixerPad.ConstructOnlyProperties {
            }
        }

        /**
         * @since 1.24
         */
        interface GLMixerPad extends GLBaseMixerPad {
            readonly $signals: GLMixerPad.SignalSignatures
            readonly $readableProperties: GLMixerPad.ReadableProperties
            readonly $writableProperties: GLMixerPad.WritableProperties
            readonly $constructOnlyProperties: GLMixerPad.ConstructOnlyProperties
        }

        interface GLMixerPadClass extends Omit<GLBaseMixerPadClass, "new"> {
            readonly $gtype: GObject.GType<GLMixerPad>
            readonly prototype: GLMixerPad
            new (props?: Partial<GObject.ConstructorProps<GLMixerPad>>): GLMixerPad
        }

        const GLMixerPad: GLMixerPadClass
        

        namespace GLOverlayCompositor {
            interface SignalSignatures extends Gst.Object.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Object.ReadableProperties {
                "yinvert": boolean
            }

            interface WritableProperties extends Gst.Object.WritableProperties {
                "yinvert": boolean
            }

            interface ConstructOnlyProperties extends Gst.Object.ConstructOnlyProperties {
            }
        }

        /**
         * Opaque #GstGLOverlayCompositor object
         */
        interface GLOverlayCompositor extends Gst.Object {
            readonly $signals: GLOverlayCompositor.SignalSignatures
            readonly $readableProperties: GLOverlayCompositor.ReadableProperties
            readonly $writableProperties: GLOverlayCompositor.WritableProperties
            readonly $constructOnlyProperties: GLOverlayCompositor.ConstructOnlyProperties
            /**
             * @default FALSE
             */
            get yinvert(): boolean
            set yinvert(value: boolean)
            /**
             */
            draw_overlays(): void
            /**
             */
            free_overlays(): void
            /**
             * @param buf
             */
            upload_overlays(buf: Gst.Buffer): void
        }

        interface GLOverlayCompositorClass extends Omit<Gst.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<GLOverlayCompositor>
            readonly prototype: GLOverlayCompositor
            new (props?: Partial<GObject.ConstructorProps<GLOverlayCompositor>>): GLOverlayCompositor
            /**
             * @param context
             */
            "new"(context: GLContext): GLOverlayCompositor
            /**
             * @param caps
             */
            add_caps(caps: Gst.Caps): Gst.Caps
        }

        const GLOverlayCompositor: GLOverlayCompositorClass
        

        namespace GLRenderbufferAllocator {
            interface SignalSignatures extends GLBaseMemoryAllocator.SignalSignatures {
            }

            interface ReadableProperties extends GLBaseMemoryAllocator.ReadableProperties {
            }

            interface WritableProperties extends GLBaseMemoryAllocator.WritableProperties {
            }

            interface ConstructOnlyProperties extends GLBaseMemoryAllocator.ConstructOnlyProperties {
            }
        }

        /**
         * Opaque #GstGLRenderbufferAllocator struct
         */
        interface GLRenderbufferAllocator extends GLBaseMemoryAllocator {
            readonly $signals: GLRenderbufferAllocator.SignalSignatures
            readonly $readableProperties: GLRenderbufferAllocator.ReadableProperties
            readonly $writableProperties: GLRenderbufferAllocator.WritableProperties
            readonly $constructOnlyProperties: GLRenderbufferAllocator.ConstructOnlyProperties
        }

        interface GLRenderbufferAllocatorClass extends Omit<GLBaseMemoryAllocatorClass, "new"> {
            readonly $gtype: GObject.GType<GLRenderbufferAllocator>
            readonly prototype: GLRenderbufferAllocator
            new (props?: Partial<GObject.ConstructorProps<GLRenderbufferAllocator>>): GLRenderbufferAllocator
        }

        const GLRenderbufferAllocator: GLRenderbufferAllocatorClass
        

        namespace GLSLStage {
            interface SignalSignatures extends Gst.Object.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Object.ReadableProperties {
            }

            interface WritableProperties extends Gst.Object.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.Object.ConstructOnlyProperties {
            }
        }

        /**
         * #GstGLSLStage holds and represents a single OpenGL shader stage.
         */
        interface GLSLStage extends Gst.Object {
            readonly $signals: GLSLStage.SignalSignatures
            readonly $readableProperties: GLSLStage.ReadableProperties
            readonly $writableProperties: GLSLStage.WritableProperties
            readonly $constructOnlyProperties: GLSLStage.ConstructOnlyProperties
            /**
             * @throws {GLib.Error}
             * @since 1.8
             * @returns whether the compilation succeeded
             */
            compile(): boolean
            /**
             * @since 1.8
             * @returns The GL handle for this shader stage
             */
            get_handle(): number
            /**
             * @since 1.8
             * @returns The GLSL profile for the current shader stage
             */
            get_profile(): GLSLProfile
            /**
             * @since 1.8
             * @returns The GL shader type for this shader stage
             */
            get_shader_type(): number
            /**
             * @since 1.8
             * @returns The GLSL version for the current shader stage
             */
            get_version(): GLSLVersion
            /**
             * Replaces the current shader string with @str.
             * @since 1.8
             * @param version a #GstGLSLVersion
             * @param profile a #GstGLSLProfile
             * @param str a GLSL shader string
             */
            set_strings(version: GLSLVersion, profile: GLSLProfile, str: string[]): boolean
        }

        interface GLSLStageClass extends Omit<Gst.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<GLSLStage>
            readonly prototype: GLSLStage
            new (props?: Partial<GObject.ConstructorProps<GLSLStage>>): GLSLStage
            /**
             * @since 1.8
             * @param context a #GstGLContext
             * @param type the GL enum shader stage type
             * @returns a new #GstGLSLStage of the specified `type`
             */
            "new"(context: GLContext, type: number): GLSLStage
            /**
             * @since 1.8
             * @param context a #GstGLContext
             * @returns a new #GstGLSLStage with the default fragment shader
             */
            new_default_fragment(context: GLContext): GLSLStage
            /**
             * @since 1.8
             * @param context a #GstGLContext
             * @returns a new #GstGLSLStage with the default vertex shader
             */
            new_default_vertex(context: GLContext): GLSLStage
            /**
             * @since 1.8
             * @param context a #GstGLContext
             * @param type the GL enum shader stage type
             * @param version the #GstGLSLVersion
             * @param profile the #GstGLSLProfile
             * @param str a shader string
             * @returns a new #GstGLSLStage of the specified `type`
             */
            new_with_string(context: GLContext, type: number, version: GLSLVersion, profile: GLSLProfile, str: string): GLSLStage
            /**
             * @since 1.8
             * @param context a #GstGLContext
             * @param type the GL enum shader stage type
             * @param version the #GstGLSLVersion
             * @param profile the #GstGLSLProfile
             * @param str 
                an array of strings concatted together to produce a shader
             * @returns a new #GstGLSLStage of the specified `type`
             */
            new_with_strings(context: GLContext, type: number, version: GLSLVersion, profile: GLSLProfile, str: string[]): GLSLStage
        }

        const GLSLStage: GLSLStageClass
        

        namespace GLShader {
            interface SignalSignatures extends Gst.Object.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Object.ReadableProperties {
                "linked": boolean
            }

            interface WritableProperties extends Gst.Object.WritableProperties {
                "linked": boolean
            }

            interface ConstructOnlyProperties extends Gst.Object.ConstructOnlyProperties {
            }
        }

        /**
         */
        interface GLShader extends Gst.Object {
            readonly $signals: GLShader.SignalSignatures
            readonly $readableProperties: GLShader.ReadableProperties
            readonly $writableProperties: GLShader.WritableProperties
            readonly $constructOnlyProperties: GLShader.ConstructOnlyProperties
            /**
             * @default FALSE
             */
            get linked(): boolean
            set linked(value: boolean)
            /**
             * Attaches @stage to @shader.  @stage must have been successfully compiled
             * with gst_glsl_stage_compile().
             *
             * Note: must be called in the GL thread
             * @since 1.8
             * @param stage a #GstGLSLStage to attach
             * @returns whether `stage` could be attached to `shader`
             */
            attach(stage: GLSLStage): boolean
            /**
             * Attaches @stage to @shader.  @stage must have been successfully compiled
             * with gst_glsl_stage_compile().
             *
             * Note: must be called in the GL thread
             * @since 1.8
             * @param stage a #GstGLSLStage to attach
             * @returns whether `stage` could be attached to `shader`
             */
            attach_unlocked(stage: GLSLStage): boolean
            /**
             * Bind attribute @name to the specified location @index using
             * `glBindAttributeLocation()`.
             * @param index attribute index to set
             * @param name name of the attribute
             */
            bind_attribute_location(index: number, name: string): void
            /**
             * Bind attribute @name to the specified location @index using
             * `glBindFragDataLocation()`.
             * @param index attribute index to set
             * @param name name of the attribute
             */
            bind_frag_data_location(index: number, name: string): void
            /**
             * Compiles @stage and attaches it to @shader.
             *
             * Note: must be called in the GL thread
             * @throws {GLib.Error}
             * @since 1.8
             * @param stage a #GstGLSLStage to attach
             * @returns whether `stage` could be compiled and attached to `shader`
             */
            compile_attach_stage(stage: GLSLStage): boolean
            /**
             * Detaches @stage from @shader.  @stage must have been successfully attached
             * to @shader with gst_gl_shader_attach() or gst_gl_shader_attach_unlocked().
             *
             * Note: must be called in the GL thread
             * @since 1.8
             * @param stage a #GstGLSLStage to attach
             */
            detach(stage: GLSLStage): void
            /**
             * Detaches @stage from @shader.  @stage must have been successfully attached
             * to @shader with gst_gl_shader_attach() or gst_gl_shader_attach_unlocked().
             *
             * Note: must be called in the GL thread
             * @since 1.8
             * @param stage a #GstGLSLStage to attach
             */
            detach_unlocked(stage: GLSLStage): void
            /**
             * @param name name of the attribute
             * @returns the attribute index for `name` in `shader` or -1 on failure
             */
            get_attribute_location(name: string): number
            /**
             * @since 1.8
             * @returns the GL program handle for this shader
             */
            get_program_handle(): number
            /**
             * Note: must be called in the GL thread
             * @since 1.8
             * @returns whether `shader` has been successfully linked
             */
            is_linked(): boolean
            /**
             * Links the current list of #GstGLSLStage's in @shader.
             *
             * Note: must be called in the GL thread
             * @throws {GLib.Error}
             * @since 1.8
             * @returns whether `shader` could be linked together.
             */
            link(): boolean
            /**
             * Releases the shader and stages.
             *
             * Note: must be called in the GL thread
             * @since 1.8
             */
            release(): void
            /**
             * Releases the shader and stages.
             *
             * Note: must be called in the GL thread
             * @since 1.8
             */
            release_unlocked(): void
            /**
             * Perform `glUniform1f()` for @name on @shader
             * @param name name of the uniform
             * @param value value to set
             */
            set_uniform_1f(name: string, value: number): void
            /**
             * Perform `glUniform1fv()` for @name on @shader
             * @param name name of the uniform
             * @param value values to set
             */
            set_uniform_1fv(name: string, value: number[]): void
            /**
             * Perform `glUniform1i()` for @name on @shader
             * @param name name of the uniform
             * @param value value to set
             */
            set_uniform_1i(name: string, value: number): void
            /**
             * Perform `glUniform1iv()` for @name on @shader
             * @param name name of the uniform
             * @param value values to set
             */
            set_uniform_1iv(name: string, value: number[]): void
            /**
             * Perform `glUniform2f()` for @name on @shader
             * @param name name of the uniform
             * @param v0 first value to set
             * @param v1 second value to set
             */
            set_uniform_2f(name: string, v0: number, v1: number): void
            /**
             * Perform `glUniform2fv()` for @name on @shader
             * @param name name of the uniform
             * @param value values to set
             */
            set_uniform_2fv(name: string, value: number[]): void
            /**
             * Perform `glUniform2i()` for @name on @shader
             * @param name name of the uniform
             * @param v0 first value to set
             * @param v1 second value to set
             */
            set_uniform_2i(name: string, v0: number, v1: number): void
            /**
             * Perform `glUniform2iv()` for @name on @shader
             * @param name name of the uniform
             * @param value values to set
             */
            set_uniform_2iv(name: string, value: number[]): void
            /**
             * Perform `glUniform3f()` for @name on @shader
             * @param name name of the uniform
             * @param v0 first value to set
             * @param v1 second value to set
             * @param v2 third value to set
             */
            set_uniform_3f(name: string, v0: number, v1: number, v2: number): void
            /**
             * Perform `glUniform3fv()` for @name on @shader
             * @param name name of the uniform
             * @param value values to set
             */
            set_uniform_3fv(name: string, value: number[]): void
            /**
             * Perform `glUniform3i()` for @name on @shader
             * @param name name of the uniform
             * @param v0 first value to set
             * @param v1 second value to set
             * @param v2 third value to set
             */
            set_uniform_3i(name: string, v0: number, v1: number, v2: number): void
            /**
             * Perform `glUniform3iv()` for @name on @shader
             * @param name name of the uniform
             * @param value values to set
             */
            set_uniform_3iv(name: string, value: number[]): void
            /**
             * Perform `glUniform4f()` for @name on @shader
             * @param name name of the uniform
             * @param v0 first value to set
             * @param v1 second value to set
             * @param v2 third value to set
             * @param v3 fourth value to set
             */
            set_uniform_4f(name: string, v0: number, v1: number, v2: number, v3: number): void
            /**
             * Perform `glUniform4fv()` for @name on @shader
             * @param name name of the uniform
             * @param value values to set
             */
            set_uniform_4fv(name: string, value: number[]): void
            /**
             * Perform `glUniform4i()` for @name on @shader
             * @param name name of the uniform
             * @param v0 first value to set
             * @param v1 second value to set
             * @param v2 third value to set
             * @param v3 fourth value to set
             */
            set_uniform_4i(name: string, v0: number, v1: number, v2: number, v3: number): void
            /**
             * Perform `glUniform4iv()` for @name on @shader
             * @param name name of the uniform
             * @param value values to set
             */
            set_uniform_4iv(name: string, value: number[]): void
            /**
             * Perform `glUniformMatrix2fv()` for @name on @shader
             * @param name name of the uniform
             * @param count number of 2x2 matrices to set
             * @param transpose transpose the matrix
             * @param value matrix to set
             */
            set_uniform_matrix_2fv(name: string, count: number, transpose: boolean, value: number): void
            /**
             * Perform `glUniformMatrix2x3fv()` for @name on @shader
             * @param name name of the uniform
             * @param count number of 2x3 matrices to set
             * @param transpose transpose the matrix
             * @param value values to set
             */
            set_uniform_matrix_2x3fv(name: string, count: number, transpose: boolean, value: number): void
            /**
             * Perform `glUniformMatrix2x4fv()` for @name on @shader
             * @param name name of the uniform
             * @param count number of 2x4 matrices to set
             * @param transpose transpose the matrix
             * @param value values to set
             */
            set_uniform_matrix_2x4fv(name: string, count: number, transpose: boolean, value: number): void
            /**
             * Perform `glUniformMatrix3fv()` for @name on @shader
             * @param name name of the uniform
             * @param count number of 3x3 matrices to set
             * @param transpose transpose the matrix
             * @param value values to set
             */
            set_uniform_matrix_3fv(name: string, count: number, transpose: boolean, value: number): void
            /**
             * Perform `glUniformMatrix3x2fv()` for @name on @shader
             * @param name name of the uniform
             * @param count number of 3x2 matrices to set
             * @param transpose transpose the matrix
             * @param value values to set
             */
            set_uniform_matrix_3x2fv(name: string, count: number, transpose: boolean, value: number): void
            /**
             * Perform `glUniformMatrix3x4fv()` for @name on @shader
             * @param name name of the uniform
             * @param count number of 3x4 matrices to set
             * @param transpose transpose the matrix
             * @param value values to set
             */
            set_uniform_matrix_3x4fv(name: string, count: number, transpose: boolean, value: number): void
            /**
             * Perform `glUniformMatrix4fv()` for @name on @shader
             * @param name name of the uniform
             * @param count number of 4x4 matrices to set
             * @param transpose transpose the matrix
             * @param value values to set
             */
            set_uniform_matrix_4fv(name: string, count: number, transpose: boolean, value: number): void
            /**
             * Perform `glUniformMatrix4x2fv()` for @name on @shader
             * @param name name of the uniform
             * @param count number of 4x2 matrices to set
             * @param transpose transpose the matrix
             * @param value values to set
             */
            set_uniform_matrix_4x2fv(name: string, count: number, transpose: boolean, value: number): void
            /**
             * Perform `glUniformMatrix4x3fv()` for @name on @shader
             * @param name name of the uniform
             * @param count number of 4x3 matrices to set
             * @param transpose transpose the matrix
             * @param value values to set
             */
            set_uniform_matrix_4x3fv(name: string, count: number, transpose: boolean, value: number): void
            /**
             * Mark's @shader as being used for the next GL draw command.
             *
             * Note: must be called in the GL thread and @shader must have been linked.
             */
            use(): void
        }

        interface GLShaderClass extends Omit<Gst.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<GLShader>
            readonly prototype: GLShader
            new (props?: Partial<GObject.ConstructorProps<GLShader>>): GLShader
            /**
             * Note: must be called in the GL thread
             * @param context a #GstGLContext
             * @returns a new empty `shader`
             */
            "new"(context: GLContext): GLShader
            /**
             * Note: must be called in the GL thread
             * @throws {GLib.Error}
             * @since 1.8
             * @param context a #GstGLContext
             * @returns a default `shader` or %NULL on failure
             */
            new_default(context: GLContext): GLShader
            /**
             * @since 1.16
             * @param context a #GstGLContext
             * @param version a #GstGLSLVersion
             * @param profile a #GstGLSLProfile
             * @returns a passthrough shader string for copying an input external-oes          texture to the output
             */
            string_fragment_external_oes_get_default(context: GLContext, version: GLSLVersion, profile: GLSLProfile): string
            /**
             * @since 1.16
             * @param context a #GstGLContext
             * @param version a #GstGLSLVersion
             * @param profile a #GstGLSLProfile
             * @returns a passthrough shader string for copying an input texture to          the output
             */
            string_fragment_get_default(context: GLContext, version: GLSLVersion, profile: GLSLProfile): string
            /**
             * Generates a shader string that defines the precision of float types in
             * GLSL shaders.  This is particularly needed for fragment shaders in a
             * GLSL ES context where there is no default precision specified.
             *
             * Practically, this will return the string 'precision mediump float'
             * or 'precision highp float' depending on if high precision floats are
             * determined to be supported.
             * @since 1.16
             * @param context a #GstGLContext
             * @param version a #GstGLSLVersion
             * @param profile a #GstGLSLProfile
             * @returns a shader string defining the precision of float types based on      `context`, `version` and `profile`
             */
            string_get_highest_precision(context: GLContext, version: GLSLVersion, profile: GLSLProfile): string
        }

        const GLShader: GLShaderClass
        

        namespace GLUpload {
            interface SignalSignatures extends Gst.Object.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Object.ReadableProperties {
            }

            interface WritableProperties extends Gst.Object.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.Object.ConstructOnlyProperties {
            }
        }

        /**
         * #GstGLUpload is an object that uploads data from system memory into GL textures.
         *
         * A #GstGLUpload can be created with gst_gl_upload_new()
         */
        interface GLUpload extends Gst.Object {
            readonly $signals: GLUpload.SignalSignatures
            readonly $readableProperties: GLUpload.ReadableProperties
            readonly $writableProperties: GLUpload.WritableProperties
            readonly $constructOnlyProperties: GLUpload.ConstructOnlyProperties
            /**
             * Fixate the @othercaps based on the information of the @caps.
             * @since 1.24
             * @param direction the pad #GstPadDirection
             * @param caps a #GstCaps as the reference
             * @param othercaps a #GstCaps to fixate
             * @returns the fixated caps
             */
            fixate_caps(direction: Gst.PadDirection, caps: Gst.Caps, othercaps: Gst.Caps): Gst.Caps
            /**
             * @returns , the input #GstCaps, the output #GstCaps
             */
            get_caps(): void
            /**
             * Uploads @buffer using the transformation specified by
             * gst_gl_upload_set_caps() creating a new #GstBuffer in @outbuf_ptr.
             * @param buffer input #GstBuffer
             * @returns whether the upload was successful, resulting #GstBuffer
             */
            perform_with_buffer(buffer: Gst.Buffer): [GLUploadReturn, Gst.Buffer]
            /**
             * Adds the required allocation parameters to support uploading.
             * @param decide_query a #GstQuery from a decide allocation
             * @param query the proposed allocation query
             */
            propose_allocation(decide_query: Gst.Query | null, query: Gst.Query): void
            /**
             * Initializes @upload with the information required for upload.
             * @param in_caps input #GstCaps
             * @param out_caps output #GstCaps
             * @returns whether `in_caps` and `out_caps` could be set on `upload`
             */
            set_caps(in_caps: Gst.Caps, out_caps: Gst.Caps): boolean
            /**
             * @param context
             */
            set_context(context: GLContext): void
            /**
             * @param context
             * @param direction
             * @param caps
             * @param filter
             */
            transform_caps(context: GLContext, direction: Gst.PadDirection, caps: Gst.Caps, filter: Gst.Caps): Gst.Caps
        }

        interface GLUploadClass extends Omit<Gst.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<GLUpload>
            readonly prototype: GLUpload
            new (props?: Partial<GObject.ConstructorProps<GLUpload>>): GLUpload
            /**
             * @param context a #GstGLContext
             * @returns a new #GstGLUpload object
             */
            "new"(context: GLContext): GLUpload
            /**
             */
            get_input_template_caps(): Gst.Caps
        }

        const GLUpload: GLUploadClass
        

        namespace GLViewConvert {
            interface SignalSignatures extends Gst.Object.SignalSignatures {
            }

            interface ReadableProperties extends Gst.Object.ReadableProperties {
                "downmix-mode": GLStereoDownmix
                "input-flags-override": GstVideo.VideoMultiviewFlags
                "input-mode-override": GstVideo.VideoMultiviewMode
                "output-flags-override": GstVideo.VideoMultiviewFlags
                "output-mode-override": GstVideo.VideoMultiviewMode
            }

            interface WritableProperties extends Gst.Object.WritableProperties {
                "downmix-mode": GLStereoDownmix
                "input-flags-override": GstVideo.VideoMultiviewFlags
                "input-mode-override": GstVideo.VideoMultiviewMode
                "output-flags-override": GstVideo.VideoMultiviewFlags
                "output-mode-override": GstVideo.VideoMultiviewMode
            }

            interface ConstructOnlyProperties extends Gst.Object.ConstructOnlyProperties {
            }
        }

        /**
         * Convert stereoscopic/multiview video using fragment shaders.
         */
        interface GLViewConvert extends Gst.Object {
            readonly $signals: GLViewConvert.SignalSignatures
            readonly $readableProperties: GLViewConvert.ReadableProperties
            readonly $writableProperties: GLViewConvert.WritableProperties
            readonly $constructOnlyProperties: GLViewConvert.ConstructOnlyProperties
            /**
             * @default GST_GL_STEREO_DOWNMIX_ANAGLYPH_GREEN_MAGENTA_DUBOIS
             */
            get downmixMode(): GLStereoDownmix
            set downmixMode(value: GLStereoDownmix)
            /**
             * @default GST_VIDEO_MULTIVIEW_FLAGS_NONE
             */
            get inputFlagsOverride(): GstVideo.VideoMultiviewFlags
            set inputFlagsOverride(value: GstVideo.VideoMultiviewFlags)
            /**
             * @default GST_VIDEO_MULTIVIEW_MODE_NONE
             */
            get inputModeOverride(): GstVideo.VideoMultiviewMode
            set inputModeOverride(value: GstVideo.VideoMultiviewMode)
            /**
             * @default GST_VIDEO_MULTIVIEW_FLAGS_NONE
             */
            get outputFlagsOverride(): GstVideo.VideoMultiviewFlags
            set outputFlagsOverride(value: GstVideo.VideoMultiviewFlags)
            /**
             * @default GST_VIDEO_MULTIVIEW_MODE_NONE
             */
            get outputModeOverride(): GstVideo.VideoMultiviewMode
            set outputModeOverride(value: GstVideo.VideoMultiviewMode)
            /**
             * Provides an implementation of #GstBaseTransformClass.fixate_caps()
             * @since 1.6
             * @param direction a #GstPadDirection
             * @param caps the #GstCaps of @direction
             * @param othercaps the #GstCaps to fixate
             * @returns the fixated #GstCaps
             */
            fixate_caps(direction: Gst.PadDirection, caps: Gst.Caps, othercaps: Gst.Caps): Gst.Caps
            /**
             * Retrieve the processed output buffer placing the output in @outbuf_ptr.
             * @since 1.6
             * @returns a #GstFlowReturn, a #GstBuffer
             */
            get_output(): [Gst.FlowReturn, Gst.Buffer]
            /**
             * Converts the data contained by @inbuf using the formats specified by the
             * #GstCaps passed to gst_gl_view_convert_set_caps()
             * @since 1.6
             * @param inbuf the #GstGLMemory filled #GstBuffer to convert
             * @returns a converted #GstBuffer or %NULL
             */
            perform(inbuf: Gst.Buffer): Gst.Buffer | null
            /**
             * Reset @viewconvert to the default state.  Further operation will require
             * setting the caps with gst_gl_view_convert_set_caps().
             * @since 1.6
             */
            reset(): void
            /**
             * Initializes @viewconvert with the information required for conversion.
             * @since 1.6
             * @param in_caps input #GstCaps
             * @param out_caps output #GstCaps
             */
            set_caps(in_caps: Gst.Caps, out_caps: Gst.Caps): boolean
            /**
             * Set @context on @viewconvert
             * @since 1.6
             * @param context the #GstGLContext to set
             */
            set_context(context: GLContext): void
            /**
             * Submit @input to be processed by @viewconvert
             * @since 1.6
             * @param is_discont true if we have a discontinuity
             * @param input a #GstBuffer
             * @returns a #GstFlowReturn
             */
            submit_input_buffer(is_discont: boolean, input: Gst.Buffer): Gst.FlowReturn
            /**
             * Provides an implementation of #GstBaseTransformClass.transform_caps()
             * @since 1.6
             * @param direction a #GstPadDirection
             * @param caps the #GstCaps to transform
             * @param filter a set of filter #GstCaps
             * @returns the converted #GstCaps
             */
            transform_caps(direction: Gst.PadDirection, caps: Gst.Caps, filter: Gst.Caps): Gst.Caps
        }

        interface GLViewConvertClass extends Omit<Gst.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<GLViewConvert>
            readonly prototype: GLViewConvert
            new (props?: Partial<GObject.ConstructorProps<GLViewConvert>>): GLViewConvert
            /**
             * @since 1.6
             * @returns a new #GstGLViewConvert
             */
            "new"(): GLViewConvert
        }

        const GLViewConvert: GLViewConvertClass
        

        namespace GLWindow {
            interface SignalSignatures extends Gst.Object.SignalSignatures {
                /**
                 * Will be emitted when a key event is received by the GstGLwindow.
                 * @since 1.6
                 * @param id the name of the event
                 * @param key the id of the key pressed
                 */
                "key-event"(id: string, key: string): void
                /**
                 * Will be emitted when a mouse event is received by the GstGLwindow.
                 * @since 1.6
                 * @param id the name of the event
                 * @param button the id of the button
                 * @param x the x coordinate of the mouse event
                 * @param y the y coordinate of the mouse event
                 */
                "mouse-event"(id: string, button: number, x: number, y: number): void
                /**
                 * Will be emitted when a mouse scroll event is received by the GstGLwindow.
                 * @since 1.18
                 * @param x the x coordinate of the mouse event
                 * @param y the y coordinate of the mouse event
                 * @param delta_x the x offset of the scroll event
                 * @param delta_y the y offset of the scroll event
                 */
                "scroll-event"(x: number, y: number, delta_x: number, delta_y: number): void
                /**
                 * Will be emitted when the window handle has been set into the native
                 * implementation, but before the context is re-activated. By using this
                 * signal, elements can refresh associated resource without relying on
                 * direct handle comparision.
                 * @since 1.20
                 */
                "window-handle-changed"(): void
            }

            interface ReadableProperties extends Gst.Object.ReadableProperties {
            }

            interface WritableProperties extends Gst.Object.WritableProperties {
            }

            interface ConstructOnlyProperties extends Gst.Object.ConstructOnlyProperties {
            }
        }

        /**
         * GstGLWindow represents a window that elements can render into.  A window can
         * either be a user visible window (onscreen) or hidden (offscreen).
         */
        interface GLWindow extends Gst.Object {
            readonly $signals: GLWindow.SignalSignatures
            readonly $readableProperties: GLWindow.ReadableProperties
            readonly $writableProperties: GLWindow.WritableProperties
            readonly $constructOnlyProperties: GLWindow.ConstructOnlyProperties
            /**
             * Checks if @window controls the GL viewport.
             * @since 1.16
             * @returns %TRUE if `window` controls the GL viewport, otherwise %FALSE
             */
            controls_viewport(): boolean
            /**
             * Redraw the window contents.  Implementations should invoke the draw callback.
             * @since 1.4
             */
            draw(): void
            /**
             * @since 1.4
             * @returns the #GstGLContext associated with this `window`
             */
            get_context(): GLContext
            /**
             * @since 1.4
             * @returns the windowing system display handle for this `window`
             */
            get_display(): never
            /**
             * @since 1.6
             * @returns , resulting surface width, resulting surface height
             */
            get_surface_dimensions(): [number, number]
            /**
             * @since 1.4
             * @returns the window handle we are currently rendering into
             */
            get_window_handle(): never
            /**
             * Tell a @window that it should handle events from the window system. These
             * events are forwarded upstream as navigation events. In some window systems
             * events are not propagated in the window hierarchy if a client is listening
             * for them. This method allows you to disable events handling completely
             * from the @window.
             * @param handle_events a #gboolean indicating if events should be handled or not.
             */
            handle_events(handle_events: boolean): void
            /**
             * Query whether @window has output surface or not
             * @since 1.18
             * @returns %TRUE if `window` has useable output surface
             */
            has_output_surface(): boolean
            /**
             * Queue resizing of @window.
             */
            queue_resize(): void
            /**
             * Quit the runloop's execution.
             * @since 1.4
             */
            quit(): void
            /**
             * Resize @window to the given @width and @height.
             * @param width new width
             * @param height new height
             */
            resize(width: number, height: number): void
            /**
             * Start the execution of the runloop.
             * @since 1.4
             */
            run(): void
            /**
             * @param event_type
             * @param key_str
             */
            send_key_event(event_type: string, key_str: string): void
            /**
             * Invoke @callback with data on the window thread.  @callback is guaranteed to
             * have executed when this function returns.
             * @since 1.4
             * @param callback function to invoke
             */
            send_message(callback: GLWindowCB): void
            /**
             * Invoke @callback with @data on the window thread.  The callback may not
             * have been executed when this function returns.
             * @since 1.4
             * @param callback function to invoke
             */
            send_message_async(callback: GLWindowCB): void
            /**
             * @param event_type
             * @param button
             * @param posx
             * @param posy
             */
            send_mouse_event(event_type: string, button: number, posx: number, posy: number): void
            /**
             * Notify a @window about a scroll event. A scroll signal holding the event
             * coordinates will be emitted.
             * @since 1.18
             * @param posx x position of the mouse cursor
             * @param posy y position of the mouse cursor
             * @param delta_x the x offset of the scroll event
             * @param delta_y the y offset of the scroll event
             */
            send_scroll_event(posx: number, posy: number, delta_x: number, delta_y: number): void
            /**
             * Sets the callback called when the window is about to close.
             * @since 1.4
             * @param callback function to invoke
             */
            set_close_callback(callback: GLWindowCB): void
            /**
             * Sets the draw callback called every time gst_gl_window_draw() is called
             * @since 1.4
             * @param callback function to invoke
             */
            set_draw_callback(callback: GLWindowCB): void
            /**
             * Set the preferred width and height of the window.  Implementations are free
             * to ignore this information.
             * @since 1.6
             * @param width new preferred width
             * @param height new preferred height
             */
            set_preferred_size(width: number, height: number): void
            /**
             * Tell a @window that it should render into a specific region of the window
             * according to the #GstVideoOverlay interface.
             * @param x x position
             * @param y y position
             * @param width width
             * @param height height
             * @returns whether the specified region could be set
             */
            set_render_rectangle(x: number, y: number, width: number, height: number): boolean
            /**
             * Sets the resize callback called every time a resize of the window occurs.
             * @since 1.4
             * @param callback function to invoke
             */
            set_resize_callback(callback: GLWindowResizeCB): void
            /**
             * Sets the window that this @window should render into.  Some implementations
             * require this to be called with a valid handle before drawing can commence.
             * @since 1.4
             * @param handle handle to the window
             */
            set_window_handle(handle: never): void
            /**
             * Present the window to the screen.
             * @since 1.6
             */
            show(): void
            /**
             * close the connection to the display
             */
            vfunc_close(): void
            /**
             * Checks if @window controls the GL viewport.
             * @since 1.16
             * @returns %TRUE if `window` controls the GL viewport, otherwise %FALSE
             */
            vfunc_controls_viewport(): boolean
            /**
             * Redraw the window contents.  Implementations should invoke the draw callback.
             * @since 1.4
             */
            vfunc_draw(): void
            /**
             * Gets the current windowing system display connection
             * @since 1.4
             * @returns the windowing system display handle for this `window`
             */
            vfunc_get_display(): never
            /**
             * Gets the current window handle that this #GstGLWindow is
             *                     rendering into.  This may return a different value to
             *                     what is passed into @set_window_handle
             * @since 1.4
             * @returns the window handle we are currently rendering into
             */
            vfunc_get_window_handle(): never
            /**
             * Tell a @window that it should handle events from the window system. These
             * events are forwarded upstream as navigation events. In some window systems
             * events are not propagated in the window hierarchy if a client is listening
             * for them. This method allows you to disable events handling completely
             * from the @window.
             * @param handle_events a #gboolean indicating if events should be handled or not.
             */
            vfunc_handle_events(handle_events: boolean): void
            /**
             * Query whether @window has output surface or not
             * @since 1.18
             * @returns %TRUE if `window` has useable output surface
             */
            vfunc_has_output_surface(): boolean
            /**
             * open the connection to the display
             * @throws {GLib.Error}
             */
            vfunc_open(): boolean
            /**
             * Queue resizing of @window.
             */
            vfunc_queue_resize(): void
            /**
             * Quit the runloop's execution.
             * @since 1.4
             */
            vfunc_quit(): void
            /**
             * Start the execution of the runloop.
             * @since 1.4
             */
            vfunc_run(): void
            /**
             * Invoke @callback with data on the window thread.  @callback is guaranteed to
             * have executed when this function returns.
             * @since 1.4
             * @param callback function to invoke
             */
            vfunc_send_message(callback: GLWindowCB): void
            /**
             * Invoke @callback with @data on the window thread.  The callback may not
             * have been executed when this function returns.
             * @since 1.4
             * @param callback function to invoke
             */
            vfunc_send_message_async(callback: GLWindowCB): void
            /**
             * Set the preferred width and height of the window.  Implementations are free
             * to ignore this information.
             * @since 1.6
             * @param width new preferred width
             * @param height new preferred height
             */
            vfunc_set_preferred_size(width: number, height: number): void
            /**
             * Tell a @window that it should render into a specific region of the window
             * according to the #GstVideoOverlay interface.
             * @param x x position
             * @param y y position
             * @param width width
             * @param height height
             * @returns whether the specified region could be set
             */
            vfunc_set_render_rectangle(x: number, y: number, width: number, height: number): boolean
            /**
             * Sets the window that this @window should render into.  Some implementations
             * require this to be called with a valid handle before drawing can commence.
             * @since 1.4
             * @param handle handle to the window
             */
            vfunc_set_window_handle(handle: never): void
            /**
             * Present the window to the screen.
             * @since 1.6
             */
            vfunc_show(): void
        }

        interface GLWindowClass extends Omit<Gst.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<GLWindow>
            readonly prototype: GLWindow
            new (props?: Partial<GObject.ConstructorProps<GLWindow>>): GLWindow
            /**
             * @since 1.4
             * @param display a #GstGLDisplay
             * @returns a new #GstGLWindow using `display`'s connection
             */
            "new"(display: GLDisplay): GLWindow
        }

        const GLWindow: GLWindowClass
        /**
         */
        abstract class GLAllocationParams {
            static readonly $gtype: GObject.GType<GLAllocationParams>

            
            /**
             * the size of the struct (including and subclass data)
             */
            struct_size: number
            /**
             * a #GstGLAllocationParamsCopyFunc
             */
            copy: GLAllocationParamsCopyFunc
            /**
             * a #GstGLAllocationParamsFreeFunc
             */
            free: GLAllocationParamsFreeFunc
            /**
             * allocation flags
             */
            alloc_flags: number
            /**
             * the allocation size
             */
            alloc_size: number
            /**
             * the #GstAllocationParams
             */
            alloc_params: Gst.AllocationParams
            /**
             * a #GstGLContext
             */
            context: GLContext
            /**
             * a #GDestroyNotify
             */
            notify: GLib.DestroyNotify
            /**
             * argument to call @notify with
             */
            user_data: never
            /**
             * the wrapped data pointer
             */
            wrapped_data: never
            /**
             * the wrapped OpenGL handle
             */
            gl_handle: never
            /**
             * @since 1.8
             * @returns a copy of the #GstGLAllocationParams specified by          `src`
             */
            copy(): GLAllocationParams
            /**
             * Copies the dynamically allocated data from @src to @dest.  Direct subclasses
             * should call this function in their own overridden copy function.
             * @since 1.8
             * @param dest the destination #GstGLAllocationParams
             */
            copy_data(dest: GLAllocationParams): void
            /**
             * Frees the #GstGLAllocationParams and all associated data.
             * @since 1.8
             */
            free(): void
            /**
             * Frees the dynamically allocated data in @params.  Direct subclasses
             * should call this function in their own overridden free function.
             * @since 1.8
             */
            free_data(): void
        }
        /**
         * #GstGLAsyncDebug an opaque structure and should only be accessed through the
         * provided API.
         */
        abstract class GLAsyncDebug {
            static readonly $gtype: GObject.GType<GLAsyncDebug>

            
            /**
             * Frees @ad
             * @since 1.8
             */
            free(): void
            /**
             * freeze the debug output.  While frozen, any call to
             * gst_gl_async_debug_output_log_msg() will not output any messages but
             * subsequent calls to gst_gl_async_debug_store_log_msg() will overwrite previous
             * messages.
             * @since 1.8
             */
            freeze(): void
            /**
             * Initialize @ad.  Intended for use with #GstGLAsyncDebug's that are embedded
             * in other structs.
             * @since 1.8
             */
            init(): void
            /**
             * Outputs a previously stored debug message.
             */
            output_log_msg(): void
            /**
             * unfreeze the debug output.  See gst_gl_async_debug_freeze() for what freezing means
             * @since 1.8
             */
            thaw(): void
            /**
             * Unset any dynamically allocated data.  Intended for use with
             * #GstGLAsyncDebug's that are embedded in other structs.
             */
            unset(): void
        }
        none
        /**
         */
        abstract class GLBaseFilterPrivate {
            static readonly $gtype: GObject.GType<GLBaseFilterPrivate>

            
        }
        /**
         * GstGLBaseMemory is a #GstMemory subclass providing the basis of support
         * for the mapping of GL buffers.
         *
         * Data is uploaded or downloaded from the GPU as is necessary.
         */
        abstract class GLBaseMemory {
            static readonly $gtype: GObject.GType<GLBaseMemory>

            
            /**
             * @since 1.8
             * @param allocator a #GstGLBaseMemoryAllocator
             * @param params the #GstGLAllocationParams to allocate the memory with
             * @returns a new #GstGLBaseMemory from `allocator` with the requested `params`.
             */
            static alloc(allocator: GLBaseMemoryAllocator, params: GLAllocationParams): GLBaseMemory | null
            /**
             * Initializes the GL Base Memory allocator. It is safe to call this function
             * multiple times.  This must be called before any other GstGLBaseMemory operation.
             * @since 1.8
             */
            static init_once(): void
            /**
             * the parent object
             */
            mem: Gst.Memory
            /**
             * the #GstGLContext to use for GL operations
             */
            context: GLContext
            /**
             */
            lock: GLib.Mutex
            /**
             */
            map_flags: Gst.MapFlags
            /**
             */
            map_count: number
            /**
             */
            gl_map_count: number
            /**
             */
            data: never
            /**
             */
            query: GLQuery
            /**
             * data,
             * then this function imply returns TRUE.
             * @returns whether the system memory could be allocated
             */
            alloc_data(): boolean
            /**
             * Initializes @mem with the required parameters
             * @since 1.8
             * @param allocator the #GstAllocator to initialize with
             * @param parent the parent #GstMemory to initialize with
             * @param context the #GstGLContext to initialize with
             * @param params the @GstAllocationParams to initialize with
             * @param size the number of bytes to be allocated
             * @param user_data user data to call @notify with
             * @param notify a #GDestroyNotify
             */
            init(allocator: Gst.Allocator, parent: Gst.Memory | null, context: GLContext, params: Gst.AllocationParams | null, size: number, user_data: never | null, notify: GLib.DestroyNotify | null): void
            /**
             * @since 1.8
             * @param dest the destination #GstGLBaseMemory
             * @param offset the offset to start at
             * @param size the number of bytes to copy
             * @returns whether the copy succeeded.
             */
            memcpy(dest: GLBaseMemory, offset: number, size: number): boolean
        }
        none
        none
        none
        /**
         */
        abstract class GLBaseMixerPrivate {
            static readonly $gtype: GObject.GType<GLBaseMixerPrivate>

            
        }
        none
        /**
         */
        abstract class GLBaseSrcPrivate {
            static readonly $gtype: GObject.GType<GLBaseSrcPrivate>

            
        }
        /**
         * GstGLBuffer is a #GstMemory subclass providing support for the mapping of
         * GL buffers.
         *
         * Data is uploaded or downloaded from the GPU as is necessary.
         */
        abstract class GLBuffer {
            static readonly $gtype: GObject.GType<GLBuffer>

            
            /**
             * Initializes the GL Buffer allocator. It is safe to call this function
             * multiple times.  This must be called before any other #GstGLBuffer operation.
             * @since 1.8
             */
            static init_once(): void
            /**
             * the parent object
             */
            mem: GLBaseMemory
            /**
             * the buffer id for this memory
             */
            id: number
            /**
             * the OpenGL target of this texture for binding purposes
             */
            target: number
            /**
             * the OpenGL usage hints this buffer was created with
             */
            usage_hints: number
        }
        /**
         */
        abstract class GLBufferAllocationParams {
            static readonly $gtype: GObject.GType<GLBufferAllocationParams>

            
            /**
             * @since 1.8
             * @param context a #GstGLContext
             * @param alloc_size the size in bytes to allocate
             * @param alloc_params the #GstAllocationParams for @tex_id
             * @param gl_target the OpenGL target to allocate
             * @param gl_usage the OpenGL usage hint to allocate with
             * @returns a new #GstGLBufferAllocationParams for allocating OpenGL buffer          objects
             */
            static "new"(context: GLContext, alloc_size: number, alloc_params: Gst.AllocationParams | null, gl_target: number, gl_usage: number): GLBufferAllocationParams
            /**
             * parent object
             */
            parent: GLAllocationParams
            /**
             * the OpenGL target to bind the buffer to
             */
            gl_target: number
            /**
             * the OpenGL usage hint to create the buffer with
             */
            gl_usage: number
        }
        none
        none
        /**
         */
        abstract class GLBufferPoolPrivate {
            static readonly $gtype: GObject.GType<GLBufferPoolPrivate>

            
        }
        none
        /**
         */
        abstract class GLColorConvertPrivate {
            static readonly $gtype: GObject.GType<GLColorConvertPrivate>

            
        }
        none
        /**
         */
        abstract class GLContextPrivate {
            static readonly $gtype: GObject.GType<GLContextPrivate>

            
        }
        none
        /**
         */
        abstract class GLDisplayPrivate {
            static readonly $gtype: GObject.GType<GLDisplayPrivate>

            
        }
        none
        none
        /**
         */
        abstract class GLFramebufferPrivate {
            static readonly $gtype: GObject.GType<GLFramebufferPrivate>

            
        }
        /**
         * Structure containing function pointers to OpenGL functions.
         *
         * Each field is named exactly the same as the OpenGL function without the
         * `gl` prefix.
         */
        abstract class GLFuncs {
            static readonly $gtype: GObject.GType<GLFuncs>

            
        }
        /**
         * GstGLMemory is a #GstGLBaseMemory subclass providing support for the mapping of
         * OpenGL textures.
         *
         * #GstGLMemory is created or wrapped through gst_gl_base_memory_alloc()
         * with #GstGLVideoAllocationParams.
         *
         * Data is uploaded or downloaded from the GPU as is necessary.
         *
         * The #GstCaps that is used for #GstGLMemory based buffers should contain
         * the %GST_CAPS_FEATURE_MEMORY_GL_MEMORY as a #GstCapsFeatures and should
         * contain a 'texture-target' field with one of the #GstGLTextureTarget values
         * as a string, i.e. some combination of 'texture-target=(string){2D,
         * rectangle, external-oes}'.
         */
        abstract class GLMemory {
            static readonly $gtype: GObject.GType<GLMemory>

            
            /**
             * Initializes the GL Base Texture allocator. It is safe to call this function
             * multiple times.  This must be called before any other GstGLMemory operation.
             * @since 1.4
             */
            static init_once(): void
            /**
             * the parent #GstGLBaseMemory object
             */
            mem: GLBaseMemory
            /**
             * the GL texture id for this memory
             */
            tex_id: number
            /**
             * the GL texture target for this memory
             */
            tex_target: GLTextureTarget
            /**
             * the texture type
             */
            tex_format: GLFormat
            /**
             * the texture's #GstVideoInfo
             */
            info: GstVideo.VideoInfo
            /**
             * data alignment for system memory mapping
             */
            valign: GstVideo.VideoAlignment
            /**
             * data plane in @info
             */
            plane: number
            /**
             * GL shader scaling parameters for @valign and/or width/height
             */
            tex_scaling: number[]
            /**
             */
            texture_wrapped: boolean
            /**
             */
            unpack_length: number
            /**
             */
            tex_width: number
            /**
             * Copies @gl_mem into the texture specified by @tex_id.  The format of @tex_id
             * is specified by @tex_format, @width and @height.
             * @since 1.8
             * @param tex_id OpenGL texture id
             * @param target the #GstGLTextureTarget
             * @param tex_format the #GstGLFormat
             * @param width width of @tex_id
             * @param height height of @tex_id
             * @returns Whether the copy succeeded
             */
            copy_into(tex_id: number, target: GLTextureTarget, tex_format: GLFormat, width: number, height: number): boolean
            /**
             * Copies the texture in #GstGLMemory into the texture specified by @tex_id,
             * @out_target, @out_tex_format, @out_width and @out_height.
             * @since 1.8
             * @param tex_id the destination texture id
             * @param out_target the destination #GstGLTextureTarget
             * @param out_tex_format the destination #GstGLFormat
             * @param out_width the destination width
             * @param out_height the destination height
             * @returns whether the copy succeeded.
             */
            copy_teximage(tex_id: number, out_target: GLTextureTarget, out_tex_format: GLFormat, out_width: number, out_height: number): boolean
            /**
             * @since 1.12
             * @returns the #GstGLFormat of `gl_mem`
             */
            get_texture_format(): GLFormat
            /**
             * @since 1.8
             * @returns the texture height of `gl_mem`
             */
            get_texture_height(): number
            /**
             * @since 1.8
             * @returns the OpenGL texture handle of `gl_mem`
             */
            get_texture_id(): number
            /**
             * @since 1.8
             * @returns the #GstGLTextureTarget of `gl_mem`
             */
            get_texture_target(): GLTextureTarget
            /**
             * @since 1.8
             * @returns the texture width of `gl_mem`
             */
            get_texture_width(): number
            /**
             * Initializes @mem with the required parameters.  @info is assumed to have
             * already have been modified with gst_video_info_align().
             * @since 1.8
             * @param allocator the #GstAllocator to initialize with
             * @param parent the parent #GstMemory to initialize with
             * @param context the #GstGLContext to initialize with
             * @param target the #GstGLTextureTarget for this #GstGLMemory
             * @param tex_format the #GstGLFormat for this #GstGLMemory
             * @param params the @GstAllocationParams to initialize with
             * @param info the #GstVideoInfo for this #GstGLMemory
             * @param plane the plane number (starting from 0) for this #GstGLMemory
             * @param valign optional #GstVideoAlignment parameters
             * @param user_data user data to call @notify with
             * @param notify a #GDestroyNotify
             */
            init(allocator: Gst.Allocator, parent: Gst.Memory | null, context: GLContext, target: GLTextureTarget, tex_format: GLFormat, params: Gst.AllocationParams | null, info: GstVideo.VideoInfo, plane: number, valign: GstVideo.VideoAlignment | null, user_data: never | null, notify: GLib.DestroyNotify | null): void
            /**
             * Reads the texture in #GstGLMemory into @write_pointer if no buffer is bound
             * to `GL_PIXEL_PACK_BUFFER`.  Otherwise @write_pointer is the byte offset into
             * the currently bound `GL_PIXEL_PACK_BUFFER` buffer to store the result of
             * glReadPixels.  See the OpenGL specification for glReadPixels for more
             * details.
             * @since 1.8
             * @param write_pointer the data pointer to pass to glReadPixels
             * @returns whether theread operation succeeded
             */
            read_pixels(write_pointer: never | null): boolean
            /**
             * Reads the texture in @read_pointer into @gl_mem.
             *
             * See gst_gl_memory_read_pixels() for what @read_pointer signifies.
             * @since 1.8
             * @param read_pointer the data pointer to pass to glTexSubImage
             */
            texsubimage(read_pointer: never | null): void
        }
        none
        /**
         * #GstGLMemoryPBO is created or wrapped through gst_gl_base_memory_alloc()
         * with #GstGLVideoAllocationParams.
         *
         * Data is uploaded or downloaded from the GPU as is necessary.
         */
        abstract class GLMemoryPBO {
            static readonly $gtype: GObject.GType<GLMemoryPBO>

            
            /**
             */
            static init_once(): void
            /**
             * Copies @gl_mem into the texture specified by @tex_id.  The format of @tex_id
             * is specified by @tex_format, @width and @height.
             *
             * If @respecify is %TRUE, then the copy is performed in terms of the texture
             * data.  This is useful for splitting RGBA textures into RG or R textures or
             * vice versa. The requirement for this to succeed is that the backing texture
             * data must be the same size, i.e. say a RGBA8 texture is converted into a RG8
             * texture, then the RG texture must have twice as many pixels available for
             * output as the RGBA texture.
             *
             * Otherwise, if @respecify is %FALSE, then the copy is performed per texel
             * using glCopyTexImage.  See the OpenGL specification for details on the
             * mappings between texture formats.
             * @since 1.8
             * @param tex_id the destination texture id
             * @param target the destination #GstGLTextureTarget
             * @param tex_format the destination #GstGLFormat
             * @param width width of @tex_id
             * @param height height of @tex_id
             * @param stride stride of the backing texture data
             * @param respecify whether to copy the data or copy per texel
             * @returns Whether the copy succeeded
             */
            copy_into_texture(tex_id: number, target: GLTextureTarget, tex_format: GLFormat, width: number, height: number, stride: number, respecify: boolean): boolean
            /**
             * Transfer the texture data from the texture into the PBO if necessary.
             * @since 1.8
             */
            download_transfer(): void
            /**
             * Transfer the texture data from the PBO into the texture if necessary.
             * @since 1.8
             */
            upload_transfer(): void
        }
        none
        none
        none
        /**
         */
        abstract class GLMixerPrivate {
            static readonly $gtype: GObject.GType<GLMixerPrivate>

            
        }
        none
        /**
         * A #GstGLQuery represents and holds an OpenGL query object.  Various types of
         * queries can be run or counters retrieved.
         * @since 1.10
         */
        abstract class GLQuery {
            static readonly $gtype: GObject.GType<GLQuery>

            
            /**
             * Performs a GST_QUERY_CONTEXT query of type "gst.gl.local_context" on all
             * #GstPads in @element of @direction for the local OpenGL context used by
             * GStreamer elements.
             * @param element a #GstElement to query from
             * @param direction the #GstPadDirection to query
             * @returns whether `context_ptr` contains a #GstGLContext, location containing the current and/or resulting                      #GstGLContext
             */
            static local_gl_context(element: Gst.Element, direction: Gst.PadDirection): [boolean, GLContext]
            /**
             * Record the result of a counter
             * @since 1.10
             */
            counter(): void
            /**
             * End counting the query
             * @since 1.10
             */
            end(): void
            /**
             * Frees a #GstGLQuery
             * @since 1.10
             */
            free(): void
            /**
             * @since 1.10
             * @param context a #GstGLContext
             * @param query_type the #GstGLQueryType
             */
            init(context: GLContext, query_type: GLQueryType): void
            /**
             * @since 1.10
             * @returns the result of the query
             */
            result(): number
            /**
             * Start counting the query
             * @since 1.10
             */
            start(): void
            /**
             * Free any dynamically allocated resources
             * @since 1.10
             */
            unset(): void
        }
        /**
         * GstGLRenderbuffer is a #GstGLBaseMemory subclass providing support for
         * OpenGL renderbuffers.
         *
         * #GstGLRenderbuffer is created or wrapped through gst_gl_base_memory_alloc()
         * with #GstGLRenderbufferAllocationParams.
         * @since 1.10
         */
        abstract class GLRenderbuffer {
            static readonly $gtype: GObject.GType<GLRenderbuffer>

            
            /**
             * Initializes the GL Base Texture allocator. It is safe to call this function
             * multiple times.  This must be called before any other GstGLRenderbuffer operation.
             * @since 1.10
             */
            static init_once(): void
            /**
             * the GL texture id for this memory
             */
            renderbuffer_id: number
            /**
             * the texture type
             */
            renderbuffer_format: GLFormat
            /**
             * the width
             */
            width: number
            /**
             * the height
             */
            height: number
            /**
             */
            renderbuffer_wrapped: boolean
            /**
             * @since 1.12
             * @returns the #GstGLFormat of `gl_mem`
             */
            get_format(): GLFormat
            /**
             * @since 1.10
             * @returns the configured height of `gl_mem`
             */
            get_height(): number
            /**
             * @since 1.10
             * @returns the OpenGL renderbuffer handle of `gl_mem`
             */
            get_id(): number
            /**
             * @since 1.10
             * @returns the configured width of `gl_mem`
             */
            get_width(): number
        }
        /**
         * Allocation parameters
         */
        abstract class GLRenderbufferAllocationParams {
            static readonly $gtype: GObject.GType<GLRenderbufferAllocationParams>

            
            /**
             * @since 1.10
             * @param context a #GstGLContext
             * @param alloc_params the #GstAllocationParams for sysmem mappings of the texture
             * @param renderbuffer_format the #GstGLFormat for the created textures
             * @param width the width of the renderbuffer
             * @param height the height of the renderbuffer
             * @returns a new #GstGLRenderbufferAllocationParams for allocating #GstGLRenderbuffer's
             */
            static "new"(context: GLContext, alloc_params: Gst.AllocationParams | null, renderbuffer_format: GLFormat, width: number, height: number): GLRenderbufferAllocationParams
            /**
             * @since 1.10
             * @param context a #GstGLContext
             * @param alloc_params the #GstAllocationParams for @tex_id
             * @param renderbuffer_format the #GstGLFormat for @tex_id
             * @param width the width of the renderbuffer
             * @param height the height of the renderbuffer
             * @param gl_handle the GL handle to wrap
             * @param user_data user data to call @notify with
             * @param notify a #GDestroyNotify
             * @returns a new #GstGLRenderbufferAllocationParams for wrapping `gl_handle` as a          renderbuffer
             */
            static new_wrapped(context: GLContext, alloc_params: Gst.AllocationParams | null, renderbuffer_format: GLFormat, width: number, height: number, gl_handle: never | null, user_data: never | null, notify: GLib.DestroyNotify | null): GLRenderbufferAllocationParams
            /**
             * the #GstGLFormat
             */
            renderbuffer_format: GLFormat
            /**
             * the width
             */
            width: number
            /**
             * the height
             */
            height: number
        }
        none
        none
        /**
         */
        abstract class GLSLStagePrivate {
            static readonly $gtype: GObject.GType<GLSLStagePrivate>

            
        }
        none
        /**
         */
        abstract class GLShaderPrivate {
            static readonly $gtype: GObject.GType<GLShaderPrivate>

            
        }
        /**
         * #GstGLSyncMeta provides the ability to synchronize the OpenGL command stream
         * with the CPU or with other OpenGL contexts.
         */
        abstract class GLSyncMeta {
            static readonly $gtype: GObject.GType<GLSyncMeta>

            
            /**
             */
            static get_info(): Gst.MetaInfo
            /**
             * the parent #GstMeta
             */
            parent: Gst.Meta
            /**
             * the #GstGLContext used to allocate the meta
             */
            context: GLContext
            /**
             * a custom data pointer for the implementation
             */
            data: never
            /**
             * Set a sync point to possibly wait on at a later time.
             * @since 1.6
             * @param context a #GstGLContext
             */
            set_sync_point(context: GLContext): void
            /**
             * Insert a wait into @context's command stream ensuring all previous OpenGL
             * commands before @sync_meta have completed.
             * @since 1.6
             * @param context a #GstGLContext
             */
            wait(context: GLContext): void
            /**
             * Perform a wait so that the sync point has passed from the CPU's perspective
             * What that means, is that all GL operations changing CPU-visible data before
             * the sync point are now visible.
             * @since 1.8
             * @param context a #GstGLContext
             */
            wait_cpu(context: GLContext): void
        }
        none
        /**
         */
        abstract class GLUploadPrivate {
            static readonly $gtype: GObject.GType<GLUploadPrivate>

            
        }
        /**
         */
        abstract class GLVideoAllocationParams {
            static readonly $gtype: GObject.GType<GLVideoAllocationParams>

            
            /**
             * @since 1.8
             * @param context a #GstGLContext
             * @param alloc_params the #GstAllocationParams for sysmem mappings of the texture
             * @param v_info the #GstVideoInfo for the texture
             * @param plane the video plane of @v_info to allocate
             * @param valign any #GstVideoAlignment applied to symem mappings of the texture
             * @param target the #GstGLTextureTarget for the created textures
             * @param tex_format the #GstGLFormat for the created textures
             * @returns a new #GstGLVideoAllocationParams for allocating #GstGLMemory's
             */
            static "new"(context: GLContext, alloc_params: Gst.AllocationParams | null, v_info: GstVideo.VideoInfo, plane: number, valign: GstVideo.VideoAlignment | null, target: GLTextureTarget, tex_format: GLFormat): GLVideoAllocationParams
            /**
             * @since 1.8
             * @param context a #GstGLContext
             * @param alloc_params the #GstAllocationParams for @wrapped_data
             * @param v_info the #GstVideoInfo for @wrapped_data
             * @param plane the video plane @wrapped_data represents
             * @param valign any #GstVideoAlignment applied to symem mappings of @wrapped_data
             * @param target the #GstGLTextureTarget for @wrapped_data
             * @param tex_format the #GstGLFormat for @wrapped_data
             * @param wrapped_data the data pointer to wrap
             * @param user_data user data to call @notify with
             * @param notify a #GDestroyNotify
             * @returns a new #GstGLVideoAllocationParams for wrapping `wrapped_data`
             */
            static new_wrapped_data(context: GLContext, alloc_params: Gst.AllocationParams | null, v_info: GstVideo.VideoInfo, plane: number, valign: GstVideo.VideoAlignment | null, target: GLTextureTarget, tex_format: GLFormat, wrapped_data: never | null, user_data: never | null, notify: GLib.DestroyNotify | null): GLVideoAllocationParams
            /**
             * @gl_handle is defined by the specific OpenGL handle being wrapped
             * For #GstGLMemory and #GstGLMemoryPBO it is an OpenGL texture id.
             * Other memory types may define it to require a different type of parameter.
             * @since 1.8
             * @param context a #GstGLContext
             * @param alloc_params the #GstAllocationParams for @tex_id
             * @param v_info the #GstVideoInfo for @tex_id
             * @param plane the video plane @tex_id represents
             * @param valign any #GstVideoAlignment applied to symem mappings of @tex_id
             * @param target the #GstGLTextureTarget for @tex_id
             * @param tex_format the #GstGLFormat for @tex_id
             * @param gl_handle the GL handle to wrap
             * @param user_data user data to call @notify with
             * @param notify a #GDestroyNotify
             * @returns a new #GstGLVideoAllocationParams for wrapping `gl_handle`
             */
            static new_wrapped_gl_handle(context: GLContext, alloc_params: Gst.AllocationParams | null, v_info: GstVideo.VideoInfo, plane: number, valign: GstVideo.VideoAlignment | null, target: GLTextureTarget, tex_format: GLFormat, gl_handle: never | null, user_data: never | null, notify: GLib.DestroyNotify | null): GLVideoAllocationParams
            /**
             * @since 1.8
             * @param context a #GstGLContext
             * @param alloc_params the #GstAllocationParams for @tex_id
             * @param v_info the #GstVideoInfo for @tex_id
             * @param plane the video plane @tex_id represents
             * @param valign any #GstVideoAlignment applied to symem mappings of @tex_id
             * @param target the #GstGLTextureTarget for @tex_id
             * @param tex_format the #GstGLFormat for @tex_id
             * @param tex_id the GL texture to wrap
             * @param user_data user data to call @notify with
             * @param notify a #GDestroyNotify
             * @returns a new #GstGLVideoAllocationParams for wrapping `tex_id`
             */
            static new_wrapped_texture(context: GLContext, alloc_params: Gst.AllocationParams | null, v_info: GstVideo.VideoInfo, plane: number, valign: GstVideo.VideoAlignment | null, target: GLTextureTarget, tex_format: GLFormat, tex_id: number, user_data: never | null, notify: GLib.DestroyNotify | null): GLVideoAllocationParams
            /**
             * the parent #GstGLAllocationParams structure
             */
            parent: GLAllocationParams
            /**
             * the #GstVideoInfo to allocate
             */
            v_info: GstVideo.VideoInfo
            /**
             * the video plane index to allocate
             */
            plane: number
            /**
             * the #GstVideoAlignment to align the system representation to (may be %NULL for the default)
             */
            valign: GstVideo.VideoAlignment
            /**
             * the #GstGLTextureTarget to allocate
             */
            target: GLTextureTarget
            /**
             * the #GstGLFormat to allocate
             */
            tex_format: GLFormat
            /**
             * Copy and set any dynamically allocated resources in @dest_vid.  Intended
             * for subclass usage only to chain up at the end of a subclass copy function.
             * @since 1.8
             * @param dest_vid destination #GstGLVideoAllocationParams to copy into
             */
            copy_data(dest_vid: GLVideoAllocationParams): void
            /**
             * Unset and free any dynamically allocated resources.  Intended for subclass
             * usage only to chain up at the end of a subclass free function.
             * @since 1.8
             */
            free_data(): void
        }
        none
        /**
         */
        abstract class GLViewConvertPrivate {
            static readonly $gtype: GObject.GType<GLViewConvertPrivate>

            
        }
        none
        /**
         */
        abstract class GLWindowPrivate {
            static readonly $gtype: GObject.GType<GLWindowPrivate>

            
        }
        /**
         * @since 1.6
         * @param context a #GstGLContext
         * @param buffer a #GstBuffer
         * @returns the #GstGLSyncMeta added to #GstBuffer
         */
        function buffer_add_gl_sync_meta(context: GLContext, buffer: Gst.Buffer): GLSyncMeta
        /**
         * @since 1.8
         * @param context a #GstGLContext
         * @param buffer a #GstBuffer
         * @param data sync data to hold
         * @returns the #GstGLSyncMeta added to #GstBuffer
         */
        function buffer_add_gl_sync_meta_full(context: GLContext, buffer: Gst.Buffer, data: never | null): GLSyncMeta
        /**
         * @param config a buffer pool config
         * @returns the currently set #GstGLAllocationParams or %NULL
         */
        function buffer_pool_config_get_gl_allocation_params(config: Gst.Structure): GLAllocationParams | null
        /**
         * See gst_buffer_pool_config_set_gl_min_free_queue_size().
         * @since 1.24
         * @param config a buffer pool config
         * @returns then number of buffers configured the free queue
         */
        function buffer_pool_config_get_gl_min_free_queue_size(config: Gst.Structure): number
        /**
         * Sets @params on @config
         * @param config a buffer pool config
         * @param params a #GstGLAllocationParams
         */
        function buffer_pool_config_set_gl_allocation_params(config: Gst.Structure, params: GLAllocationParams | null): void
        /**
         * Instructs the #GstGLBufferPool to keep @queue_size amount of buffers around
         * before allowing them for reuse.
         *
         * This is helpful to allow GPU processing to complete before the CPU
         * operations on the same buffer could start.  Particularly useful when
         * uploading or downloading data to/from the GPU.
         *
         * A value of 0 disabled this functionality.
         *
         * This value must be less than the configured maximum amount of buffers for
         * this @config.
         * @since 1.24
         * @param config a buffer pool config
         * @param queue_size the number of buffers
         */
        function buffer_pool_config_set_gl_min_free_queue_size(config: Gst.Structure, queue_size: number): void
        /**
         * @since 1.4
         * @param context a #GstContext
         * @returns Whether `display` was in `context`, resulting #GstGLDisplay
         */
        function context_get_gl_display(context: Gst.Context): boolean
        /**
         * Sets @display on @context
         * @since 1.4
         * @param context a #GstContext
         * @param display resulting #GstGLDisplay
         */
        function context_set_gl_display(context: Gst.Context, display: GLDisplay | null): void
        /**
         * @param api_s a space separated string of OpenGL apis
         * @returns The #GstGLAPI represented by `api_s`
         */
        function gl_api_from_string(api_s: string): GLAPI
        /**
         * @param api a #GstGLAPI to stringify
         * @returns A space separated string of the OpenGL api's enabled in `api`
         */
        function gl_api_to_string(api: GLAPI): string
        none
        /**
         * @since 1.8
         * @param allocator a #GstGLBaseMemoryAllocator
         * @param params the #GstGLAllocationParams to allocate the memory with
         * @returns a new #GstGLBaseMemory from `allocator` with the requested `params`.
         */
        function gl_base_memory_alloc(allocator: GLBaseMemoryAllocator, params: GLAllocationParams): GLBaseMemory | null
        /**
         * @returns the quark used for #GstGLBaseMemory in #GError's
         */
        function gl_base_memory_error_quark(): GLib.Quark
        /**
         * Initializes the GL Base Memory allocator. It is safe to call this function
         * multiple times.  This must be called before any other GstGLBaseMemory operation.
         * @since 1.8
         */
        function gl_base_memory_init_once(): void
        /**
         * Initializes the GL Buffer allocator. It is safe to call this function
         * multiple times.  This must be called before any other #GstGLBuffer operation.
         * @since 1.8
         */
        function gl_buffer_init_once(): void
        /**
         * @param name the extension to search for
         * @param ext the list of possible extensions
         * @returns whether `name` is in the space separated list of `ext`
         */
        function gl_check_extension(name: string, ext: string): boolean
        /**
         * @since 1.20
         * @param caveat the #GstGLConfigCaveat
         * @returns a string version of `caveat` or %NULL if `caveat` does not                      exist.
         */
        function gl_config_caveat_to_string(caveat: GLConfigCaveat): string | null
        /**
         * @since 1.20
         * @param surface_type the #GstGLConfigSurfaceType
         * @returns a string version of `caveat` or %NULL if `surface_type` does not                      exist.
         */
        function gl_config_surface_type_to_string(surface_type: GLConfigSurfaceType): string | null
        /**
         * @returns the quark used for #GstGLContext in #GError's
         */
        function gl_context_error_quark(): GLib.Quark
        /**
         * Given the DRM formats in @src #GValue, collect corresponding GST formats to
         * @dst #GValue. This function returns %FALSE if  the context is not an EGL
         * context.
         * @since 1.26
         * @param context a #GstContext
         * @param src value of "drm-format" field in #GstCaps as #GValue
         * @param flags transformation flags
         * @returns whether any valid GST video formats were found and stored in `dst`, empty destination #GValue
         */
        function gl_dma_buf_transform_drm_formats_to_gst_formats(context: GLContext, src: GObject.Value, flags: GLDrmFormatFlags): [boolean, GObject.Value]
        /**
         * Given the video formats in @src #GValue, collect corresponding drm formats
         * supported by @context into @dst #GValue. This function returns %FALSE if
         * the context is not an EGL context.
         * @since 1.26
         * @param context a #GstContext
         * @param src value of "format" field in #GstCaps as #GValue
         * @param flags transformation flags
         * @returns whether any valid drm formats were found and stored in `dst`, empty destination #GValue
         */
        function gl_dma_buf_transform_gst_formats_to_drm_formats(context: GLContext, src: GObject.Value, flags: GLDrmFormatFlags): [boolean, GObject.Value]
        /**
         * @param element
         * @param display
         */
        function gl_element_propagate_display_context(element: Gst.Element, display: GLDisplay): void
        /**
         * Perform the steps necessary for retrieving a #GstGLDisplay and (optionally)
         * an application provided #GstGLContext from the surrounding elements or from
         * the application using the #GstContext mechanism.
         *
         * If the contents of @display_ptr or @other_context_ptr are not %NULL, then no
         * #GstContext query is necessary for #GstGLDisplay or #GstGLContext retrieval
         * or is performed.
         *
         * This performs #GstContext queries (if necessary) for a winsys display
         * connection with %GST_GL_DISPLAY_CONTEXT_TYPE, "gst.x11.display.handle", and
         * "GstWaylandDisplayHandleContextType" stopping after the first successful
         * retrieval.
         *
         * This also performs a #GstContext query (if necessary) for an optional
         * application provided #GstGLContext using the name "gst.gl.app_context".
         * The returned #GstGLContext will be shared with a GStreamer created OpenGL context.
         * @param element the #GstElement running the query
         * @returns whether a #GstGLDisplay exists in `display_ptr`, the resulting #GstGLDisplay, the resulting #GstGLContext
         */
        function gl_ensure_element_data(element: Gst.Element): [boolean, GLDisplay, GLContext]
        /**
         * @param context a #GstGLContext
         * @param vinfo a #GstVideoInfo
         * @param plane the plane number in @vinfo
         * @returns the #GstGLFormat necessary for holding the data in `plane` of `vinfo`
         */
        function gl_format_from_video_info(context: GLContext, vinfo: GstVideo.VideoInfo, plane: number): GLFormat
        /**
         * @since 1.16
         * @param context a #GstGLContext
         * @param format the #GstGLFormat to check is supported by @context
         * @returns Whether `format` is supported by `context` based on the OpenGL API,          version, or available OpenGL extension/s.
         */
        function gl_format_is_supported(context: GLContext, format: GLFormat): boolean
        /**
         * @since 1.24
         * @param gl_format the #GstGLFormat
         * @returns the number of components in a #GstGLFormat
         */
        function gl_format_n_components(gl_format: GLFormat): number
        /**
         * Get the unsized format and type from @format for usage in glReadPixels,
         * glTex{Sub}Image*, glTexImage* and similar functions.
         * @since 1.16
         * @param format the sized internal #GstGLFormat
         * @returns , location for the resulting unsized #GstGLFormat, location for the resulting GL type
         */
        function gl_format_type_from_sized_gl_format(format: GLFormat): [GLFormat, number]
        /**
         * @param format the OpenGL format, `GL_RGBA`, `GL_LUMINANCE`, etc
         * @param type the OpenGL type, `GL_UNSIGNED_BYTE`, `GL_FLOAT`, etc
         * @returns the number of bytes the specified `format`, `type` combination takes per pixel
         */
        function gl_format_type_n_bytes(format: number, type: number): number
        /**
         * Retrieves the stored 4x4 affine transformation matrix stored in @meta in
         * NDC coordinates. if @meta is NULL, an identity matrix is returned.
         *
         * NDC is a left-handed coordinate system
         * - x - [-1, 1] - +ve X moves right
         * - y - [-1, 1] - +ve Y moves up
         * - z - [-1, 1] - +ve Z moves into
         * @since 1.20
         * @param meta a #GstVideoAffineTransformationMeta
         * @returns , result of the 4x4 matrix
         */
        function gl_get_affine_transformation_meta_as_ndc(meta: GstVideo.VideoAffineTransformationMeta | null): number[]
        /**
         * Retrieve the size in bytes of a video plane of data with a certain alignment
         * @param info a #GstVideoInfo
         * @param align a #GstVideoAlignment or %NULL
         * @param plane plane number in @info to retrieve the data size of
         */
        function gl_get_plane_data_size(info: GstVideo.VideoInfo, align: GstVideo.VideoAlignment, plane: number): number
        /**
         * @param info a #GstVideoInfo
         * @param valign a #GstVideoAlignment or %NULL
         * @param plane plane number in @info to retrieve the data size of
         * @returns difference between the supposed start of the plane from the `info`          and where the data from the previous plane ends.
         */
        function gl_get_plane_start(info: GstVideo.VideoInfo, valign: GstVideo.VideoAlignment, plane: number): number
        /**
         * @param element a #GstElement
         * @param query a #GstQuery of type %GST_QUERY_CONTEXT
         * @param display a #GstGLDisplay
         * @param context a #GstGLContext
         * @param other_context application provided #GstGLContext
         * @returns Whether the `query` was successfully responded to from the passed          `display`, `context`, and `other_context`.
         */
        function gl_handle_context_query(element: Gst.Element, query: Gst.Query, display: GLDisplay | null, context: GLContext | null, other_context: GLContext | null): boolean
        /**
         * Helper function for implementing #GstElementClass.set_context() in
         * OpenGL capable elements.
         *
         * Retrieve's the #GstGLDisplay or #GstGLContext in @context and places the
         * result in @display or @other_context respectively.
         * @param element a #GstElement
         * @param context a #GstContext
         * @returns whether the `display` or `other_context` could be set successfully, location of a #GstGLDisplay, location of a #GstGLContext
         */
        function gl_handle_set_context(element: Gst.Element, context: Gst.Context): [boolean, GLDisplay, GLContext]
        none
        /**
         * Initializes the GL Base Texture allocator. It is safe to call this function
         * multiple times.  This must be called before any other GstGLMemory operation.
         * @since 1.4
         */
        function gl_memory_init_once(): void
        /**
         */
        function gl_memory_pbo_init_once(): void
        none
        /**
         * Multiplies two 4x4 matrices, @a and @b, and stores the result, a
         * 2-dimensional array of #gfloat, in @result.
         * @since 1.20
         * @param a a 2-dimensional 4x4 array of #gfloat
         * @param b another 2-dimensional 4x4 array of #gfloat
         * @returns , the result of the multiplication
         */
        function gl_multiply_matrix4(a: number[], b: number[]): number[]
        /**
         * @param platform_s a space separated string of OpenGL platformss
         * @returns The #GstGLPlatform represented by `platform_s`
         */
        function gl_platform_from_string(platform_s: string): GLPlatform
        /**
         * @param platform a #GstGLPlatform to stringify
         * @returns A space separated string of the OpenGL platforms enabled in `platform`
         */
        function gl_platform_to_string(platform: GLPlatform): string
        /**
         * Performs a GST_QUERY_CONTEXT query of type "gst.gl.local_context" on all
         * #GstPads in @element of @direction for the local OpenGL context used by
         * GStreamer elements.
         * @param element a #GstElement to query from
         * @param direction the #GstPadDirection to query
         * @returns whether `context_ptr` contains a #GstGLContext, location containing the current and/or resulting                      #GstGLContext
         */
        function gl_query_local_gl_context(element: Gst.Element, direction: Gst.PadDirection): [boolean, GLContext]
        none
        /**
         * Initializes the GL Base Texture allocator. It is safe to call this function
         * multiple times.  This must be called before any other GstGLRenderbuffer operation.
         * @since 1.10
         */
        function gl_renderbuffer_init_once(): void
        /**
         * Set the 4x4 affine transformation matrix stored in @meta from the
         * NDC coordinates in @matrix.
         * @since 1.20
         * @param meta a #GstVideoAffineTransformationMeta
         * @param matrix a 4x4 matrix
         */
        function gl_set_affine_transformation_meta_from_ndc(meta: GstVideo.VideoAffineTransformationMeta, matrix: number[]): void
        /**
         * @param context a #GstGLContext
         * @param format an OpenGL format, `GL_RGBA`, `GL_LUMINANCE`, etc
         * @param type an OpenGL type, `GL_UNSIGNED_BYTE`, `GL_FLOAT`, etc
         * @returns the sized internal format specified by `format` and `type` that can          be used in `context`
         */
        function gl_sized_gl_format_from_gl_format_type(context: GLContext, format: number, type: number): number
        /**
         */
        function gl_stereo_downmix_mode_get_type(): GObject.GType
        /**
         * Given @swizzle, produce @inversion such that:
         *
         * @swizzle[@inversion[i]] == identity[i] where:
         * - identity = {0, 1, 2,...}
         * - unset fields are marked by -1
         * @since 1.24
         * @param swizzle input swizzle
         * @returns , resulting inversion
         */
        function gl_swizzle_invert(swizzle: number[]): number[]
        /**
         */
        function gl_sync_meta_api_get_type(): GObject.GType
        /**
         */
        function gl_sync_meta_get_info(): Gst.MetaInfo
        /**
         * @param target an OpenGL texture binding target
         * @returns the #GstGLTextureTarget that's equiavalant to `target` or          %GST_GL_TEXTURE_TARGET_NONE
         */
        function gl_texture_target_from_gl(target: number): GLTextureTarget
        /**
         * @param str a string equivalent to one of the GST_GL_TEXTURE_TARGET_*_STR values
         * @returns the #GstGLTextureTarget represented by `str` or          %GST_GL_TEXTURE_TARGET_NONE
         */
        function gl_texture_target_from_string(str: string): GLTextureTarget
        /**
         * @param target a #GstGLTextureTarget
         * @returns a string representing the `GstBufferPoolOption` specified by `target`
         */
        function gl_texture_target_to_buffer_pool_option(target: GLTextureTarget): string | null
        /**
         * @param target a #GstGLTextureTarget
         * @returns the OpenGL value for binding the `target` with glBindTexture() and          similar functions or 0
         */
        function gl_texture_target_to_gl(target: GLTextureTarget): number
        /**
         * @param target a #GstGLTextureTarget
         * @returns the stringified version of `target` or %NULL
         */
        function gl_texture_target_to_string(target: GLTextureTarget): string | null
        /**
         * See gst_gl_value_set_texture_target_from_mask() for what entails a mask
         * @param value an initialized #GValue of type G_TYPE_STRING
         * @returns the mask of #GstGLTextureTarget's in `value` or     %GST_GL_TEXTURE_TARGET_NONE on failure
         */
        function gl_value_get_texture_target_mask(value: GObject.Value): GLTextureTarget
        /**
         * @param value an initialized #GValue of type G_TYPE_STRING
         * @param target a #GstGLTextureTarget's
         * @returns whether the `target` could be set on `value`
         */
        function gl_value_set_texture_target(value: GObject.Value, target: GLTextureTarget): boolean
        /**
         *  target) where target is a valid
         * #GstGLTextureTarget
         * @param value an uninitialized #GValue
         * @param target_mask a bitwise mask of #GstGLTextureTarget's
         * @returns whether the `target_mask` could be set on `value`
         */
        function gl_value_set_texture_target_from_mask(value: GObject.Value, target_mask: GLTextureTarget): boolean
        /**
         * @param gl_api the #GstGLAPI
         * @param maj the major GL version
         * @param min the minor GL version
         * @returns The minimum supported #GstGLSLVersion available for `gl_api`, `maj` and `min`
         */
        function gl_version_to_glsl_version(gl_api: GLAPI, maj: number, min: number): GLSLVersion
        /**
         * Calculates the swizzle indices for @video_format and @gl_format in order to
         * access a texture such that accessing a texel from a texture through the swizzle
         * index produces values in the order (R, G, B, A) or (Y, U, V, A).
         *
         * For multi-planer formats, the swizzle index uses the same component order (RGBA/YUVA)
         * and should be applied after combining multiple planes into a single rgba/yuva value.
         * e.g. sampling from a NV12 format would have Y from one texture and UV from
         * another texture into a (Y, U, V) value.  Add an Aplha component and then
         * perform swizzling.  Sampling from NV21 would produce (Y, V, U) which is then
         * swizzled to (Y, U, V).
         * @since 1.24
         * @param video_format the #GstVideoFormat in use
         * @returns whether valid swizzle indices could be found, the returned swizzle indices
         */
        function gl_video_format_swizzle(video_format: GstVideo.VideoFormat): [boolean, number[]]
        /**
         * @returns the quark used for #GstGLWindow in #GError's
         */
        function gl_window_error_quark(): GLib.Quark
        /**
         * @returns the quark used for GstGLSL in #GError's
         */
        function glsl_error_quark(): GLib.Quark
        /**
         * @param string a GLSL version string
         * @returns the #GstGLSLProfile of `string` or %GST_GLSL_PROFILE_NONE on error
         */
        function glsl_profile_from_string(string: string): GLSLProfile
        /**
         * @param profile a #GstGLSLProfile
         * @returns the name for `profile` or %NULL on error
         */
        function glsl_profile_to_string(profile: GLSLProfile): string | null
        /**
         * Note: this function first searches the first 1 kilobytes for a `#version`
         * preprocessor directive and then executes gst_glsl_version_profile_from_string().
         * @param s string to search for a valid `#version` string
         * @returns TRUE if a valid `#version` string was found, FALSE otherwise, resulting #GstGLSLVersion, resulting #GstGLSLProfile
         */
        function glsl_string_get_version_profile(s: string): [boolean, GLSLVersion, GLSLProfile]
        /**
         * @param string a GLSL version string
         * @returns the #GstGLSLVersion of `string` or %GST_GLSL_VERSION_NONE on error
         */
        function glsl_version_from_string(string: string): GLSLVersion
        /**
         * Note: this function expects either a `#version` GLSL preprocesser directive
         * or a valid GLSL version and/or profile.
         * @param string a valid GLSL `#version` string
         * @returns TRUE if a valid `#version` string was found, FALSE otherwise, resulting #GstGLSLVersion, resulting #GstGLSLVersion
         */
        function glsl_version_profile_from_string(string: string): [boolean, GLSLVersion, GLSLProfile]
        /**
         * @param version a #GstGLSLVersion
         * @param profile a #GstGLSLVersion
         * @returns the combined GLSL `#version` string for `version` and `profile`
         */
        function glsl_version_profile_to_string(version: GLSLVersion, profile: GLSLProfile): string | null
        /**
         * @param version a #GstGLSLVersion
         * @returns the name of `version` or %NULL on error
         */
        function glsl_version_to_string(version: GLSLVersion): string | null
        /**
         * @since 1.8
         * @param mem a #GstMemory
         * @returns whether the memory at `mem` is a #GstGLBaseMemory
         */
        function is_gl_base_memory(mem: Gst.Memory): boolean
        /**
         * @since 1.8
         * @param mem a #GstMemory
         * @returns whether the memory at `mem` is a #GstGLBuffer
         */
        function is_gl_buffer(mem: Gst.Memory): boolean
        /**
         * @since 1.4
         * @param mem a #GstMemory
         * @returns whether the memory at `mem` is a #GstGLMemory
         */
        function is_gl_memory(mem: Gst.Memory): boolean
        /**
         * @since 1.8
         * @param mem a #GstMemory
         * @returns whether the memory at `mem` is a #GstGLMemoryPBO
         */
        function is_gl_memory_pbo(mem: Gst.Memory): boolean
        /**
         * @since 1.10
         * @param mem a #GstMemory
         * @returns whether the memory at `mem` is a #GstGLRenderbuffer
         */
        function is_gl_renderbuffer(mem: Gst.Memory): boolean
        const BUFFER_POOL_OPTION_GL_SYNC_META: "GstBufferPoolOptionGLSyncMeta"
        const BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_2D: "GstBufferPoolOptionGLTextureTarget2D"
        const BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_EXTERNAL_OES: "GstBufferPoolOptionGLTextureTargetExternalOES"
        const BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_RECTANGLE: "GstBufferPoolOptionGLTextureTargetRectangle"
        const CAPS_FEATURE_MEMORY_GL_BUFFER: "memory:GLBuffer"
        const CAPS_FEATURE_MEMORY_GL_MEMORY: "memory:GLMemory"
        const GL_ALLOCATION_PARAMS_ALLOC_FLAG_ALLOC: 1
        const GL_ALLOCATION_PARAMS_ALLOC_FLAG_BUFFER: 16
        const GL_ALLOCATION_PARAMS_ALLOC_FLAG_USER: 65536
        const GL_ALLOCATION_PARAMS_ALLOC_FLAG_VIDEO: 8
        const GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_GPU_HANDLE: 4
        const GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_SYSMEM: 2
        const GL_API_GLES1_NAME: "gles1"
        const GL_API_GLES2_NAME: "gles2"
        const GL_API_OPENGL3_NAME: "opengl3"
        const GL_API_OPENGL_NAME: "opengl"
        const GL_BASE_MEMORY_ALLOCATOR_NAME: "GLBaseMemory"
        const GL_BUFFER_ALLOCATOR_NAME: "GLBuffer"
        none
        const GL_COLOR_CONVERT_FORMATS: "{ RGBA, RGB, RGBx, BGR, BGRx, BGRA, xRGB, xBGR, ARGB, ABGR, GBRA, GBR, RGBP, BGRP, Y444, I420, YV12, Y42B, Y41B, NV12, NV21, NV16, NV61, YUY2, UYVY, Y210, AYUV, VUYA, Y410, A444, A422, GRAY8, GRAY16_LE, GRAY16_BE, RGB16, BGR16, ARGB64, A420, AV12, NV12_16L32S, NV12_4L4, RBGA, v210"
        const GL_COLOR_CONVERT_VIDEO_CAPS: "video/x-raw("
        const GL_CONFIG_STRUCTURE_NAME: "gst-gl-context-config"
        const GL_CONTEXT_TYPE_CGL: "gst.gl.context.CGL"
        const GL_CONTEXT_TYPE_EAGL: "gst.gl.context.EAGL"
        const GL_CONTEXT_TYPE_EGL: "gst.gl.context.EGL"
        const GL_CONTEXT_TYPE_GLX: "gst.gl.context.GLX"
        const GL_CONTEXT_TYPE_WGL: "gst.gl.context.WGL"
        const GL_DISPLAY_CONTEXT_TYPE: "gst.gl.GLDisplay"
        const GL_MEMORY_ALLOCATOR_NAME: "GLMemory"
        const GL_MEMORY_PBO_ALLOCATOR_NAME: "GLMemoryPBO"
        none
        const GL_MEMORY_VIDEO_FORMATS_STR: "{ RGBA, BGRA, RGBx, BGRx, ARGB, ABGR, xRGB, xBGR, GBRA, GBR, RGBP, BGRP, RGB, BGR, RGB16, BGR16, AYUV, VUYA, A444, A422, Y410, I420, YV12, NV12, NV21, NV16, NV61, YUY2, UYVY, Y210, Y41B, Y42B, Y444, GRAY8, GRAY16_LE, GRAY16_BE, ARGB64, A420, AV12, NV12_16L32S, NV12_4L4, RBGA, v210"
        const GL_RENDERBUFFER_ALLOCATOR_NAME: "GLRenderbuffer"
        const GL_TEXTURE_TARGET_2D_STR: "2D"
        const GL_TEXTURE_TARGET_EXTERNAL_OES_STR: "external-oes"
        const GL_TEXTURE_TARGET_RECTANGLE_STR: "rectangle"
        const MAP_GL: 131072
        
        abstract class GLBaseMemoryError extends GLib.Error {
            static readonly $gtype: GObject.GType<GLBaseMemoryError>
            /**
             * generic failure
             */
            static readonly "FAILED": 0
            /**
             * the implementation is too old and doesn't
             *                                     implement enough features
             */
            static readonly "OLD_LIBS": 1
            /**
             * a resource could not be found
             */
            static readonly "RESOURCE_UNAVAILABLE": 2
        }
        /**
         * @returns the quark used for #GstGLBaseMemory in #GError's
         */
        function quark(): GLib.Quark
        
        namespace GLConfigCaveat {
            const $gtype: GObject.GType<GLConfigCaveat>
        }

        /**
         * @since 1.20
         */
        enum GLConfigCaveat {
            /**
             * none
             */
            "NONE" = 0,
            /**
             * slow
             */
            "SLOW" = 1,
            /**
             * non-conformant
             */
            "NON_CONFORMANT" = 2,
        }
        /**
         * @since 1.20
         * @param caveat the #GstGLConfigCaveat
         * @returns a string version of `caveat` or %NULL if `caveat` does not                      exist.
         */
        function to_string(caveat: GLConfigCaveat): string | null
        
        abstract class GLContextError extends GLib.Error {
            static readonly $gtype: GObject.GType<GLContextError>
            /**
             * Failed for an unspecified reason
             */
            static readonly "FAILED": 0
            /**
             * The configuration requested is not correct
             */
            static readonly "WRONG_CONFIG": 1
            /**
             * The OpenGL API requested is not correct
             */
            static readonly "WRONG_API": 2
            /**
             * The OpenGL libraries are too old
             */
            static readonly "OLD_LIBS": 3
            /**
             * glXCreateContext (or similar) failed
             */
            static readonly "CREATE_CONTEXT": 4
            /**
             * A resource is not available
             */
            static readonly "RESOURCE_UNAVAILABLE": 5
        }
        /**
         * @returns the quark used for #GstGLContext in #GError's
         */
        function quark(): GLib.Quark
        
        namespace GLFormat {
            const $gtype: GObject.GType<GLFormat>
        }

        /**
         */
        enum GLFormat {
            /**
             * Single component replicated across R, G, and B textures
             *                    components
             */
            "LUMINANCE" = 6409,
            /**
             * Single component stored in the A texture component
             */
            "ALPHA" = 6406,
            /**
             * Combination of #GST_GL_LUMINANCE and #GST_GL_ALPHA
             */
            "LUMINANCE_ALPHA" = 6410,
            /**
             * Single component stored in the R texture component
             */
            "RED" = 6403,
            /**
             * Single 8-bit component stored in the R texture component
             */
            "R8" = 33321,
            /**
             * Two components stored in the R and G texture components
             */
            "RG" = 33319,
            /**
             * Two 8-bit components stored in the R and G texture components
             */
            "RG8" = 33323,
            /**
             * Three components stored in the R, G, and B texture components
             */
            "RGB" = 6407,
            /**
             * Three 8-bit components stored in the R, G, and B
             *               texture components
             */
            "RGB8" = 32849,
            /**
             * Three components of bit depth 5, 6 and 5 stored in the R, G,
             *                 and B texture components respectively.
             */
            "RGB565" = 36194,
            /**
             * Three 16-bit components stored in the R, G, and B
             *               texture components
             */
            "RGB16" = 32852,
            /**
             * Four components stored in the R, G, B, and A texture
             *               components respectively.
             */
            "RGBA" = 6408,
            /**
             * Four 8-bit components stored in the R, G, B, and A texture
             *                components respectively.
             */
            "RGBA8" = 32856,
            /**
             * Four 16-bit components stored in the R, G, B, and A texture
             *                components respectively.
             */
            "RGBA16" = 32859,
            /**
             * A single 16-bit component for depth information.
             */
            "DEPTH_COMPONENT16" = 33189,
            /**
             * A 24-bit component for depth information and
             *                           a 8-bit component for stencil informat.
             */
            "DEPTH24_STENCIL8" = 35056,
            /**
             */
            "RGB10_A2" = 32857,
            /**
             * Single 16-bit component stored in the R texture component
             */
            "R16" = 33322,
            /**
             * Two 16-bit components stored in the R and G texture components
             */
            "RG16" = 33324,
        }
        /**
         * @param context a #GstGLContext
         * @param vinfo a #GstVideoInfo
         * @param plane the plane number in @vinfo
         * @returns the #GstGLFormat necessary for holding the data in `plane` of `vinfo`
         */
        function from_video_info(context: GLContext, vinfo: GstVideo.VideoInfo, plane: number): GLFormat
        /**
         * @since 1.16
         * @param context a #GstGLContext
         * @param format the #GstGLFormat to check is supported by @context
         * @returns Whether `format` is supported by `context` based on the OpenGL API,          version, or available OpenGL extension/s.
         */
        function is_supported(context: GLContext, format: GLFormat): boolean
        /**
         * @since 1.24
         * @param gl_format the #GstGLFormat
         * @returns the number of components in a #GstGLFormat
         */
        function n_components(gl_format: GLFormat): number
        /**
         * Get the unsized format and type from @format for usage in glReadPixels,
         * glTex{Sub}Image*, glTexImage* and similar functions.
         * @since 1.16
         * @param format the sized internal #GstGLFormat
         * @returns , location for the resulting unsized #GstGLFormat, location for the resulting GL type
         */
        function type_from_sized_gl_format(format: GLFormat): [GLFormat, number]
        /**
         * @param format the OpenGL format, `GL_RGBA`, `GL_LUMINANCE`, etc
         * @param type the OpenGL type, `GL_UNSIGNED_BYTE`, `GL_FLOAT`, etc
         * @returns the number of bytes the specified `format`, `type` combination takes per pixel
         */
        function type_n_bytes(format: number, type: number): number
        
        namespace GLQueryType {
            const $gtype: GObject.GType<GLQueryType>
        }

        /**
         */
        enum GLQueryType {
            /**
             * no query
             */
            "NONE" = 0,
            /**
             * query the time elapsed
             */
            "TIME_ELAPSED" = 1,
            /**
             * query the current time
             */
            "TIMESTAMP" = 2,
        }
        
        abstract class GLSLError extends GLib.Error {
            static readonly $gtype: GObject.GType<GLSLError>
            /**
             * Compilation error occurred
             */
            static readonly "COMPILE": 0
            /**
             * Link error occurred
             */
            static readonly "LINK": 1
            /**
             * General program error occurred
             */
            static readonly "PROGRAM": 2
        }
        /**
         * @returns the quark used for GstGLSL in #GError's
         */
        function quark(): GLib.Quark
        
        namespace GLSLVersion {
            const $gtype: GObject.GType<GLSLVersion>
        }

        /**
         * GLSL version list
         * @since 1.8
         */
        enum GLSLVersion {
            /**
             * no version
             */
            "NONE" = 0,
            /**
             * version 100 (only valid for ES)
             */
            "100" = 100,
            /**
             * version 110 (only valid for compatibility desktop GL)
             */
            "110" = 110,
            /**
             * version 120 (only valid for compatibility desktop GL)
             */
            "120" = 120,
            /**
             * version 130 (only valid for compatibility desktop GL)
             */
            "130" = 130,
            /**
             * version 140 (only valid for compatibility desktop GL)
             */
            "140" = 140,
            /**
             * version 150 (valid for compatibility/core desktop GL)
             */
            "150" = 150,
            /**
             * version 300 (only valid for ES)
             */
            "300" = 300,
            /**
             * version 310 (only valid for ES)
             */
            "310" = 310,
            /**
             * version 320 (only valid for ES)
             */
            "320" = 320,
            /**
             * version 330 (valid for compatibility/core desktop GL)
             */
            "330" = 330,
            /**
             * version 400 (valid for compatibility/core desktop GL)
             */
            "400" = 400,
            /**
             * version 410 (valid for compatibility/core desktop GL)
             */
            "410" = 410,
            /**
             * version 420 (valid for compatibility/core desktop GL)
             */
            "420" = 420,
            /**
             * version 430 (valid for compatibility/core desktop GL)
             */
            "430" = 430,
            /**
             * version 440 (valid for compatibility/core desktop GL)
             */
            "440" = 440,
            /**
             * version 450 (valid for compatibility/core desktop GL)
             */
            "450" = 450,
        }
        /**
         * @param string a GLSL version string
         * @returns the #GstGLSLVersion of `string` or %GST_GLSL_VERSION_NONE on error
         */
        function from_string(string: string): GLSLVersion
        /**
         * Note: this function expects either a `#version` GLSL preprocesser directive
         * or a valid GLSL version and/or profile.
         * @param string a valid GLSL `#version` string
         * @returns TRUE if a valid `#version` string was found, FALSE otherwise, resulting #GstGLSLVersion, resulting #GstGLSLVersion
         */
        function profile_from_string(string: string): [boolean, GLSLVersion, GLSLProfile]
        /**
         * @param version a #GstGLSLVersion
         * @param profile a #GstGLSLVersion
         * @returns the combined GLSL `#version` string for `version` and `profile`
         */
        function profile_to_string(version: GLSLVersion, profile: GLSLProfile): string | null
        /**
         * @param version a #GstGLSLVersion
         * @returns the name of `version` or %NULL on error
         */
        function to_string(version: GLSLVersion): string | null
        
        namespace GLStereoDownmix {
            const $gtype: GObject.GType<GLStereoDownmix>
        }

        /**
         * Output anaglyph type to generate when downmixing to mono
         */
        enum GLStereoDownmix {
            /**
             * Dubois optimised Green-Magenta anaglyph
             */
            "GREEN_MAGENTA_DUBOIS" = 0,
            /**
             * Dubois optimised Red-Cyan anaglyph
             */
            "RED_CYAN_DUBOIS" = 1,
            /**
             * Dubois optimised Amber-Blue anaglyph
             */
            "AMBER_BLUE_DUBOIS" = 2,
        }
        
        namespace GLTextureTarget {
            const $gtype: GObject.GType<GLTextureTarget>
        }

        /**
         * The OpenGL texture target that an OpenGL texture can be bound to.  The
         * gst_gl_value_set_texture_target_from_mask(),
         * gst_gl_value_get_texture_target_mask(), and
         * gst_gl_value_set_texture_target() functions can be used for handling texture
         * targets with #GValue's when e.g. dealing with #GstCaps.
         * @since 1.8
         */
        enum GLTextureTarget {
            /**
             * no texture target
             */
            "NONE" = 0,
            /**
             * 2D texture target (`GL_TEXTURE_2D`)
             */
            "2D" = 1,
            /**
             * rectangle texture target
             *     (`GL_TEXTURE_RECTANGLE`)
             */
            "RECTANGLE" = 2,
            /**
             * external oes texture target
             *     (`GL_TEXTURE_EXTERNAL_OES`)
             */
            "EXTERNAL_OES" = 3,
        }
        /**
         * @param target an OpenGL texture binding target
         * @returns the #GstGLTextureTarget that's equiavalant to `target` or          %GST_GL_TEXTURE_TARGET_NONE
         */
        function from_gl(target: number): GLTextureTarget
        /**
         * @param str a string equivalent to one of the GST_GL_TEXTURE_TARGET_*_STR values
         * @returns the #GstGLTextureTarget represented by `str` or          %GST_GL_TEXTURE_TARGET_NONE
         */
        function from_string(str: string): GLTextureTarget
        /**
         * @param target a #GstGLTextureTarget
         * @returns a string representing the `GstBufferPoolOption` specified by `target`
         */
        function to_buffer_pool_option(target: GLTextureTarget): string | null
        /**
         * @param target a #GstGLTextureTarget
         * @returns the OpenGL value for binding the `target` with glBindTexture() and          similar functions or 0
         */
        function to_gl(target: GLTextureTarget): number
        /**
         * @param target a #GstGLTextureTarget
         * @returns the stringified version of `target` or %NULL
         */
        function to_string(target: GLTextureTarget): string | null
        
        namespace GLUploadReturn {
            const $gtype: GObject.GType<GLUploadReturn>
        }

        /**
         */
        enum GLUploadReturn {
            /**
             * No further processing required
             */
            "DONE" = 1,
            /**
             * An unspecified error occurred
             */
            "ERROR" = -1,
            /**
             * The configuration is unsupported.
             */
            "UNSUPPORTED" = -2,
            /**
             * This element requires a reconfiguration.
             */
            "RECONFIGURE" = -3,
            /**
             * private return value.
             */
            "UNSHARED_GL_CONTEXT" = -100,
        }
        
        abstract class GLWindowError extends GLib.Error {
            static readonly $gtype: GObject.GType<GLWindowError>
            /**
             * failed for a unspecified reason
             */
            static readonly "FAILED": 0
            /**
             * the implementation is too old
             */
            static readonly "OLD_LIBS": 1
            /**
             * no such resource was found
             */
            static readonly "RESOURCE_UNAVAILABLE": 2
        }
        /**
         * @returns the quark used for #GstGLWindow in #GError's
         */
        function quark(): GLib.Quark
        
        namespace GLAPI {
            const $gtype: GObject.GType<GLAPI>
        }

        /**
         */
        enum GLAPI {
            /**
             * no API
             */
            "NONE" = 0,
            /**
             * = 3.2
             */
            "OPENGL" = 1,
            /**
             * = 3.2 core profile
             */
            "OPENGL3" = 2,
            /**
             * OpenGL ES 1.x
             */
            "GLES1" = 32768,
            /**
             * OpenGL ES 2.x and 3.x
             */
            "GLES2" = 65536,
            /**
             * Any OpenGL API
             */
            "ANY" = 4294967295,
        }
        /**
         * @param api_s a space separated string of OpenGL apis
         * @returns The #GstGLAPI represented by `api_s`
         */
        function from_string(api_s: string): GLAPI
        /**
         * @param api a #GstGLAPI to stringify
         * @returns A space separated string of the OpenGL api's enabled in `api`
         */
        function to_string(api: GLAPI): string
        
        namespace GLBaseMemoryTransfer {
            const $gtype: GObject.GType<GLBaseMemoryTransfer>
        }

        /**
         */
        enum GLBaseMemoryTransfer {
            /**
             * the texture needs downloading
             *                                             to the data pointer
             */
            "DOWNLOAD" = 1048576,
            /**
             * the data pointer needs uploading
             *                                             to the texture
             */
            "UPLOAD" = 2097152,
        }
        
        namespace GLConfigSurfaceType {
            const $gtype: GObject.GType<GLConfigSurfaceType>
        }

        /**
         * @since 1.20
         */
        enum GLConfigSurfaceType {
            /**
             * none
             */
            "NONE" = 0,
            /**
             * window
             */
            "WINDOW" = 1,
            /**
             * pbuffer
             */
            "PBUFFER" = 2,
            /**
             * pixmap
             */
            "PIXMAP" = 4,
        }
        /**
         * @since 1.20
         * @param surface_type the #GstGLConfigSurfaceType
         * @returns a string version of `caveat` or %NULL if `surface_type` does not                      exist.
         */
        function to_string(surface_type: GLConfigSurfaceType): string | null
        
        namespace GLDisplayType {
            const $gtype: GObject.GType<GLDisplayType>
        }

        /**
         */
        enum GLDisplayType {
            /**
             * no display type
             */
            "NONE" = 0,
            /**
             * X11 display
             */
            "X11" = 1,
            /**
             * Wayland display
             */
            "WAYLAND" = 2,
            /**
             * Cocoa display
             */
            "COCOA" = 4,
            /**
             * Win32 display
             */
            "WIN32" = 8,
            /**
             * Dispmanx display
             */
            "DISPMANX" = 16,
            /**
             * EGL display
             */
            "EGL" = 32,
            /**
             * Vivante Framebuffer display
             */
            "VIV_FB" = 64,
            /**
             * Mesa3D GBM display
             */
            "GBM" = 128,
            /**
             * EGLDevice display.
             * @since 1.18
             */
            "EGL_DEVICE" = 256,
            /**
             * EAGL display.
             * @since 1.20
             */
            "EAGL" = 512,
            /**
             * WinRT display.
             * @since 1.20
             */
            "WINRT" = 1024,
            /**
             * Android display.
             * @since 1.20
             */
            "ANDROID" = 2048,
            /**
             * Mesa3D surfaceless display using the EGL_PLATFORM_SURFACELESS_MESA
             * extension.
             * @since 1.24
             */
            "EGL_SURFACELESS" = 4096,
            /**
             * any display type
             */
            "ANY" = 4294967295,
        }
        
        namespace GLDrmFormatFlags {
            const $gtype: GObject.GType<GLDrmFormatFlags>
        }

        /**
         * @since 1.26
         */
        enum GLDrmFormatFlags {
            /**
             * include external-only formats
             * @since 1.26
             */
            "INCLUDE_EXTERNAL" = 1,
            /**
             * only include formats with linear modifier
             * @since 1.26
             */
            "LINEAR_ONLY" = 2,
            /**
             * include emulated formats
             * @since 1.26
             */
            "INCLUDE_EMULATED" = 4,
        }
        
        namespace GLPlatform {
            const $gtype: GObject.GType<GLPlatform>
        }

        /**
         */
        enum GLPlatform {
            /**
             * no platform
             */
            "NONE" = 0,
            /**
             * the EGL platform used primarily with the X11, wayland
             *                      and android window systems as well as on embedded Linux
             */
            "EGL" = 1,
            /**
             * the GLX platform used primarily with the X11 window system
             */
            "GLX" = 2,
            /**
             * the WGL platform used primarily on Windows
             */
            "WGL" = 4,
            /**
             * the CGL platform used primarily on OS X
             */
            "CGL" = 8,
            /**
             * the EAGL platform used primarily on iOS
             */
            "EAGL" = 16,
            /**
             * any OpenGL platform
             */
            "ANY" = 4294967295,
        }
        /**
         * @param platform_s a space separated string of OpenGL platformss
         * @returns The #GstGLPlatform represented by `platform_s`
         */
        function from_string(platform_s: string): GLPlatform
        /**
         * @param platform a #GstGLPlatform to stringify
         * @returns A space separated string of the OpenGL platforms enabled in `platform`
         */
        function to_string(platform: GLPlatform): string
        
        namespace GLSLProfile {
            const $gtype: GObject.GType<GLSLProfile>
        }

        /**
         * GLSL profiles
         * @since 1.8
         */
        enum GLSLProfile {
            /**
             * no profile supported/available
             */
            "NONE" = 0,
            /**
             * OpenGL|ES profile
             */
            "ES" = 1,
            /**
             * OpenGL core profile
             */
            "CORE" = 2,
            /**
             * OpenGL compatibility profile
             */
            "COMPATIBILITY" = 4,
            /**
             * any OpenGL/OpenGL|ES profile
             */
            "ANY" = 4294967295,
        }
        /**
         * @param string a GLSL version string
         * @returns the #GstGLSLProfile of `string` or %GST_GLSL_PROFILE_NONE on error
         */
        function from_string(string: string): GLSLProfile
        /**
         * @param profile a #GstGLSLProfile
         * @returns the name for `profile` or %NULL on error
         */
        function to_string(profile: GLSLProfile): string | null
        /**
         * Copies the parameters from @src into @dest.  The subclass must compose copy
         * functions from the superclass.
         * @param src the source #GstGLAllocationParams to copy from
         * @param dest the source #GstGLAllocationParams to copy
         */
        type GLAllocationParamsCopyFunc = (src: GLAllocationParams, dest: GLAllocationParams) => void
        /**
         * Free any dynamically allocated data.  The subclass must call the superclass'
         * free.
         * @param params a #GstGLAllocationParams
         */
        type GLAllocationParamsFreeFunc = (params: never | null) => void
        /**
         */
        type GLAsyncDebugLogGetMessage = () => string
        /**
         * Note: not called with a GL context current
         * @since 1.8
         * @param allocator a #GstGLBaseMemoryAllocator
         * @param params the #GstGLAllocationParams to allocate the memory with
         * @returns a newly allocated #GstGLBaseMemory from `allocator` and `params`
         */
        type GLBaseMemoryAllocatorAllocFunction = (allocator: GLBaseMemoryAllocator, params: GLAllocationParams) => GLBaseMemory | null
        /**
         * Also see gst_memory_copy();
         * @since 1.8
         * @param mem a #GstGLBaseMemory
         * @param offset the offset to copy from
         * @param size the number of bytes to copy
         * @returns the newly copied #GstGLMemory or %NULL
         */
        type GLBaseMemoryAllocatorCopyFunction = (mem: GLBaseMemory, offset: number, size: number) => GLBaseMemory | null
        /**
         * As this virtual method is called with an OpenGL context current, use this
         * function to allocate and OpenGL resources needed for your application
         * @throws {GLib.Error}
         * @since 1.8
         * @param mem a #GstGLBaseMemory
         * @returns whether the creation succeeded
         */
        type GLBaseMemoryAllocatorCreateFunction = (mem: GLBaseMemory) => boolean
        /**
         * Destroy any resources allocated throughout the lifetime of @mem
         * @since 1.8
         * @param mem a #GstGLBaseMemory
         */
        type GLBaseMemoryAllocatorDestroyFunction = (mem: GLBaseMemory) => void
        /**
         * Also see gst_memory_map();
         * @since 1.8
         * @param mem a #GstGLBaseMemory
         * @param info a #GstMapInfo to map with
         * @param maxsize the size to map
         * @returns the mapped pointer
         */
        type GLBaseMemoryAllocatorMapFunction = (mem: GLBaseMemory, info: Gst.MapInfo, maxsize: number) => never | null
        /**
         * Also see gst_memory_unmap();
         * @since 1.8
         * @param mem a #GstGLBaseMemory
         * @param info a #GstMapInfo to map with
         */
        type GLBaseMemoryAllocatorUnmapFunction = (mem: GLBaseMemory, info: Gst.MapInfo) => void
        /**
         * Represents a function to run in the GL thread with @context and @data
         * @param context a #GstGLContext
         * @param data user data
         */
        type GLContextThreadFunc = (context: GLContext, data: never | null) => void
        /**
         * @since 1.10
         * @param filter the #GstGLFilter
         * @param in_tex the input #GstGLMemory to render
         * @returns whether the render succeeded
         */
        type GLFilterRenderFunc = (filter: GLFilter, in_tex: GLMemory) => boolean
        /**
         * callback definition for operating through a #GstGLFramebuffer object
         * @param stuff user data
         */
        type GLFramebufferFunc = (stuff: never | null) => boolean
        /**
         * @param data
         */
        type GLWindowCB = (data: never | null) => void
        /**
         * @param data
         * @param width
         * @param height
         */
        type GLWindowResizeCB = (data: never | null, width: number, height: number) => void
    }

    export default GstGL
}