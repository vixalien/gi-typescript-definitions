
/// <reference path="./GLib-2.0.d.ts" />
/// <reference path="./GModule-2.0.d.ts" />
/// <reference path="./GObject-2.0.d.ts" />
/// <reference path="./Gio-2.0.d.ts" />

/**
 * Type Definitions for GJS (https://gjs.guide/), generated by [GirGen](https://github.com/aylur/girgen)
 * If you found a bug, create a bug report on [GirGen's Repository](https://github.com/aylur/girgen/issues/new)
 */
declare module "gi://GCab?version=1.0" {
    import type GLib from "gi://GLib?version=2.0"
    import type GModule from "gi://GModule?version=2.0"
    import type GObject from "gi://GObject?version=2.0"
    import type Gio from "gi://Gio?version=2.0"

    


    namespace GCab {
        const __name__: "GCab"
        const __version: "1.0"
        

        namespace Cabinet {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "reserved": Uint8Array
                "signature": Uint8Array
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "reserved": Uint8Array
                "signature": Uint8Array
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * An opaque object holding a Cabinet file reference.
         */
        interface Cabinet extends GObject.Object {
            readonly $signals: Cabinet.SignalSignatures
            readonly $readableProperties: Cabinet.ReadableProperties
            readonly $writableProperties: Cabinet.WritableProperties
            readonly $constructOnlyProperties: Cabinet.ConstructOnlyProperties
            /**
             */
            get reserved(): Uint8Array
            set reserved(value: Uint8Array)
            /**
             */
            get signature(): Uint8Array
            set signature(value: Uint8Array)
            /**
             * Adds a compression kind to the allow-list. By default, GCab will use all decompression support
             * compiled in at build time. Once this function has been called only specific compression kinds
             * will be used in functions like gcab_cabinet_load().
             * @since 1.6
             * @param compression a #GCabCompression kind, e.g. %GCAB_COMPRESSION_MSZIP
             */
            add_allowed_compression(compression: Compression): void
            /**
             * Add @folder to @cabinet.
             * @throws {GLib.Error}
             * @param folder a #GCabFolder
             * @returns %TRUE on success.
             */
            add_folder(folder: Folder): boolean
            /**
             * Extract files to given path.
             *
             * If @path is NULL then the files are decompressed to memory blobs stored on
             * each #GCabFile.
             * @throws {GLib.Error}
             * @param path the path to extract files
             * @param file_callback an optional #GCabFile callback,
                return %FALSE to filter out or skip files.
             * @param progress_callback a progress callback
             * @param cancellable optional #GCancellable object,
                %NULL to ignore
             * @returns %TRUE on success.
             */
            extract(path: Gio.File | null, file_callback: FileCallback | null, progress_callback: Gio.FileProgressCallback | null, cancellable: Gio.Cancellable | null): boolean
            /**
             * Extract files to given path.
             * @throws {GLib.Error}
             * @param path the path to extract files
             * @param file_callback an optional #GCabFile callback,
                return %FALSE to filter out or skip files.
             * @param cancellable optional #GCancellable object,
                %NULL to ignore
             * @returns %TRUE on success.
             */
            extract_simple(path: Gio.File, file_callback: FileCallback | null, cancellable: Gio.Cancellable | null): boolean
            /**
             * Get the Cabinet folders within the @cabinet.
             * Note that Cabinet folders are not like filesystem path, they are
             * group of files sharing some layout parameters.
             * @returns an array of #GCabFolder
             */
            get_folders(): Folder[]
            /**
             * Lookup the cabinet authenticode signature if any.
             * @throws {GLib.Error}
             * @since 0.5
             * @param cancellable optional #GCancellable object,
                %NULL to ignore
             * @returns the array containing the PKCS#7 signed data or %NULL on error.
             */
            get_signature(cancellable: Gio.Cancellable | null): Uint8Array
            /**
             * Get the size of the compressed cabinet file.
             * @since 1.0
             * @returns size in bytes
             */
            get_size(): number
            /**
             * Load a cabinet archive.
             * @throws {GLib.Error}
             * @param stream a #GInputStream
             * @param cancellable optional #GCancellable object,
                %NULL to ignore
             * @returns %TRUE on success
             */
            load(stream: Gio.InputStream, cancellable: Gio.Cancellable | null): boolean
            /**
             * Save @cabinet to the output stream @out. @out must be a #GSeekable.
             * @throws {GLib.Error}
             * @param stream a #GOutputStream also #GSeekable
             * @param file_callback report current file being saved
             * @param progress_callback report saving progress
             * @param cancellable optional #GCancellable object,
                %NULL to ignore
             * @returns %TRUE on success.
             */
            write(stream: Gio.OutputStream, file_callback: FileCallback | null, progress_callback: Gio.FileProgressCallback | null, cancellable: Gio.Cancellable | null): boolean
            /**
             * Save @cabinet to the output stream @out. @out must be a #GSeekable.
             * @throws {GLib.Error}
             * @param stream a #GOutputStream also #GSeekable
             * @param file_callback report current file being saved
             * @param cancellable optional #GCancellable object,
                %NULL to ignore
             * @returns %TRUE on success.
             */
            write_simple(stream: Gio.OutputStream, file_callback: FileCallback | null, cancellable: Gio.Cancellable | null): boolean
        }

        interface CabinetClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Cabinet>
            readonly prototype: Cabinet
            new (props?: Partial<GObject.ConstructorProps<Cabinet>>): Cabinet
            /**
             * Create a new #GCabCabinet object to read or create a Cabinet
             * archive.
             * @returns a new #GCabCabinet
             */
            "new"(): Cabinet
        }

        const Cabinet: CabinetClass
        

        namespace File {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "bytes": GLib.Bytes
                "file": Gio.File
                "name": string
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "bytes": GLib.Bytes
                "file": Gio.File
                "name": string
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * An opaque object, referencing a file in a Cabinet.
         */
        interface File extends GObject.Object {
            readonly $signals: File.SignalSignatures
            readonly $readableProperties: File.ReadableProperties
            readonly $writableProperties: File.WritableProperties
            readonly $constructOnlyProperties: File.ConstructOnlyProperties
            /**
             */
            get bytes(): GLib.Bytes
            set bytes(value: GLib.Bytes)
            /**
             */
            get file(): Gio.File
            set file(value: Gio.File)
            /**
             * @default NULL
             */
            get name(): string
            set name(value: string)
            /**
             * Get the file attributes.
             * @since 0.6
             * @returns the cabinet file attributes
             */
            get_attributes(): number
            /**
             * Get the #GFile associated with @file. This will only be non-%NULL if the
             * #GCabFile has been created using gcab_file_new_with_bytes().
             * @since 1.0
             * @returns the associated #GBytes or %NULL
             */
            get_bytes(): GLib.Bytes
            /**
             * Get the file date, in @result.
             * @since 0.6
             * @param result a #GTimeVal to return date
             * @returns %TRUE if `tv` was set
             */
            get_date(result: GLib.TimeVal): boolean
            /**
             * Gets the file date and returns it as a #GDateTime..
             * @since 1.4
             * @returns file date, or NULL if unknown.
             */
            get_date_time(): GLib.DateTime
            /**
             * Get the file name to use for extraction, or %NULL.
             * @returns a file name
             */
            get_extract_name(): string | null
            /**
             * If the cabinet is being created, get the #GFile associated with
             * @file. This must be an exisiting file that can be read, in order to
             * be added to the archive during cabinet creation.
             *
             * If @file is from an existing cabinet, the fuction will return
             * %NULL.
             * @returns the associated #GFile or %NULL
             */
            get_file(): Gio.File
            /**
             * Get the file name within the cabinet.
             * @returns the cabinet file name
             */
            get_name(): string
            /**
             * Get the file size.
             * @since 0.6
             * @returns the cabinet file size
             */
            get_size(): number
            /**
             * Set the file attributes.
             * @since 1.0
             * @param attr the attributes, e.g. %GCAB_FILE_ATTRIBUTE_RDONLY
             */
            set_attributes(attr: number): void
            /**
             * Replace the #GBytes associated with @self.
             * This is most usefule when the #GCabFile has been created using
             * gcab_file_new_with_bytes() and the data needs to be modified.
             * @since 1.5
             * @param bytes a #GBytes
             */
            set_bytes(bytes: GLib.Bytes): void
            /**
             * Sets the file modification date, instead of the value provided by the GFile.
             * @since 1.0
             * @param tv a #GTimeVal
             */
            set_date(tv: GLib.TimeVal): void
            /**
             * Sets the file modification date (instead of the date provided by the GFile)
             * @since 1.4
             * @param dt a #GDateTime
             */
            set_date_time(dt: GLib.DateTime): void
            /**
             * Sets the file name to use for extraction, instead of the name
             * provided by the Cabinet.
             * @param name a file name or %NULL
             */
            set_extract_name(name: string | null): void
        }

        interface FileClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<File>
            readonly prototype: File
            new (props?: Partial<GObject.ConstructorProps<File>>): File
            /**
             * Create a #GCabFile from a given #GBytes.
             *
             * If this file is to be added to an archive you should also probably use
             * gcab_file_set_date() and gcab_file_set_attributes() to set sensible values.
             * @since 1.0
             * @param name name of the file within the cabinet
             * @param bytes a #GBytes to be added to the cabinet
             * @returns a new #GCabFile
             */
            new_with_bytes(name: string, bytes: GLib.Bytes): File
            /**
             * Create a #GCabFile from a given #GFile, to be added to a
             * #GCabCabinet for archive creation.
             * @param name name of the file within the cabinet
             * @param file a #GFile to be added to the cabinet
             * @returns a new #GCabFile
             */
            new_with_file(name: string, file: Gio.File): File
        }

        const File: FileClass
        

        namespace Folder {
            interface SignalSignatures extends GObject.Object.SignalSignatures {
            }

            interface ReadableProperties extends GObject.Object.ReadableProperties {
                "compression": Compression
                "comptype": number
                "reserved": Uint8Array
            }

            interface WritableProperties extends GObject.Object.WritableProperties {
                "compression": Compression
                "comptype": number
                "reserved": Uint8Array
            }

            interface ConstructOnlyProperties extends GObject.Object.ConstructOnlyProperties {
            }
        }

        /**
         * An opaque object, referencing a folder in a Cabinet.
         */
        interface Folder extends GObject.Object {
            readonly $signals: Folder.SignalSignatures
            readonly $readableProperties: Folder.ReadableProperties
            readonly $writableProperties: Folder.WritableProperties
            readonly $constructOnlyProperties: Folder.ConstructOnlyProperties
            /**
             * @default GCAB_COMPRESSION_NONE
             */
            get compression(): Compression
            set compression(value: Compression)
            /**
             * @default 0
             */
            get comptype(): number
            set comptype(value: number)
            /**
             */
            get reserved(): Uint8Array
            set reserved(value: Uint8Array)
            /**
             * Add @file to the #GCabFolder.
             * @throws {GLib.Error}
             * @param cabfile file to be added
             * @param recurse whether to recurse through subdirectories
             * @param cancellable optional #GCancellable object,
                %NULL to ignore
             * @returns %TRUE on succes
             */
            add_file(cabfile: File, recurse: boolean, cancellable: Gio.Cancellable | null): boolean
            /**
             * Returns the compression used in this folder.
             * @since 1.0
             * @returns a #GCabCompression, e.g. %GCAB_COMPRESSION_MSZIP
             */
            get_comptype(): number
            /**
             * Gets a specific #GCabFile files contained in the @cabfolder.
             * @param name a file name
             * @returns A #GCabFile, or %NULL if not found
             */
            get_file_by_name(name: string): File
            /**
             * Get the list of #GCabFile files contained in the @cabfolder.
             * @returns list of files
             */
            get_files(): File[]
            /**
             * Get the number of files in this @folder.
             * @returns a #guint
             */
            get_nfiles(): number
        }

        interface FolderClass extends Omit<GObject.ObjectClass, "new"> {
            readonly $gtype: GObject.GType<Folder>
            readonly prototype: Folder
            new (props?: Partial<GObject.ConstructorProps<Folder>>): Folder
            /**
             * Creates a new empty Cabinet folder. Use gcab_folder_add_file() to
             * add files to an archive.
             *
             * A Cabinet folder is not a file path, it is a container for files.
             * @param comptype compression to used in this folder
             * @returns a new #GCabFolder
             */
            "new"(comptype: number): Folder
        }

        const Folder: FolderClass
        none
        none
        none
        /**
         */
        function error_quark(): GLib.Quark
        
        namespace Compression {
            const $gtype: GObject.GType<Compression>
        }

        /**
         * Compression used by the #GCabFolder.
         */
        enum Compression {
            /**
             * No compression.
             */
            "NONE" = 0,
            /**
             * MSZIP compression.
             */
            "MSZIP" = 1,
            /**
             * QUANTUM compression (unsupported).
             */
            "QUANTUM" = 2,
            /**
             * LZX compression (only decompression supported).
             */
            "LZX" = 3,
            /**
             * compression value mask.
             */
            "MASK" = 15,
        }
        
        abstract class Error extends GLib.Error {
            static readonly $gtype: GObject.GType<Error>
            /**
             * The given file is not of Cabinet format.
             */
            static readonly "FORMAT": 0
            /**
             * General function failure.
             */
            static readonly "FAILED": 1
            /**
             * Action or format is not supported
             */
            static readonly "NOT_SUPPORTED": 2
            /**
             * Data stream was invalid
             */
            static readonly "INVALID_DATA": 3
        }
        
        namespace FileAttribute {
            const $gtype: GObject.GType<FileAttribute>
        }

        /**
         * Attributes associated with the #GCabFile.
         */
        enum FileAttribute {
            /**
             * file is read-only
             */
            "RDONLY" = 1,
            /**
             * file is hidden
             */
            "HIDDEN" = 2,
            /**
             * file is a system file
             */
            "SYSTEM" = 4,
            /**
             * file modified since last backup
             */
            "ARCH" = 32,
            /**
             * run after extraction
             */
            "EXEC" = 64,
            /**
             * name contains UTF
             */
            "NAME_IS_UTF" = 128,
        }
        /**
         * The type used for callback called when processing Cabinet archive
         * files.
         * @param file the file being processed
         */
        type FileCallback = (file: File) => boolean
    }

    export default GCab
}